(***********************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which typically
will have the same name as this file except ending in ".nb" instead of
".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent to
using the Evaluate Initialization Cells menu command in the front end.

DO NOT EDIT THIS FILE.  This entire file is regenerated automatically 
each time the parent Notebook file is saved in the Mathematica front end.
Any changes you make to this file will be overwritten.
***********************************************************************)



































(*:Title:BumpEtc.m -- a package containing miscellaneous systemutilities  *) 

(* :Context: JMJUtils`BumpEtc` *)

(* :Author: John M. Jowett *)

(* :Summary:  *)

(* :Copyright: \[Copyright] 1997 by CERN *)

(* :Package Version: 1.0 *)

(* :Mathematica Version: 3.0 *)

(*:History:
  1.0 6 June 1997 split off from Imperfections.m
					Various additions not documented
	  1.2 20 January 1999 added packageSourceDirectory, etc.
*)

(* :Keywords: System Files Bump Links *)

(* :Sources:  *)

(*:Warnings:
   <description of global effects,incompatibilities>
*)


(* :Limitations:
   <special cases not handled, known problems>
*)

(* :Discussion:
   <description of algorithm,information for experts>
*)

(* :Requirements:
   
*)

(*:Examples:
  <sample input that demonstrates the features of thispackage>
*)                               



BeginPackage["JMJUtils`BumpEtc`"]



onPC::usage =
    "A logical value which says if we are running on a PC.  Otherwise a Unix \
environment is assumed.  This is used to select directories.";

$AfsRoot::usage="$AfsRoot is a string defining the root directory of the AFS \
system."

AfsHomeDirectory::usage="AfsHomeDirectory[user] returns a string defining a \
user's AFS home directory under CERN Unix or CERN Windows NT with the AFS \
client.  The default value of the string user is the current user's id."

makeBatchScript::usage="makeBatchScript[mathFile,batchFile] creates a batch \
job script for the CERN batch system that will run the commands in the file \
mathFile."

toWindowsFileName::usage="toWindowsFileName[unixFileName] converts an AFS \
file's complete name under CERN Unix to the corresponding name under CERN \
Windows NT with the AFS client."

toUnixFileName::usage="toUnixFileName[windowsFileName] converts an AFS file's \
complete name under CERN Windows NT with the AFS client to the corresponding \
name under CERN Unix ."

explorer::usage="explorer[dirspec] opens a Windows Explorer window in a \
specified directory. This can be given as an explicit string or as an \
operating systen independent path (as for ToFileName).  Under CERN Windows NT \
with the AFS client, explicit Unix format directory names will work."

dirJoin::usage="dirJoin[dir1,subdir1,subdir2] constructs the name of a \
directory path from a sequence of strings, dealing quite robustly with the \
separating symbols as appropriate for the operating system.";

newFileName::usage=
    "newFileName[\"ext\"] constructs a new file name with the extension .ext \
that is not already used in the current directory.";

ThisNotebookDirectory::usage="ThisNotebookDirectory[] returns the
directory of the file containing the current notebook.  If the file has
not been saved, the current working directory is returned.\nIntended
usage is SetDirectory[ThisNotebookDirectory[]].";

packageSourceDirectory::usage="packageSourceDirectory[\"package\"] returns \
the list of directories where the source of the first currently loaded \
package containing \"package\" in its context string might be located."

packageSourceNotebook::usage="packageSourceNotebook[\"package\"] returns the \
name of a notebook that may be the source of the first currently loaded \
package containing \"package\" in its context string."

UnixLinkQ::usage:="UnixLinkQ[filename] returns True if a file exists with the \
name filename and is a Unix link."

makeShortLinks::usage =
    "makeShortLinks[linkRules] issues Unix commands to set up the links \
defined in linkRules.";

shortFileName::usage =
    "shortFileName[filename] shortens a file name (including a path) by using \
any applicable links in the list linkRules.";

bumpFileName::usage =
    "bumpFileName[file] returns a unique name for a backup copy of a file, \
using the current date and time.";

bumpFile::usage =
    "bumpFile[file] saves a backup copy of a file in the local TRASH \
directory. This is created if it does not already exist.";

generateLaunchScript::usage=
    "generateLaunchScript[cmd,dirs,scriptname] will create a Unix shell \
script, named scriptname, that will execute the command cmd in each of the \
directories in the list dirs.";

stringReplaceInFile::usage=
    "stringReplaceInFile[\"file1\",\"file2\",\"s1\" -> \"sp1\"] or \
stringReplaceInFile[\"file1\",\"file2\", {\"s1\" -> \"sp1\", \"s2\" -> \
\"sp2\", ... }] creates a new file, file2, from file1 using StringReplace to \
apply  string substitution rules to each record in file1. \nIf file2=file1 \
then the original file is replaced.";

DOStoUnix::usage="DOStoUnix[\"file\"] changes the DOS line end characters in \
a file to Unix ones.";

domain::usage="domain[f] returns a list of values (or patterns) for which the \
function f is defined." 

UsageNotebook::usage="UsageNotebook[Names[\"Li*\"]] will create a new \
notebook containing the usage messages for all functions whose names start \
with Li.";

UsageCells::usage="UsageCells[Names[\"Li*\"]] will generated formatted cells \
containing the usage messages for all functions whose names start with Li.";



BumpEtc::badarg ="You called `1` with argument `2`!" ;                     

explorer::notWindows="Can't call Windows Explorer; kernel running on wrong \
operating system.";

nbdir::"nofile"="This notebook has not been saved.";



Begin["`Private`"] ;





onPC=Length[StringPosition[$Version,"Windows"]]>0







Clear[dirJoin];
dirJoin[a_List]:=Apply[dirJoin,a];
		dirJoin[a_String, b_String] :=Block[{psep}, 
		psep = If[onPC, "\\", "/"];
		StringReplace[StringJoin[a, psep, b]
		, {"///"->psep,"//" -> psep,"\\\\\\"->psep ,"\\\\" -> psep}]
	];
dirJoin[a_List,b]:=dirJoin[dirJoin[a],b];
dirJoin[a_,b_]:=dirJoin[ToString[a],ToString[b]];
dirJoin[a_,b_,c__]:=dirJoin[dirJoin[a,b],c]



UnixLinkQ[fn_String]:=If[onPC,False,
		StringMatchQ[First[Join[ReadList["!ls -l "<>fn,String],{" "}]],"*->*"]
	]

SetAttributes[UnixLinkQ,Listable]



ThisNotebookDirectory[]:=
  Block[{info=NotebookInformation[InputNotebook[]]},
    If[FreeQ[info,"FileName",{2}],Message[nbdir::nofile];
      Directory[],ToFileName[First["FileName"/.info]]]];





$AfsRoot=If[$OperatingSystem=="Unix","/afs","P:"]



AfsHomeDirectory[username_String:$UserName]:=
  ToFileName[{$AfsRoot,"cern.ch","user",StringTake[username,1],username}]









makeBatchScript[mathFile_String,batchFile_String]:=Block[{
			headFile=
        ToFileName[{AfsHomeDirectory["jowett"],"public","scripts"},
          "MathBatchHead.csh"],
			tailFile=
        ToFileName[{AfsHomeDirectory["jowett"],"public","scripts"},
          "MathBatchTail.csh"],
			tempFile="makeBatchScript.temp.orary.junk",
			batchJobName=StringReplace[mathFile,{".m"\[Rule]""}],
			mathInput,tail,jobStream
		},
		bumpFile[batchFile];
		Splice[headFile,tempFile,FormatType\[Rule]OutputForm];
		head=ReadList[tempFile,String];
		DeleteFile[tempFile];
		mathInput=
      StringReplace[#,{"$"->"\$","`"\[Rule]"\`","\""\[Rule]"\\\"",
              "\t"\[Rule]"   "}]& /@ ReadList[mathFile,String];
		tail=ReadList[tailFile,String];
		jobStream=OpenWrite[batchFile,DOSTextFormat\[Rule]False];
		Write[jobStream,OutputForm[#]]&/@ Flatten[{ head,mathInput,tail}];
		Close[jobStream]
	]





toWindowsFileName[unixFilename_]:=
  StringReplace[unixFilename,{"/afs"\[Rule]$AfsRoot,"/"\[Rule]"\\"}]

toUnixFileName[windowsFilename_]:=
  StringReplace[
    windowsFilename,{$AfsRoot\[Rule]"/afs","\\\\"\[Rule]"/","\\"\[Rule]"/"}]





explorer[dir_String]:=
  If[StringMatchQ[$OperatingSystem,"Windows*"], 
    Module[
      {windir=toWindowsFileName[dir]},
      ReadList["!explorer "<>windir,Record];
      Return[windir]
      ],
    Message[explorer::notWindows];
    Return[dir]
    ]





explorer[mdir_List]:=explorer[ToFileName[mdir]]



explorer[]:=explorer[Directory[]]











packageSourceDirectory[package_String]:=
	Module[{mdir},
		mdir=DirectoryName[
        ContextToFilename[
          First[Select[Contexts[],StringMatchQ[#,"*"<>package<>"*"]&]]
				]];Select[ (ToFileName[{#,mdir}]& /@ $Path),FileType[#]==Directory&]
		]

packageSourceNotebook[package_String]:=
  ToFileName[Take[packageSourceDirectory[package],1],package<>".nb"]





makeShortLinks[linkrule_Rule]:=
	If[onPC,
		Print["On Unix would link: ",Reverse[linkrule]],
      Run["ln -sf "<>First[linkrule]<>" "<>Last[linkrule]] 
		];
makeShortLinks[linkrules_List]:=
  Map[makeShortLinks,
    Sort[linkrules,({1,-1}.StringLength /@List@@ ( #1)>{1,-1}.StringLength /@ 
                List@@  (#2))&]]



shortFileName[fn_String]:=StringReplace[fn,Global`linkRules] 





newFileName[ext_]:=
	"autoFile"<>
    ToString[1+
        Max[ToExpression[
            StringReplace[{"0"}\[Union]FileNames[
                  "autoFile*."<>ext],{"autoFile"->"","."<>ext->""}]]]
			]<>"."<>ext







bumpFileName[fn_String]:=
  fn<>Apply[StringJoin,Map[("_"<>ToString[#])&,FileDate[fn]]]



bumpFile[fn_String]:=Block[{tfn},
		If[FileNames["TRASH"]=={},CreateDirectory["TRASH"]];
		If[FileNames[fn]=={},$Failed,
			tfn=CopyFile[fn,dirJoin["TRASH",bumpFileName[fn]]];	DeleteFile[fn];tfn
			]
	]





generateLaunchScript[cmd_String,dirs_List,scriptName_String]:= 
Block[{cmd1,cmd2},
		bumpFile[scriptName];
		script=OpenWrite[scriptName];
		WriteString[script,"#!/usr/bin/sh  \n"];
		WriteString[script,
      "# Created by generateLaunchScript at "<>ToString[Date[]],"\n"];
		Map[(WriteString[script,"cd ",#,"\n"
						                               ,cmd,"\n",
					                                 "cd ..","\n"]
			)&,dirs];
		Close[script];
		Run["chmod u+x "<>scriptName]
		]





stringReplaceInFile[file1_,file2_,reprule_Rule]:=
    stringReplaceInFile[file1,file2,{reprule}];
stringReplaceInFile[file1_,file2_,reprules:{Rule__}]:=
    Module[{f1,f2,lines,newlines},
		f1 = OpenRead[file1];
		lines=ReadList[f1,Record];
		newlines = StringReplace[#,reprules] &/@ lines;
		Close[f1];
		f2=OpenWrite[file2,DOSTextFormat\[Rule]False];
		Do[WriteString[f2, newlines[[k]],"\n"],{k,1,Length[newlines]}];
		Close[f2]
		];






DOStoUnix[file_]:=stringReplaceInFile[file,file,{"DDD"\[Rule]"DDD"}]

DOStoUnix[files_List]:=DOStoUnix/@files



domain[f_]:=Cases[DownValues[f],HoldPattern[f[j_]]->j,{3}]





UsageNotebook[cmds:{__String}] :=
  NotebookPut[
    Notebook[Flatten[{Cell[#,"Section"],
              Cell[MessageName[#,"usage"]&[ToExpression[#]],"Text"]}&/@cmds],
      StyleDefinitions\[Rule]"Report.nb"]]



UsageCells[cmds:{__String}] :=
  Scan[(StylePrint[#,"Subsection"];
        StylePrint[MessageName[#,"usage"]&[ToExpression[#]],"Text"])&,cmds]





End[ ]        



Protect[ onPC,dirJoin,bumpFile,bumpFileName,makeShortLinks,shortFileName,\
stringReplaceInFile,domain]    



EndPackage[ ]  





























































































































































































































