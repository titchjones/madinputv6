(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

BeginPackage["EPOptimise`",{"Statistics`NormalDistribution`"}];

EPOptimise::usage="EPOptimise[Objective Function, No Of Chromosomes, Iterations, Prob. of Crossover, Prob. of Mutation, Genes per Chrom., Start of range, End of range, Options (see EPOptimise[Options])]\nEPOptimise is a MAXIMISING Function!";

EPOptimise::Options=
  "EPOptimise supports 3 possible options: SelectionMethod, BreedingPool, ReinsertionMethod;\nSee EPOptimise[<Option Name>];"



EPOptimise::SelectionMethod=
  "SelectionMethod specifies one of 4 methods for selecting the possible breeding population.\nThe options are:\nRoulette\nUniversal\nTruncation\nTournament"



EPOptimise::Roulette=
  "In the Roulette SelectionMethod The individuals are mapped to contiguous segments of a line, such that each individual's segment is equal in size to its fitness. A random number is generated and the individual whose segment spans the random number is selected. This is repeated to select the breeding population required."



EPOptimise::Universal=
  "In the Universal SelectionMethod the individuals are mapped to contiguous segments of a line, such that each individual's segment is equal in size to its fitness exactly as in Roulette selection. Here equally spaced pointers are placed over the line as many as there are individuals to be selected, and the breeding population thus chosen."



EPOptimise::Truncation=
  "In Truncation selection individuals are sorted according to their fitness. Only the best individuals are selected for parents. The parameter for truncation selection is the TruncationThreshold. TruncationThreshold indicates the proportion of the population to be selected as parents and takes values ranging from 50%-10%. Individuals below the truncation threshold do not produce offspring."



EPOptimise::TruncationThreshold=
  "TruncationThreshold indicates the proportion of the population to be selected as parents in the Truncation SelectionMethod, and takes values ranging from 50%-10%."



EPOptimise::Tournament=
  "In Tournament selection a number TournamentNumber of individuals is chosen randomly from the population and the best individual from this group is selected as a parent. This process is repeated as often as individuals must be chosen."



EPOptimise::TournamentNumber="TournamentNumber is the number of individuals to be tested in each tournament round in the Tournament SelectionMethod." 



EPOptimise::BreedingPool=
  "The BreedingPool is the size of the breeding population at each iteration. This is the total possible breeding population, and not all individuals chosen will breed. See EPOptimise[Breeding]."



EPOptimise::Breeding=
  "When breeding individuals, the breeding population is chosen using the SelectionMethod variable and the BreedingPool size. The chance of these individuals then breeding is determined randomly using the Crossover Probability. The breeding is then performed using one of the CrossoverMethod's (Not yet implemented), and reinsertion of the resulting offspring is performed according to the ReinsertionMethod."



EPOptimise::ReinsertionMethod=
  "ReinsertionMethod specifies the algorithm for reinserting the offspring back into the main population. It is dependant on the choice of BreedingPool relative to the population size. The methods are:\nBreedingPool = Population Size  \[Rule]  Pure\nBreedingPool < Population Size  \[Rule]  Elitist or Uniform\nBreedingPool > Population Size  \[Rule]  Fitness"



EPOptimise::Pure=
  "In Pure reinsertion the parents are completely replaced with their offspring. Because not all parents reproduce (see EPOptimise[Breeding]), some offspring are clones of their parents."



EPOptimise::Elitist=
  "In Elitist reinsertion the worst parents are replaced by the offspring. Elitist reinsertion requires BreedingPool to be less than the population Size."



EPOptimise::Uniform=
  "In Uniform reinsertion the offspring randomly replace some of the parents. This is analogous to Pure reinsertion when BreedingPool < Population Size."



EPOptimise::Fitness=
  "In Fitness reinsertion the fittest offspring replace all of the parents. This requires BreedingPool > Population Size. The Fitness ReinsertionMethod has a penalty in terms of computational efficiency as the fitness of all offspring must be evaluated in addition to that required in evaluating the chosen SelectionMethod."



GetIterationNumber::usage="Returns Latest Iteration Number from EPOptimise."



Begin["`Private`"]





EPOptimise[]:=?EPOptimise

EPOptimise[help_]:=
  Print[ToExpression[Evaluate["EPOptimise::"<>ToString[help]]]]



RandomUnion[no_]:=Block[{randlist=Range[no],rand,randno},
    Table[(rand=Random[Integer,{1,Length[randlist]}];
        randno=randlist\[LeftDoubleBracket]rand\[RightDoubleBracket];
        randlist=Drop[randlist,{rand}];randno),{no}]
    ]

RandomUnion[no_,subno_]:=Block[{randlist=Range[no],rand,randno},
    Table[(rand=Random[Integer,{1,Length[randlist]}];
        randno=randlist\[LeftDoubleBracket]rand\[RightDoubleBracket];
        randlist=Drop[randlist,{rand}];randno),{subno}]
    ]



CreateChrom[number_,numbers_Integer,start_List,end_List]:=
  Table[Random[
          Real,{start\[LeftDoubleBracket]#\[RightDoubleBracket],
            end\[LeftDoubleBracket]#\[RightDoubleBracket]}]&/@
      Range[numbers],{number}]

CreateChrom[number_,numbers_Integer,start_Real|start_Integer,end_List]:=
  Table[Random[Real,{start,end\[LeftDoubleBracket]#\[RightDoubleBracket]}]&/@
      Range[numbers],{number}]

CreateChrom[number_,numbers_Integer,start_List,end_Real|end_Integer]:=
  Table[Random[Real,{start\[LeftDoubleBracket]#\[RightDoubleBracket],end}]&/@
      Range[numbers],{number}]

CreateChrom[number_,numbers_Integer,start_Real|start_Integer,
    end_Real|end_Integer]:=
  Table[Random[Real,{start,end}]&/@Range[numbers],{number}]

FitnessAll[list_,rawdata_,fitdata_]:=(FitnessValue[#]&/@list)

FitnessAll[list_,number_,rawdata_,
    fitdata_]:=(If[MemberQ[Partition[Flatten[Drop[rawdata,-1]],number],#],
          Flatten[fitdata]\[LeftDoubleBracket]
            Position[
                Partition[Flatten[Drop[rawdata,-1]],
                  number],#]\[LeftDoubleBracket]1,
              1\[RightDoubleBracket]\[RightDoubleBracket],
          FitnessValue[#]]&/@(#&/@list))

CumulativeProbabilities[list_,number_,start_,range_,rawdata_,fitdata2_]:=
  Block[{a},
    a=FitnessAll[list,number,rawdata,fitdata2];
    AppendTo[fitdata,a];
    Rest[FoldList[Plus,0,a/Total[a]]]
    ]

randomnumbers[number_]:=(SeedRandom[];Table[Random[Real,{0,1}],{number}])

selectionmethods={Global`Roulette,Global`Universal,Global`Truncation,
    Global`Tournament}



SelectionRoulette[list_,probab_,number_,opts___]:=
  Block[{a,random=randomnumbers[number]},
    list\[LeftDoubleBracket]breedinglist=(a=#;
              Length[Select[probab,#<a&]]+1)&/@random\[RightDoubleBracket]]

\!\(SelectionUniversal[list_, probab_, number_, opts___] := Block[{a, linear = Range[Random[Real, {0, 1\/number}], 1, 1\/number]}, \[IndentingNewLine]list\[LeftDoubleBracket]breedinglist = \(\((a = #; \[IndentingNewLine]Length[Select[probab, # < a &]] + 1)\) &\) /@ linear\[RightDoubleBracket]]\)

SelectionTruncation[list_,probab_,number_,opts___]:=Block[{a,b},
    threshold=
      Global`TruncationThreshold/.{opts}/.{Global`TruncationThreshold\[Rule]0.\
5};
    If[printedsetting=!=True,
      Print["Using TruncationThreshold \[Rule] "<>ToString[threshold]];
      printedsetting=True];
    a=MapThread[Subtract,{probab,Prepend[Most[probab],0]}];
    b=Sort[
        Transpose[{a,
            list}],#1\[LeftDoubleBracket]1\[RightDoubleBracket]<#2\
\[LeftDoubleBracket]1\[RightDoubleBracket]&];
    c=Take[b,-Round[threshold*Length[list]]];
    (*Print["Number selected = ",-Round[threshold*Length[list]]];*)
    breedinglist=
      Position[list,#]\[LeftDoubleBracket]1,1\[RightDoubleBracket]&/@
        c\[LeftDoubleBracket]All,2\[RightDoubleBracket];
    (*Print["breedinglist = ",breedinglist];*)
    c\[LeftDoubleBracket]All,2\[RightDoubleBracket]\[LeftDoubleBracket]
      Table[Random[Integer,{1,Length[c]}],{Length[c]}]\[RightDoubleBracket]
    ]

SelectionTournament[list_,probab_,number_,opts___]:=
  Block[{a=MapThread[Subtract,{probab,Prepend[Most[probab],0]}],b=a},
    tour=Global`TournamentNumber/.{opts}/.{Global`TournamentNumber\[Rule]
            Ceiling[number/5]};
    If[printedsetting=!=True,
      Print["Using TournamentNumber \[Rule] "<>ToString[tour]];
      printedsetting=True];
    Table[(a=ReplacePart[a,0,#];AppendTo[breedinglist,#];
            list\[LeftDoubleBracket]#\[RightDoubleBracket])&[
        Position[a,Max[#]]\[LeftDoubleBracket]1,1\[RightDoubleBracket]&[
          a\[LeftDoubleBracket]Table[
              Random[Integer,{1,
                  Length[list]}],{tour}]\[RightDoubleBracket]]],{number}]
    ]

bin6[b_,c_]:=b[[#]]&/@Split[Ordering[c],c[[#1]]\[Equal]c[[#2]]&];

Clear[SelectforCrossover]

SelectforCrossover[list_,numbers_:5,pc_:0.25]:=
  Block[{a,crossdatalist,positionsofcross,d,e,f,g,h},
    (*Generate enough random numbers*)
    a=randomnumbers[numbers];
    
    (*positions where random no is less than chance of crossing*)
    positionsofcross=Flatten[Position[a,_?(#<pc&)]];
    
    (*elements of list that are to be crossed*)
    crossdatalist=(list\[LeftDoubleBracket]#\[RightDoubleBracket])&/@
        positionsofcross;
    
    (*if total number of crossers is odd...*)
    If[OddQ[Length[crossdatalist]],
      
      (*randomly choose to add another or drop 1, 
        unless chosen is fewer than 2 - then must add*)
      If[Random[Integer,{1,2}]===1&&Length[crossdatalist]>1,
        
        (*lets drop a gene from the list*)
        (*randomly pick which one*)
        g=Random[Integer,{1,Length[crossdatalist]}];
        
        (*in case we have more than 1 of them, randomly drop 1*)
        h=#\[LeftDoubleBracket]
                Random[Integer,{1,Length[#]}]\[RightDoubleBracket]&[
            Select[Flatten[
                Position[list,
                  crossdatalist\[LeftDoubleBracket]g\[RightDoubleBracket]]],
              MemberQ[positionsofcross,#]&]];
        
        (*edit the crossover lists*)
        positionsofcross=Select[positionsofcross,#=!=h&];
        crossdatalist=Drop[crossdatalist,{g}],
        
        (*lets add an extra gene to the list*)
        (*randomly pick one...*)
        d=Range[1,numbers];
        (*edit the crossover lists*)
        AppendTo[
          positionsofcross,(f=
              d\[LeftDoubleBracket]Random[
                  Integer,{1,Length[d]}]\[RightDoubleBracket])];
        AppendTo[crossdatalist,
          list\[LeftDoubleBracket]f\[RightDoubleBracket]];]];
    crossoverlist=positionsofcross;
    crossdatalist]



LimitedGaussianSample[mean_,sigma_,limits_List]:=Module[{a,i=0},
    While[
      (a=Random[NormalDistribution[mean,sigma]])>
          limits\[LeftDoubleBracket]2\[RightDoubleBracket]||
        a<limits\[LeftDoubleBracket]1\[RightDoubleBracket],i=i+1];
    a]



\!\(newvalue[input_List] := \(If[Max[#] - Min[#] > 0, Min[#] + LimitedGaussianSample[\(Max[#] - Min[#]\)\/2, \(Max[#] - Min[#]\)\/6, {\(-10\), 10}], #] &\) /@ Transpose[input]\)

\!\(InvDistC[x_, n_] := Switch[Random[Integer, {0, 1}], 0, 1\^\(1\/\(\(\(1.`\)\(\[InvisibleSpace]\)\) + n\)\)\ x\^\(1\/\(\(\(1.`\)\(\[InvisibleSpace]\)\) + n\)\), 1, Abs[\ \(2\^\(-\(1.`\/\(\(\(1.`\)\(\[InvisibleSpace]\)\) + n\)\)\)\) \((0.5`\[InvisibleSpace] - 1.`\ x)\)\^\(-\(1.`\/\(\(\(1.`\)\(\[InvisibleSpace]\)\) + n\)\)\)]]\)



SBX[input_List,Limits_List,betafactor_]:=Module[{absmeans,relmeans,orders,a},
    absmeans=Mean[#]&/@Transpose[input];
    relmeans=Mean[#-Min[#]]&/@Transpose[input];
    orders=Ordering[#]&/@Transpose[input];
    b=True;
    While[b,
      betas=InvDistC[Random[Real,{0,1}],betafactor];
      a=Switch[Random[Integer,{0,1}],
              1,{#\[LeftDoubleBracket]1\[RightDoubleBracket]-(#\
\[LeftDoubleBracket]2\[RightDoubleBracket]*
                        betas),#\[LeftDoubleBracket]1\[RightDoubleBracket]+(#\
\[LeftDoubleBracket]2\[RightDoubleBracket]*
                        betas)}\[LeftDoubleBracket]#\[LeftDoubleBracket]3\
\[RightDoubleBracket]\[RightDoubleBracket],
              0,#\[LeftDoubleBracket]4\[RightDoubleBracket]]&/@
          Transpose[{absmeans,relmeans,orders,Transpose[input]}];
      Print["here?"];
      b=Or@@((Min[#\[LeftDoubleBracket]1\[RightDoubleBracket]]<
                      Min[#\[LeftDoubleBracket]2\[RightDoubleBracket]]||
                    Max[#\[LeftDoubleBracket]1\[RightDoubleBracket]]>
                      Max[#\[LeftDoubleBracket]2\[RightDoubleBracket]])&/@
              MapThread[List,{a,Limits}]);Print["end here?"];
      ];
    a
    ]





































Crossover[datalist_,crosslist_,limits_,betafactor_]:=
  Block[{a={},b,c,pos,c1last,c2last,c1new,c2new,lengths},
    If[Length[crosslist]>0,
      a=RandomUnion[Length[crosslist]];
      c=Partition[(datalist\[LeftDoubleBracket]#\[RightDoubleBracket]&/@a),
          2];
      Transpose[Flatten[SBX[#,limits,betafactor]&/@c,1]],{}]]

reinsertionmethods={Global`Elitist,Global`Uniform}



ReinsertPure[olddata_,newdata_,positions_,Null___]:=Block[{a},a=olddata;
    (a=ReplacePart[
              a,#\[LeftDoubleBracket]2\[RightDoubleBracket],#\
\[LeftDoubleBracket]1\[RightDoubleBracket]])&/@Transpose[{positions,newdata}];
    a]

ReinsertFitness[olddata_,newdata_,null_,start_,end_]/;
    Length[newdata]\[GreaterEqual]Length[olddata]:=
  Block[{a,random=RandomUnion[Length[olddata]],bnewdata=newdata,fitdata},
    a=olddata;
    fitdata=FitnessValue[#]&/@bnewdata;
    (*Print["Fitdata offspring = ",fitdata];
      Print["Fitdata ordered = ",Ordering[fitdata,-Length[olddata]]];*)
    positions=Ordering[fitdata,-Length[olddata]];
    (a=ReplacePart[
              a,#\[LeftDoubleBracket]2\[RightDoubleBracket],#\
\[LeftDoubleBracket]1\[RightDoubleBracket]])&/@
      Transpose[{random,
          newdata\[LeftDoubleBracket]positions\[RightDoubleBracket]}];
    a]

ReinsertFitness[olddata_,newdata_,positions_,start_,end_]/;
    Length[newdata]<Length[olddata]:=
  ((*Print["Not enough offspring, using Reinsertion Method \[Rule] Elitist"];*)
    
    ReinsertElitist[olddata,newdata])

ReinsertUniform[olddata_,newdata_,Null___]:=
  Block[{a,positions=RandomUnion[Length[olddata],Length[newdata]]},
    (*Print["Uniform Positions = ",positions];*)
    a=olddata;
    (a=ReplacePart[
              a,#\[LeftDoubleBracket]2\[RightDoubleBracket],#\
\[LeftDoubleBracket]1\[RightDoubleBracket]])&/@
      Transpose[{positions,newdata}];
    a]

ReinsertElitist[olddata_,newdata_,Null___]:=
  Block[{a,random=RandomUnion[Length[newdata]],positions},
    a=olddata;
    positions=
      Ordering[fitdata\[LeftDoubleBracket]-1\[RightDoubleBracket]]\
\[LeftDoubleBracket]Range[
            Length[newdata]]\[RightDoubleBracket]\[LeftDoubleBracket]
        random\[RightDoubleBracket];
    (a=ReplacePart[
              a,#\[LeftDoubleBracket]2\[RightDoubleBracket],#\
\[LeftDoubleBracket]1\[RightDoubleBracket]])&/@
      Transpose[{positions,newdata}];
    a]



Mutate[list_,start_List,end_List,mr_]:=Block[{a,b},
    startend=
      Flatten[Table[Transpose[{start,end}],{Length[Flatten[list]]}],1];
    a=Flatten[list];
    b=Flatten[
        Position[Table[Random[Real,{0,1}],{Length[Flatten[a]]}],_?(#<mr&)]];
    (a=ReplacePart[a,
              Random[Real,
                startend\[LeftDoubleBracket]#\[RightDoubleBracket]],#])&/@b;
    Partition[a,Length[list\[LeftDoubleBracket]1\[RightDoubleBracket]]]
    ]

<<Statistics`ContinuousDistributions`



















Mutate[list_,start_Real|start_Integer,end_List,mr_]:=
  Block[{a,b,l=Length[end]},
    startend=
      Flatten[Table[
          Transpose[{Table[start,{l}],end}],{Length[Flatten[list]]}],1];
    a=Flatten[list];
    b=Table[Random[Real,{0,1}],{Length[Flatten[a]]}];
    f=Block[{a,b,c=#\[LeftDoubleBracket]1\[RightDoubleBracket],
              d=#\[LeftDoubleBracket]2\[RightDoubleBracket],
              e=#\[LeftDoubleBracket]3\[RightDoubleBracket],
              f=If[Random[Integer,{0,1}]===0,-1,1]},
            If[d<mr,
              
              While[c+f*#>e\[LeftDoubleBracket]2\[RightDoubleBracket]||
                      c+f*#<e\[LeftDoubleBracket]1\[RightDoubleBracket]&[
                  a=If[Random[Integer,{0,1}]===0,-1*#,#]&[
                      Random[WeibullDistribution[0.8,Max[e]*2]]]]];
              c+f*a,
              c]]&/@MapThread[List,{a,b,startend}];
    f
    ]

Mutate[list_,start_List,end_Real|end_Integer,mr_]:=
  Block[{a,b,l=Length[start]},
    startend=
      Flatten[Table[
          Transpose[{start,Table[end,{l}]}],{Length[Flatten[list]]}],1];
    a=Flatten[list];
    b=Table[Random[Real,{0,1}],{Length[Flatten[a]]}];
    f=Block[{a,b,c=#\[LeftDoubleBracket]1\[RightDoubleBracket],
              d=#\[LeftDoubleBracket]2\[RightDoubleBracket],
              e=#\[LeftDoubleBracket]3\[RightDoubleBracket],
              f=If[Random[Integer,{0,1}]===0,-1,1]},
            If[d<mr,
              
              While[c+f*#>e\[LeftDoubleBracket]2\[RightDoubleBracket]||
                      c+f*#<e\[LeftDoubleBracket]1\[RightDoubleBracket]&[
                  a=If[Random[Integer,{0,1}]===0,-1*#,#]&[
                      Random[WeibullDistribution[0.8,Max[e]*2]]]]];
              c+f*a,
              c]]&/@MapThread[List,{a,b,startend}];
    f
    ]

Mutate[list_,start_Real|start_Integer,end_Real|end_Integer,mr_]:=
  Block[{a,b,l=Length[list\[LeftDoubleBracket]1\[RightDoubleBracket]]},
    startend=
      Flatten[Table[
          Transpose[{Table[start,{l}],Table[end,{l}]}],{Length[
              Flatten[list]]}],1];
    a=Flatten[list];
    b=Table[Random[Real,{0,1}],{Length[Flatten[a]]}];
    f=Block[{a,b,c=#\[LeftDoubleBracket]1\[RightDoubleBracket],
              d=#\[LeftDoubleBracket]2\[RightDoubleBracket],
              e=#\[LeftDoubleBracket]3\[RightDoubleBracket],
              f=If[Random[Integer,{0,1}]===0,-1,1]},
            If[d<mr,
              
              While[c+f*#>e\[LeftDoubleBracket]2\[RightDoubleBracket]||
                      c+f*#<e\[LeftDoubleBracket]1\[RightDoubleBracket]&[
                  a=If[Random[Integer,{0,1}]===0,-1*#,#]&[
                      Random[WeibullDistribution[0.8,Max[e]*2]]]]];
              c+f*a,
              c]]&/@MapThread[List,{a,b,startend}];
    f
    ]

GetIterationNumber[]:=iterationno

MakeLimits[l_,start_Real|start_Integer,end_Real|end_Integer]:=
  Transpose[{Table[start,{l}],Table[end,{l}]}]

MakeLimits[l_,start_List,end_Real|end_Integer]:=
  Transpose[{start,Table[end,{l}]}]

MakeLimits[l_,start_Real|start_Integer,end_List]:=
  Transpose[{Table[start,{l}],end}]

MakeLimits[l_,start_List,end_List]:=Transpose[{start,end}]

EPOptimise[function_,nochroms_,iters_,pc_:0.25,mr_:0.01,nogenes_,start_,end_,
    opts___]:=Block[{a,probs,b,c,alldata,current,best={-\[Infinity],0}},
    startgene=Global`Start/.{opts}/.{Global`Start\[Rule]Null};
    converge=
      Global`Convergence/.{opts}/.{Global`Convergence\[Rule]\[Infinity]};
    selectmethod=
      ToExpression[
        "EPOptimise`Private`Selection"<>ToString[
            If[MemberQ[selectionmethods,#],
                  Print["Using SelectionMethod \[Rule] "<>ToString[#]];
                  #,
                  Print["SelectionMethod not recognised: Using Roulette\n"];
                  Global`Roulette]&[
              Global`SelectionMethod/.{opts}/.{Global`SelectionMethod\[Rule]
                    Roulette}]]];
    Print["Methods \[Rule] Roulette, Universal, Truncation (TruncationThreshold) and Tournament (TournamentNumber)"]\
;printedsetting=False;
    ruttingpopulationsize=
      Global`BreedingPool/.{opts}/.{Global`BreedingPool\[Rule]nochroms};
    If[ruttingpopulationsize<nochroms||
        selectmethod===EPOptimise`Private`SelectionTruncation,
      reinsertmethod=
        ToExpression[
          "EPOptimise`Private`Reinsert"<>ToString[
              If[MemberQ[reinsertionmethods,#],
                    
                    Print["Using ReinsertionMethod \[Rule] "<>ToString[#]<>
                        "\nBreedingPool < Population \[Rule] Methods: Elitist and Uniform"]\
;#,
                    
                    Print["ReinsertionMethod not recognised: Using Elitist\nBreedingPool < Population \[Rule] Methods: Elitist and Uniform"]\
;
                    Global`Elitist]&[
                Global`ReinsertionMethod/.{opts}/.{Global`ReinsertionMethod\
\[Rule]Elitist}]]],
      If[ruttingpopulationsize>nochroms,
        Print[
          "Using ReinsertionMethod \[Rule] Fitness (BreedingPool > Population)"]\
;
        reinsertmethod=EPOptimise`Private`ReinsertFitness,
        Print[
          "Using ReinsertionMethod \[Rule] Pure (BreedingPool == Population)"]\
;
        reinsertmethod=EPOptimise`Private`ReinsertPure;
        ]
      ];
    betafactor=Global`\[Beta]Factor/.{opts}/.{Global`\[Beta]Factor\[Rule]3};
    Print["Using \[Beta]Factor \[Rule] ",betafactor];
    
    limits=MakeLimits[nogenes,start,end];
    
    SeedRandom[];
    alldata=Global`AllData/.{opts}/.{Global`AllData\[Rule]True};
    FitnessValue[x___]:=function[x];
    
    If[startgene===Null,population=CreateChrom[nochroms,nogenes,start,end],
      population=Join[{startgene},CreateChrom[nochroms-1,nogenes,start,end]]
      ];
    
    fitdata={};rawdata={};
    (*Print["Starting population = ",population];*)
    Do[
      (*Print["Population = ",population];*)
      AppendTo[rawdata,population];
      SeedRandom[];
      breedinglist={};
      ruttingpopulation=
        selectmethod[population,
          CumulativeProbabilities[population,nogenes,start,end,rawdata,
            fitdata],ruttingpopulationsize,opts];
      (*Print["breedinglist = ",breedinglist];*)
      
      (*Print["Rutting population = ",ruttingpopulation];*)
      
      If[Length[breedinglist]>1,
        breedingpopulation=
          SelectforCrossover[ruttingpopulation,Length[breedinglist],pc];
        newpopulation=
          Crossover[breedingpopulation,crossoverlist,Transpose[{start,end}],
            betafactor];,
        crossoverlist={1};
        newpopulation=ruttingpopulation;
        ];
      (*Print["crossoverlist = ",crossoverlist];*)
      (*Print["Crossover List = ",crossoverlist];*)
      (*Print["New population = ",newpopulation];*)
      population=
        reinsertmethod[population,newpopulation,
          breedinglist\[LeftDoubleBracket]crossoverlist\[RightDoubleBracket],
          start,end];
      
      population=Mutate[population,start,end,mr];
      
      (*Print["Final population = ",population];*)
      If[(current=(Union[
                        MapThread[
                            List,{Flatten[fitdata,1],
                              Flatten[rawdata,
                                1]}]\[LeftDoubleBracket]#\[RightDoubleBracket]\
]&[Position[Flatten[fitdata,1],Max[Flatten[fitdata,1]]]\[LeftDoubleBracket]1,
                      1\[RightDoubleBracket]]))\[LeftDoubleBracket]1\
\[RightDoubleBracket]>best\[LeftDoubleBracket]1\[RightDoubleBracket],
        best=current;
        Print[i,". ","New Fit Value \[Rule] ",
          best\[LeftDoubleBracket]1\[RightDoubleBracket],"\tRaw Value \[Rule] ",
          best\[LeftDoubleBracket]2\[RightDoubleBracket]]];
      If[best\[LeftDoubleBracket]1\[RightDoubleBracket]>=converge,Break[]];
      iterationno=i;,
      {i,1,iters}];
    
    If[alldata,{Union[Extract[rawdata,#]&/@Position[fitdata,Max[fitdata]]],
        MapThread[
              List,{#\[LeftDoubleBracket]1\[RightDoubleBracket],#\
\[LeftDoubleBracket]2\[RightDoubleBracket]}]&/@
          MapThread[List,{rawdata,fitdata}]}];
    Print[
      "Best Results: "];(Union[
            MapThread[
                List,{Flatten[fitdata,1],
                  Flatten[rawdata,
                    1]}]\[LeftDoubleBracket]#\[RightDoubleBracket]]&[
        Position[Flatten[fitdata,1],
            Max[Flatten[fitdata,1]]]\[LeftDoubleBracket]1,
          1\[RightDoubleBracket]])
    ]

End[]



EndPackage[]

