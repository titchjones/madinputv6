(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

BeginPackage["EPOptimise`"];

EPOptimise::usage="EPOptimise[Objective Function, No Of Chromosomes, Iterations, Prob. of Crossover, Prob. of Mutation, Genes per Chrom., Gene Length, Start of range, Length of range]";

Begin["`Private`"]





BinToGray[bin_]:=Block[{a,b,c,gray,binary},
    gray={};binary=bin;
    b=First[binary];
    AppendTo[gray,b];
    binary=Rest[binary];
    (a=#;
          AppendTo[gray,If[b===a,0,1]];
          b=a;
          )&/@binary;
    gray]

GrayToBin[gra_]:=Block[{a,b,c,gray,binary},
    gray=Rest[gra];
    binary={};
    a=First[gra];
    AppendTo[binary,First[gra]];
    (If[#===1&&a===1,AppendTo[binary,0];a=0,
            If[#===1&&a===0,AppendTo[binary,1];a=1,AppendTo[binary,a]]]&/@
        gray);
    binary
    ]

\!\(CreateChrom[number_, length_Integer, numbers_Integer] := Table[\[IndentingNewLine]IntegerDigits[Random[Integer, {0, \((2\^\(length*numbers\) - 1)\)}], 2, length*numbers]\[IndentingNewLine], {number}]\)

\!\(CreateChrom[number_, length_List, numbers_Integer] := Table[\[IndentingNewLine]IntegerDigits[Random[Integer, {0, \((2\^Plus @@ length - 1)\)}], 2, Plus @@ length*numbers]\[IndentingNewLine], {number}]\)

\!\(TurnToBin[list_List, length_Integer, number_Integer, start_, range_] := Flatten[\(Block[{a = #}, \(PadLeft[\(RealDigits[\(Ordering[Abs[list\[LeftDoubleBracket]a\[RightDoubleBracket] - #]]\)\[LeftDoubleBracket]1\[RightDoubleBracket] - 1, 2]\)\[LeftDoubleBracket]1\[RightDoubleBracket], length, 0] &\)[Range[start\[LeftDoubleBracket]a\[RightDoubleBracket], range\[LeftDoubleBracket]a\[RightDoubleBracket], \((range\[LeftDoubleBracket]a\[RightDoubleBracket] - start\[LeftDoubleBracket]a\[RightDoubleBracket])\)\/\(2\^length - 1\)]]] &\) /@ Range[number]]\)

\!\(TurnToRange[binnumber_, length_Integer, number_Integer, start_Integer, range_Integer] := \((\(N[start + \((FromDigits[Take[binnumber, {#, # + \((length)\) - 1}], 2]*\((\((range - start)\)/\((2\^\((length)\) - 1)\))\))\)] &\) /@ Range[1, length*number, \((length)\)])\)\)

\!\(TurnToRange[binnumber_, length_Integer, number_Integer, start_List, range_Integer] := \((\(N[#\[LeftDoubleBracket]2\[RightDoubleBracket] + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1\[RightDoubleBracket], #\[LeftDoubleBracket]1\[RightDoubleBracket] + \((length)\) - 1}], 2]*\((\((range - #\[LeftDoubleBracket]2\[RightDoubleBracket])\)/\((2\^\((length)\) - 1)\))\))\)] &\) /@ MapThread[List, {Range[1, length*number, \((length/number)\)], start}])\)\)

\!\(TurnToRange[binnumber_, length_Integer, number_Integer, start_Integer, range_List] := \((\(N[start + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1\[RightDoubleBracket], #\[LeftDoubleBracket]1\[RightDoubleBracket] + \((length)\) - 1}], 2]*\((\((#\[LeftDoubleBracket]2\[RightDoubleBracket] - start)\)/\((2\^\((length/number)\) - 1)\))\))\)] &\) /@ MapThread[List, {Range[1, length*number, \((length/number)\)], range}])\)\)

\!\(TurnToRange[binnumber_, length_Integer, number_Integer, start_List, range_List] := \((\(N[#\[LeftDoubleBracket]2\[RightDoubleBracket] + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1\[RightDoubleBracket], #\[LeftDoubleBracket]1\[RightDoubleBracket] + \((length)\) - 1}], 2]*\((\((#\[LeftDoubleBracket]3\[RightDoubleBracket] - #\[LeftDoubleBracket]2\[RightDoubleBracket])\)/\((2\^\((length)\) - 1)\))\))\)] &\) /@ MapThread[List, {Range[1, length*number, length], start, range}])\)\)

\!\(TurnToRange[binnumber_, length_List, number_Integer, start_Integer, range_Integer] := \((\(N[start + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1\[RightDoubleBracket], #\[LeftDoubleBracket]1\[RightDoubleBracket] + #\[LeftDoubleBracket]2\[RightDoubleBracket] - 1}], 2]*\((\((range - start)\)/\((2\^#\[LeftDoubleBracket]2\[RightDoubleBracket] - 1)\))\))\)] &\) /@ MapThread[List, {Drop[FoldList[Plus, 1, length], \(-1\)], length}])\)\)

\!\(TurnToRange[binnumber_, length_List, number_Integer, start_List, range_Integer] := \((\(N[#\[LeftDoubleBracket]2\[RightDoubleBracket] + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1, 1\[RightDoubleBracket], #\[LeftDoubleBracket]1, 1\[RightDoubleBracket] + #\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1}], 2]*\((\((range - #\[LeftDoubleBracket]2\[RightDoubleBracket])\)/\((2\^#\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1)\))\))\)] &\) /@ MapThread[List, {MapThread[List, {Drop[FoldList[Plus, 1, length], \(-1\)], length}], start}])\)\)

\!\(TurnToRange[binnumber_, length_List, number_Integer, start_Integer, range_List] := \((\(N[start + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1, 1\[RightDoubleBracket], #\[LeftDoubleBracket]1, 1\[RightDoubleBracket] + #\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1}], 2]*\((\((#\[LeftDoubleBracket]2\[RightDoubleBracket] - start)\)/\((2\^#\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1)\))\))\)] &\) /@ MapThread[List, {MapThread[List, {Drop[FoldList[Plus, 1, length], \(-1\)], length}], range}])\)\)

\!\(TurnToRange[binnumber_, length_List, number_Integer, start_List, range_List] := \((\(N[#\[LeftDoubleBracket]2\[RightDoubleBracket] + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1, 1\[RightDoubleBracket], #\[LeftDoubleBracket]1, 1\[RightDoubleBracket] + #\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1}], 2]*\((\((#\[LeftDoubleBracket]3\[RightDoubleBracket] - #\[LeftDoubleBracket]2\[RightDoubleBracket])\)/\((2\^#\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1)\))\))\)] &\) /@ MapThread[List, {MapThread[List, {Drop[FoldList[Plus, 1, length], \(-1\)], length}], start, range}])\)\)

\!\(TurnToRange[binnumber_, length_List, number_List, start_Integer, range_Integer] := \((\(N[start + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1\[RightDoubleBracket], #\[LeftDoubleBracket]1\[RightDoubleBracket] + #\[LeftDoubleBracket]2\[RightDoubleBracket] - 1}], 2]*\((\((range - start)\)/\((2\^#\[LeftDoubleBracket]2\[RightDoubleBracket] - 1)\))\))\)] &\) /@ MapThread[List, {Drop[FoldList[Plus, 1, length], \(-1\)], length}])\)\)

\!\(TurnToRange[binnumber_, length_List, number_List, start_List, range_Integer] := \((\(N[#\[LeftDoubleBracket]2\[RightDoubleBracket] + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1, 1\[RightDoubleBracket], #\[LeftDoubleBracket]1, 1\[RightDoubleBracket] + #\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1}], 2]*\((\((range - #\[LeftDoubleBracket]2\[RightDoubleBracket])\)/\((2\^#\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1)\))\))\)] &\) /@ MapThread[List, {MapThread[List, {Drop[FoldList[Plus, 1, length], \(-1\)], length}], start}])\)\)

\!\(TurnToRange[binnumber_, length_List, number_List, start_Integer, range_List] := \((\(N[start + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1, 1\[RightDoubleBracket], #\[LeftDoubleBracket]1, 1\[RightDoubleBracket] + #\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1}], 2]*\((\((#\[LeftDoubleBracket]2\[RightDoubleBracket] - start)\)/\((2\^#\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1)\))\))\)] &\) /@ MapThread[List, {MapThread[List, {Drop[FoldList[Plus, 1, length], \(-1\)], length}], range}])\)\)

\!\(TurnToRange[binnumber_, length_List, number_List, start_List, range_List] := \((\(N[#\[LeftDoubleBracket]2\[RightDoubleBracket] + \((FromDigits[Take[binnumber, {#\[LeftDoubleBracket]1, 1\[RightDoubleBracket], #\[LeftDoubleBracket]1, 1\[RightDoubleBracket] + #\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1}], 2]*\((\((#\[LeftDoubleBracket]3\[RightDoubleBracket] - #\[LeftDoubleBracket]2\[RightDoubleBracket])\)/\((2\^#\[LeftDoubleBracket]1, 2\[RightDoubleBracket] - 1)\))\))\)] &\) /@ MapThread[List, {MapThread[List, {Drop[FoldList[Plus, 1, length], \(-1\)], length}], start, range}])\)\)

FitnessAll[list_,length_,number_,start_,range_,rawdata_,
    fitdata_]:=(FitnessValue[TurnToRange[#,length,number,start,range]]&/@list)

FitnessAll[list_,length_,number_,start_,range_,rawdata_,
    fitdata_]:=(If[MemberQ[Partition[Flatten[Drop[rawdata,-1]],number],#],
          Flatten[fitdata]\[LeftDoubleBracket]
            Position[
                Partition[Flatten[Drop[rawdata,-1]],
                  number],#]\[LeftDoubleBracket]1,
              1\[RightDoubleBracket]\[RightDoubleBracket],
          FitnessValue[#]]&/@(TurnToRange[#,length,number,start,range]&/@
          list))

CumulativeProbabilities[list_,length_,number_,start_,range_,rawdata_,
    fitdata2_]:=Block[{a},
    a=FitnessAll[list,length,number,start,range,rawdata,fitdata2];
    AppendTo[fitdata,a];
    Rest[FoldList[Plus,0,a/Total[a]]]
    ]

randomnumbers[number_]:=(SeedRandom[];Table[Random[Real,{0,1}],{number}])

selectionmethods={Global`Roulette,Global`Universal,Global`Truncation,
    Global`Tournament}



Roulette[list_,probab_,number_,opts___]:=
  Block[{a,random=randomnumbers[number]},
    list\[LeftDoubleBracket](a=#;
            Length[Select[probab,#<a&]]+1)&/@random\[RightDoubleBracket]]

\!\(Universal[list_, probab_, number_, opts___] := Block[{a, linear = Range[Random[Real, {0, 1\/number}], 1, 1\/number]}, \[IndentingNewLine]list\[LeftDoubleBracket]\(\((a = #; \[IndentingNewLine]Length[Select[probab, # < a &]] + 1)\) &\) /@ linear\[RightDoubleBracket]]\)

Truncation[list_,probab_,number_,opts___]:=Block[{a,b},
    threshold=
      Global`TruncationThreshold/.{opts}/.{Global`TruncationThreshold\[Rule]0.\
5};
    If[printedsetting=!=True,
      Print["Using TruncationThreshold \[Rule] "<>ToString[threshold]];
      printedsetting=True];
    a=MapThread[Subtract,{probab,Prepend[Most[probab],0]}];
    b=Sort[
        Transpose[{a,
            list}],#1\[LeftDoubleBracket]1\[RightDoubleBracket]<#2\
\[LeftDoubleBracket]1\[RightDoubleBracket]&];
    c=Take[b,-Round[threshold*number]];
    c\[LeftDoubleBracket]All,2\[RightDoubleBracket]\[LeftDoubleBracket]
      Table[Random[Integer,{1,Length[c]}],{number}]\[RightDoubleBracket]
    ]

Tournament[list_,probab_,number_,opts___]:=
  Block[{a=MapThread[Subtract,{probab,Prepend[Most[probab],0]}],b=a},
    tour=Global`TournamentNumber/.{opts}/.{Global`TournamentNumber\[Rule]
            Ceiling[number/5]};
    If[printedsetting=!=True,
      Print["Using TournamentNumber \[Rule] "<>ToString[tour]];
      printedsetting=True];
    Table[(a=ReplacePart[a,0,#];
            list\[LeftDoubleBracket]#\[RightDoubleBracket])&[
        Position[a,Max[#]]\[LeftDoubleBracket]1,1\[RightDoubleBracket]&[
          a\[LeftDoubleBracket]Table[
              Random[Integer,{1,
                  number}],{tour}]\[RightDoubleBracket]]],{number}]
    ]

bin6[b_,c_]:=b[[#]]&/@Split[Ordering[c],c[[#1]]\[Equal]c[[#2]]&];

Clear[SelectforCrossover]

SelectforCrossover[list_,numbers_:5,pc_:0.25]:=
  Block[{a,crossdatalist,positionsofcross,d,e,f,g,h},
    (*Generate enough random numbers*)
    a=randomnumbers[numbers];
    
    (*positions where random nu is less than chance of crossing*)
    positionsofcross=Flatten[Position[a,_?(#<pc&)]];
    
    (*elements of list that are to be crossed*)
    crossdatalist=(list\[LeftDoubleBracket]#\[RightDoubleBracket])&/@
        positionsofcross;
    
    (*if total number of crossers is odd...*)
    If[OddQ[Length[crossdatalist]],
      
      (*randomly choose to add another or drop 1, 
        unless chosen is fewer than 2 - then must add*)
      If[Random[Integer,{1,2}]===1&&Length[crossdatalist]>1,
        
        (*lets drop a gene from the list*)
        (*randomly pick which one*)
        g=Random[Integer,{1,Length[crossdatalist]}];
        
        (*in case we have more than 1 of them, randomly drop 1*)
        h=#\[LeftDoubleBracket]
                Random[Integer,{1,Length[#]}]\[RightDoubleBracket]&[
            Select[Flatten[
                Position[list,
                  crossdatalist\[LeftDoubleBracket]g\[RightDoubleBracket]]],
              MemberQ[positionsofcross,#]&]];
        
        (*edit the crossover lists*)
        positionsofcross=Select[positionsofcross,#=!=h&];
        crossdatalist=Drop[crossdatalist,{g}],
        
        (*lets add an extra gene to the list*)
        (*randomly pick one...*)
        d=Range[1,numbers];
        (*edit the crossover lists*)
        AppendTo[
          positionsofcross,(f=
              d\[LeftDoubleBracket]Random[
                  Integer,{1,Length[d]}]\[RightDoubleBracket])];
        AppendTo[crossdatalist,
          list\[LeftDoubleBracket]f\[RightDoubleBracket]];]];
    crossoverlist=positionsofcross;
    crossdatalist]

Crossover[datalist_,crosslist_,length_,numbers_]:=
  Block[{a,b,c,pos,c1last,c2last,c1new,c2new,lengths},
    If[Head[length]===List,lengths=Plus@@length,lengths=length*numbers];
    pos=Random[Integer,{1,lengths-1}];
    a={};
    While[Length[a]<Length[crosslist],
      If[!MemberQ[a,(b=Random[Integer,{1,Length[crosslist]}])],
        AppendTo[a,b]]];
    c=Partition[(datalist\[LeftDoubleBracket]#\[RightDoubleBracket]&/@a),2];
    Partition[Flatten[bin6[Partition[Flatten[(
                    pos=Random[Integer,{1,lengths}];
                    
                    c1last=Take[#\[LeftDoubleBracket]1\[RightDoubleBracket],-(\
lengths-pos)];
                    
                    c2last=Take[#\[LeftDoubleBracket]2\[RightDoubleBracket],-(\
lengths-pos)];
                    
                    c1new=Flatten[
                        Append[
                          Delete[#\[LeftDoubleBracket]1\[RightDoubleBracket],
                            Table[{\[Iota]},{\[Iota],pos+1,lengths}]],
                          c2last]];
                    
                    c2new=Flatten[
                        Append[
                          Delete[#\[LeftDoubleBracket]2\[RightDoubleBracket],
                            Table[{\[Iota]},{\[Iota],pos+1,lengths}]],
                          c1last]];
                    {c1new,c2new}
                    )&/@c],lengths],a]],lengths]]

reinsertinlist[olddata_,newdata_,positions_]:=Block[{a},a=olddata;
    (a=ReplacePart[
              a,#\[LeftDoubleBracket]2\[RightDoubleBracket],#\
\[LeftDoubleBracket]1\[RightDoubleBracket]])&/@
      MapThread[List,{positions,newdata}];a]

Mutate[list_,lengths_,numbers_,mr_]:=Block[{a,b,c,number},
    If[Head[lengths]===List,number=Plus@@lengths,number=lengths*numbers];
    a=Flatten[list];
    b=Flatten[
        Position[Table[Random[Real,{0,1}],{Length[Flatten[a]]}],_?(#<mr&)]];
    If[a\[LeftDoubleBracket]#\[RightDoubleBracket]===1,a=ReplacePart[a,0,#],
          a=ReplacePart[a,1,#]]&/@b;
    Partition[a,number]
    ]

EPOptimise[function_,nochroms2_,notimes_,pc_:0.25,mr_:0.01,nochroms_,
    chromlength_,start_,range_,opts___]:=
  Block[{a,probs,b,c,FitnessValue,alldata,current,best={\[Infinity],0}},
    startgene=Global`Start/.{opts}/.{Global`Start\[Rule]Null};
    converge=Global`Convergence/.{opts}/.{Global`Convergence\[Rule]0};
    selectmethod=
      ToExpression[
        "EPOptimise`Private`"<>ToString[If[MemberQ[selectionmethods,#],
                  Print["Using Selection Method \[Rule] "<>ToString[#]];
                  #,
                  Print["Method not recognised: Using Roulette\nMethods \[Rule] Roulette, Universal, Truncation (TruncationThreshold) and Tournament (TournamentNumber)"]\
;
                  Global`Roulette]&[
              Global`SelectMethod/.{opts}/.{Global`SelectMethod\[Rule]
                    Roulette}]]];
    printedsetting=False;
    SeedRandom[];
    alldata=Global`AllData/.{opts}/.{Global`AllData\[Rule]True};
    FitnessValue[x___]:=1/function[x];
    If[startgene===Null,a=CreateChrom[nochroms2,chromlength,nochroms],
      a=Join[{TurnToBin[startgene,chromlength,nochroms,start,range]},
          CreateChrom[nochroms2-1,chromlength,nochroms]]
      ];
    fitdata={};
    rawdata={};
    Do[
      AppendTo[
        rawdata,(TurnToRange[#,chromlength,nochroms,start,range]&/@a)];
      SeedRandom[];
      a=selectmethod[a,
          CumulativeProbabilities[a,chromlength,nochroms,start,range,rawdata,
            fitdata],nochroms2,opts];
      
      a=BinToGray[#]&/@a;
      SeedRandom[];
      
      b=SelectforCrossover[a,nochroms2,pc];
      
      c=Crossover[b,crossoverlist,chromlength,nochroms];
      
      a=reinsertinlist[a,c,crossoverlist];
      
      a=Mutate[a,chromlength,nochroms,mr];
      
      a=GrayToBin[#]&/@a;
      If[(current=(Union[
                        MapThread[
                            List,{Flatten[1/fitdata,1],
                              Flatten[rawdata,
                                1]}]\[LeftDoubleBracket]#\[RightDoubleBracket]\
]&[Position[Flatten[fitdata,1],Max[Flatten[fitdata,1]]]\[LeftDoubleBracket]1,
                      
                      1\[RightDoubleBracket]]))\[LeftDoubleBracket]1\
\[RightDoubleBracket]<best\[LeftDoubleBracket]1\[RightDoubleBracket],
        best=current;
        Print["New Fit Value \[Rule] ",
          best\[LeftDoubleBracket]1\[RightDoubleBracket],"\tRaw Value \[Rule] ",
          best\[LeftDoubleBracket]2\[RightDoubleBracket]]];
      If[best\[LeftDoubleBracket]1\[RightDoubleBracket]\[LessEqual]converge,
        Break[]];
      ,{notimes}];
    If[alldata,{Union[Extract[rawdata,#]&/@Position[fitdata,Max[fitdata]]],
        MapThread[
              List,{#\[LeftDoubleBracket]1\[RightDoubleBracket],#\
\[LeftDoubleBracket]2\[RightDoubleBracket]}]&/@
          MapThread[List,{rawdata,fitdata}]}];
    Print[
      "Best Results: "];(Union[
            MapThread[
                List,{Flatten[1/fitdata,1],
                  Flatten[rawdata,
                    1]}]\[LeftDoubleBracket]#\[RightDoubleBracket]]&[
        Position[Flatten[fitdata,1],
            Max[Flatten[fitdata,1]]]\[LeftDoubleBracket]1,
          1\[RightDoubleBracket]])
    ]

End[]



EndPackage[]