(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["EPOptimise`"];


EPOptimiseNDSGA::usage="EPOptimise[Objective Function, No Of Chromosomes, Iterations, Prob. of Crossover, Prob. of Mutation, Genes per Chrom., Gene Length (\!\(\*SuperscriptBox[\"2\", 
RowBox[{\"Gene\", \" \", \"Length\"}]]\)), Start of range, End of range, Options (see EPOptimise[Options])]\nEPOptimise is a MAXIMISING Function!";


EPOptimise::Options="EPOptimise supports 3 possible options: SelectionMethod, BreedingPool, ReinsertionMethod;\nSee EPOptimise[<Option Name>];"


EPOptimise::SelectionMethod="SelectionMethod specifies one of 4 methods for selecting the possible breeding population.\nThe options are:\nRoulette\nUniversal\nTruncation\nTournament"


EPOptimise::Roulette="In the Roulette SelectionMethod The individuals are mapped to contiguous segments of a line, such that each individual's segment is equal in size to its fitness. A random number is generated and the individual whose segment spans the random number is selected. This is repeated to select the breeding population required."


EPOptimise::Universal="In the Universal SelectionMethod the individuals are mapped to contiguous segments of a line, such that each individual's segment is equal in size to its fitness exactly as in Roulette selection. Here equally spaced pointers are placed over the line as many as there are individuals to be selected, and the breeding population thus chosen."


EPOptimise::Truncation="In Truncation selection individuals are sorted according to their fitness. Only the best individuals are selected for parents. The parameter for truncation selection is the TruncationThreshold. TruncationThreshold indicates the proportion of the population to be selected as parents and takes values ranging from 50%-10%. Individuals below the truncation threshold do not produce offspring."


EPOptimise::TruncationThreshold="TruncationThreshold indicates the proportion of the population to be selected as parents in the Truncation SelectionMethod, and takes values ranging from 50%-10%."


EPOptimise::Tournament="In Tournament selection a number TournamentNumber of individuals is chosen randomly from the population and the best individual from this group is selected as a parent. This process is repeated as often as individuals must be chosen."


EPOptimise::TournamentNumber="TournamentNumber is the number of individuals to be tested in each tournament round in the Tournament SelectionMethod." 


EPOptimise::BreedingPool="The BreedingPool is the size of the breeding population at each iteration. This is the total possible breeding population, and not all individuals chosen will breed. See EPOptimise[Breeding]."


EPOptimise::Breeding="When breeding individuals, the breeding population is chosen using the SelectionMethod variable and the BreedingPool size. The chance of these individuals then breeding is determined randomly using the Crossover Probability. The breeding is then performed using one of the CrossoverMethod's (Not yet implemented), and reinsertion of the resulting offspring is performed according to the ReinsertionMethod."


EPOptimise::ReinsertionMethod="ReinsertionMethod specifies the algorithm for reinserting the offspring back into the main population. It is dependant on the choice of BreedingPool relative to the population size. The methods are:\nBreedingPool = Population Size  \[Rule]  Pure\nBreedingPool < Population Size  \[Rule]  Elitist or Uniform\nBreedingPool > Population Size  \[Rule]  Fitness"


EPOptimise::Pure="In Pure reinsertion the parents are completely replaced with their offspring. Because not all parents reproduce (see EPOptimise[Breeding]), some offspring are clones of their parents."


EPOptimise::Elitist="In Elitist reinsertion the worst parents are replaced by the offspring. Elitist reinsertion requires BreedingPool to be less than the population Size."


EPOptimise::Uniform="In Uniform reinsertion the offspring randomly replace some of the parents. This is analogous to Pure reinsertion when BreedingPool < Population Size."


EPOptimise::Fitness="In Fitness reinsertion the fittest offspring replace all of the parents. This requires BreedingPool > Population Size. The Fitness ReinsertionMethod has a penalty in terms of computational efficiency as the fitness of all offspring must be evaluated in addition to that required in evaluating the chosen SelectionMethod."


GetIterationNumber::usage="Returns Latest Iteration Number from EPOptimise."


Begin["`Private`"]


EPOptimise[]:=?EPOptimise


EPOptimise[help_]:=Print[ToExpression[Evaluate["EPOptimise::"<>ToString[help]]]]


BinToGray[bin_]:=Block[{a,b,c,gray,binary},
gray={};binary=bin;
b=First[binary];
AppendTo[gray,b];
binary=Rest[binary];
(a=#;
AppendTo[gray,If[b===a,0,1]];
b=a;
)&/@binary;
gray]


GrayToBin[gra_]:=Block[{a,b,c,gray,binary},
gray=Rest[gra];
binary={};
a=First[gra];
AppendTo[binary,First[gra]];
(If[#===1&&a===1,AppendTo[binary,0];a=0,If[#===1&&a===0,AppendTo[binary,1];a=1,AppendTo[binary,a]]]&/@gray);
binary
]


RandomUnion[no_]:=Block[{randlist=Range[no],rand,randno},Table[rand=RandomInteger[{1,Length[randlist]}];randno=randlist[[rand]];randlist=Drop[randlist,{rand}];randno,{no}]]


RandomUnion[no_,subno_]:=Block[{randlist=Range[no],rand,randno},Table[rand=RandomInteger[{1,Length[randlist]}];randno=randlist[[rand]];randlist=Drop[randlist,{rand}];randno,{subno}]]


CreateChrom[number_,length_Integer,numbers_Integer]:=Table[IntegerDigits[RandomInteger[{0,2^(length numbers)-1}],2,length numbers],{number}]


CreateChrom[number_,length_List,numbers_Integer]:=Table[IntegerDigits[RandomInteger[{0,2^Plus@@length-1}],2,Plus@@length numbers],{number}]


TurnToBin[list_List,length_Integer,number_Integer,start_Integer|start_Real,end_Integer|end_Real]:=Flatten[Block[{a=#},PadLeft[RealDigits[Ordering[Abs[list[[a]]-#]][[1]]-1,2][[1]],length,0]&[Range[start,end,(end-start)/(2^length-1)]]]&/@Range[number]]


TurnToBin[list_List,length_Integer,number_Integer,start_List,end_Integer|end_Real]:=Flatten[Block[{a=#},PadLeft[RealDigits[Ordering[Abs[list[[a]]-#]][[1]]-1,2][[1]],length,0]&[Range[start[[a]],end,(end-start[[a]])/(2^length-1)]]]&/@Range[number]]


TurnToBin[list_List,length_Integer,number_Integer,start_Integer|start_Real,end_List]:=Flatten[Block[{a=#},PadLeft[RealDigits[Ordering[Abs[list[[a]]-#]][[1]]-1,2][[1]],length,0]&[Range[start,end[[a]],(end[[a]]-start)/(2^length-1)]]]&/@Range[number]]


TurnToBin[list_List,length_Integer,number_Integer,start_List,end_List]:=Flatten[Block[{a=#},PadLeft[RealDigits[Ordering[Abs[list[[a]]-#]][[1]]-1,2][[1]],length,0]&[Range[start[[a]],end[[a]],(end[[a]]-start[[a]])/(2^length-1)]]]&/@Range[number]]


TurnToRange[binnumber_,length_Integer,number_Integer,start_Integer,range_Integer]:=(N[start+(FromDigits[Take[binnumber,{#,#+(length)-1}],2]*((range-start)/(2^(length)-1)))]&/@Range[1,length*number,(length)])


TurnToRange[binnumber_,length_Integer,number_Integer,start_List,range_Integer]:=(N[#[[2]]+(FromDigits[Take[binnumber,{#[[1]],#[[1]]+(length)-1}],2]*((range-#[[2]])/(2^(length)-1)))]&/@MapThread[List,{Range[1,length*number,(length/number)],start}])


TurnToRange[binnumber_,length_Integer,number_Integer,start_Integer,range_List]:=(N[start+(FromDigits[Take[binnumber,{#[[1]],#[[1]]+(length)-1}],2]*((#[[2]]-start)/(2^(length/number)-1)))]&/@MapThread[List,{Range[1,length*number,(length/number)],range}])


TurnToRange[binnumber_,length_Integer,number_Integer,start_List,range_List]:=(N[#[[2]]+(FromDigits[Take[binnumber,{#[[1]],#[[1]]+(length)-1}],2]*((#[[3]]-#[[2]])/(2^(length)-1)))]&/@MapThread[List,{Range[1,length*number,length],start,range}])


TurnToRange[binnumber_,length_List,number_Integer,start_Integer,range_Integer]:=(N[start+(FromDigits[Take[binnumber,{#[[1]],#[[1]]+#[[2]]-1}],2]*((range-start)/(2^#[[2]]-1)))]&/@MapThread[List,{Drop[FoldList[Plus,1,length],-1],length}])


TurnToRange[binnumber_,length_List,number_Integer,start_List,range_Integer]:=(N[#[[2]]+(FromDigits[Take[binnumber,{#[[1,1]],#[[1,1]]+#[[1,2]]-1}],2]*((range-#[[2]])/(2^#[[1,2]]-1)))]&/@MapThread[List,{MapThread[List,{Drop[FoldList[Plus,1,length],-1],length}],start}])


TurnToRange[binnumber_,length_List,number_Integer,start_Integer,range_List]:=(N[start+(FromDigits[Take[binnumber,{#[[1,1]],#[[1,1]]+#[[1,2]]-1}],2]*((#[[2]]-start)/(2^#[[1,2]]-1)))]&/@MapThread[List,{MapThread[List,{Drop[FoldList[Plus,1,length],-1],length}],range}])


TurnToRange[binnumber_,length_List,number_Integer,start_List,range_List]:=(N[#[[2]]+(FromDigits[Take[binnumber,{#[[1,1]],#[[1,1]]+#[[1,2]]-1}],2]*((#[[3]]-#[[2]])/(2^#[[1,2]]-1)))]&/@MapThread[List,{MapThread[List,{Drop[FoldList[Plus,1,length],-1],length}],start,range}])


TurnToRange[binnumber_,length_List,number_List,start_Integer,range_Integer]:=(N[start+(FromDigits[Take[binnumber,{#[[1]],#[[1]]+#[[2]]-1}],2]*((range-start)/(2^#[[2]]-1)))]&/@MapThread[List,{Drop[FoldList[Plus,1,length],-1],length}])


TurnToRange[binnumber_,length_List,number_List,start_List,range_Integer]:=(N[#[[2]]+(FromDigits[Take[binnumber,{#[[1,1]],#[[1,1]]+#[[1,2]]-1}],2]*((range-#[[2]])/(2^#[[1,2]]-1)))]&/@MapThread[List,{MapThread[List,{Drop[FoldList[Plus,1,length],-1],length}],start}])


TurnToRange[binnumber_,length_List,number_List,start_Integer,range_List]:=(N[start+(FromDigits[Take[binnumber,{#[[1,1]],#[[1,1]]+#[[1,2]]-1}],2]*((#[[2]]-start)/(2^#[[1,2]]-1)))]&/@MapThread[List,{MapThread[List,{Drop[FoldList[Plus,1,length],-1],length}],range}])


TurnToRange[binnumber_,length_List,number_List,start_List,range_List]:=(N[#[[2]]+(FromDigits[Take[binnumber,{#[[1,1]],#[[1,1]]+#[[1,2]]-1}],2]*((#[[3]]-#[[2]])/(2^#[[1,2]]-1)))]&/@MapThread[List,{MapThread[List,{Drop[FoldList[Plus,1,length],-1],length}],start,range}])


FitnessAll[funcs_,list_,length_,number_,start_,range_,rawdata_,fitdata_]:=
Block[{values=TurnToRange[#,length,number,start,range]&/@list},
DominationSortingList[values,CrowdingDistanceAssignment[values,funcs],funcs]
]


bin6[b_,c_]:=(b[[#1]]&)/@Split[Ordering[c],c[[#1]]==c[[#2]]&]


CumulativeProbabilities[funcs_,list_,length_,number_,start_,range_,rawdata_,fitdata2_]:=Block[{a},
locations=FitnessAll[funcs,list,length,number,start,range,rawdata,fitdata2];
(*Print["locations = ",locations];*)
ans=#/Total[##]&[(1/(1.5)^(#/(Length[list]/10))&/@Range[Length[list]])];
Flatten[bin6[ans,locations],1]]


randomnumbers[number_]:=(SeedRandom[];RandomReal[{0,1},number])


selectionmethods={Global`Roulette,Global`Universal,Global`Truncation,Global`Tournament}


SelectionRoulette[list_,probab_,number_,opts___]:=Block[{a,random=randomnumbers[number]},
list[[breedinglist=(a=#;
Length[Select[probab,#<a&]]+1)&/@random]]
]


SelectionUniversal[list_,probab_,number_,opts___]:=Block[{a,linear=Range[RandomReal[{0,1/number}],1,1/number]},ans=list[[breedinglist=((a=#1;Length[Select[probab,#1<a&]])&)/@linear]];Print["output = ",breedinglist];ans]


SelectionTruncation[list_,probab_,number_,opts___]:=Block[{a,b},threshold=TruncationThreshold/.{opts}/.{TruncationThreshold->0.5`};If[printedsetting=!=True,Print["Using TruncationThreshold \[Rule] "<>ToString[threshold]];printedsetting=True];a=MapThread[Subtract,{probab,Prepend[Most[probab],0]}];b=Sort[Transpose[{a,list}],#1[[1]]<#2[[1]]&];c=Take[b,-Round[threshold Length[list]]];Print["Number selected = ",-Round[threshold Length[list]]];breedinglist=(Position[list,#1][[1,1]]&)/@c[[All,2]];Print["breedinglist = ",breedinglist];c[[All,2]][[RandomInteger[{1,Length[c]},Length[c]]]]]


SelectionTournament[list_,probab_,number_,opts___]:=Block[{a=MapThread[Subtract,{probab,Prepend[Most[probab],0]}],b=a,tour},tour=Global`TournamentNumber/.{opts}/.{Global`TournamentNumber->Ceiling[number/5]};If[printedsetting=!=True,Print["Using TournamentNumber \[Rule] "<>ToString[tour]];printedsetting=True];Table[((a=ReplacePart[a,0,#1];AppendTo[breedinglist,#1];list[[#1]])&)[(Position[a,Max[#1]][[1,1]]&)[a[[RandomInteger[{1,Length[list]},tour]]]]],{number}]]


bin6[b_,c_]:=b[[#]]&/@Split[Ordering[c],c[[#1]]==c[[#2]]&];


Clear[SelectforCrossover]


SelectforCrossover[list_,numbers_:5,pc_:0.25`]:=Block[{a,crossdatalist,positionsofcross,d,e,f,g,h},a=randomnumbers[numbers];positionsofcross=Flatten[Position[a,_?(#1<pc&)]];crossdatalist=(list[[#1]]&)/@positionsofcross;If[OddQ[Length[crossdatalist]],If[RandomInteger[{1,2}]===1&&Length[crossdatalist]>1,g=RandomInteger[{1,Length[crossdatalist]}];h=(#1[[RandomInteger[{1,Length[#1]}]]]&)[Select[Flatten[Position[list,crossdatalist[[g]]]],MemberQ[positionsofcross,#1]&]];positionsofcross=Select[positionsofcross,#1=!=h&];crossdatalist=Drop[crossdatalist,{g}],d=Range[1,numbers];AppendTo[positionsofcross,f=d[[RandomInteger[{1,Length[d]}]]]];AppendTo[crossdatalist,list[[f]]];]];crossoverlist=positionsofcross;crossdatalist]


Crossover[datalist_,crosslist_,length_,numbers_]:=Block[{a={},b,c,pos,c1last,c2last,c1new,c2new,lengths},If[Head[length]===List,lengths=Plus@@length,lengths=length numbers];pos=RandomInteger[{1,lengths-1}];a=RandomUnion[Length[crosslist]];c=Partition[(datalist[[#1]]&)/@a,2];Partition[Flatten[bin6[Partition[Flatten[((pos=RandomInteger[{1,lengths}];c1last=Take[#1[[1]],-(lengths-pos)];c2last=Take[#1[[2]],-(lengths-pos)];c1new=Flatten[Append[Delete[#1[[1]],Table[{\[Iota]},{\[Iota],pos+1,lengths}]],c2last]];c2new=Flatten[Append[Delete[#1[[2]],Table[{\[Iota]},{\[Iota],pos+1,lengths}]],c1last]];{c1new,c2new})&)/@c],lengths],a]],lengths]]


reinsertionmethods={Global`Elitist,Global`Uniform}


ReinsertPure[olddata_,newdata_,positions_,Null___]:=Block[{a},a=olddata;
(a=ReplacePart[a,#[[2]],#[[1]]])&/@Transpose[{positions,newdata}];a]


ReinsertFitness[olddata_,newdata_,null_,genelength_,nogenes_,start_,end_,funcs_]/;Length[newdata]>=Length[olddata]:=Block[{a,random=RandomUnion[Length[olddata]],fitdata},
a=olddata;
fitdata=FitnessValue[TurnToRange[#,genelength,nogenes,start,end]]&/@newdata;
(*Print["Fitdata offspring = ",fitdata];
Print["Fitdata ordered = ",Ordering[fitdata,-Length[olddata]]];*)
positions=Ordering[fitdata,-Length[olddata]];
(a=ReplacePart[a,#[[2]],#[[1]]])&/@Transpose[{random,newdata[[positions]]}];a]


ReinsertFitness[olddata_,newdata_,positions_,genelength_,nogenes _,start_,end_,funcs_]/;Length[newdata]<Length[olddata]:=
((*Print["Not enough offspring, using Reinsertion Method -> Elitist"];*)
ReinsertElitist[olddata,newdata])


ReinsertUniform[olddata_,newdata_,Null___]:=Block[{a,positions=RandomUnion[Length[olddata],Length[newdata]]},
(*Print["Uniform Positions = ",positions];*)
a=olddata;
(a=ReplacePart[a,#[[2]],#[[1]]])&/@Transpose[{positions,newdata}];
a]


ReinsertElitist[olddata_,newdata_,Null___]:=Block[{a,random=RandomUnion[Length[newdata]],positions},a=olddata;
positions=Ordering[fitdata[[-1]]][[Range[Length[newdata]]]][[random]];
(a=ReplacePart[a,#[[2]],#[[1]]])&/@Transpose[{positions,newdata}];a]


ReinsertElitist[olddata_,newdata_,crosspositions_,genelength_,nogenes_,start_,end_,funcs_]:=Block[{a,random=RandomUnion[Length[newdata]],positions,values=TurnToRange[#,genelength,nogenes,start,end]&/@olddata},
a=olddata;
positions=Reverse[DominationSortingList[values,CrowdingDistanceAssignment[values,funcs],funcs]][[Range[Length[newdata]]]][[random]];
(a=ReplacePart[a,#[[1]]->#[[2]]])&/@Transpose[{positions,newdata}];
a]


Mutate[list_,lengths_,numbers_,mr_]:=Block[{a,b,c,number},If[Head[lengths]===List,number=Plus@@lengths,number=lengths numbers];a=Flatten[list];b=Flatten[Position[RandomReal[{0,1},Length[Flatten[a]]],_?(#1<mr&)]];(If[a[[#1]]===1,a=ReplacePart[a,0,#1],a=ReplacePart[a,1,#1]]&)/@b;Partition[a,number]]


GetIterationNumber[]:=iterationno


SaveFit[mfunc_,p_]:=Block[{},
If[ValueQ[Fitness[mfunc][p]],
Fitness[mfunc][p],
Fitness[mfunc][p]=mfunc[p]]
]


Dominates[p_,q_,m_]:=Dominates[p,q,m]=Block[{},
pans=SaveFit[#,p]&/@m;
qans=SaveFit[#,q]&/@m;
Or@@{Or@@(#[[1]]>#[[2]]&/@Transpose[{pans,qans}]),
Or@@(#[[1]]>=#[[2]]&/@Transpose[{pans,qans}])}
]


FindNonDominatedFront[P_,m_]:=Block[{Pdash={}},
AppendTo[Pdash,P[[1]]];
Block[{a=#,deletes={}},
If[And@@(If[Dominates[a,Pdash[[#]],m],AppendTo[deletes,{#}];True,False]&/@Range[Length[Pdash]];),AppendTo[Pdash,a]];
Pdash=Delete[Pdash,deletes]]&/@Rest[P];
Pdash
]


FastNonDominatedSort[Pin_,m_]:=Block[{P=Pin,F={},i=0},
While[Length[P]>0,
F=AppendTo[F,FindNonDominatedFront[P,m]];
P=Complement[P,F[[-1]]];
i++;
];
F
]


DominationRank[P_List,m_List]:=Block[{P2},
P2=Outer[Dominates[#1,#2,m]&,P,P,1];
Count[#,True]&/@P2
]


PartialOrder[i_List,j_List]:=Module[{irank,jrankidistance,jdistance},
{{irank,jrank},{idistance,jdistance}}=Transpose[{i,j}];
irank>jrank||(irank===jrank&&idistance>jdistance)
]


ObjectiveSort[I_,mfunc_]:=Module[{ans},
ans=SaveFit[mfunc,#]&/@I;
I[[Ordering[ans]]]
]


CrowdingDistanceAssignment[P_List,m_List]:=Module[{Idistance=Table[0,{Length[P]}]},
Block[{mfunc=#},
ans=SaveFit[mfunc,#]&/@P;
Idistance+=MapIndexed[Min[Drop[#1,#2]]^2&,Outer[Abs[Subtract[##]]&,ans,ans]]]&/@m;
Idistance
]


DominationSortingList[P_,distances_,m_]:=Module[{ranks},
ranks=DominationRank[P,m];
Ordering[Transpose[{ranks,distances}],All,PartialOrder[#1,#2]&]
]


DominationSorting[P_,distances_,m_]:=Module[{ranks},
ranks=DominationRank[P,m];
P[[Ordering[Transpose[{ranks,distances}],All,PartialOrder[#1,#2]&]]]
]


DominationSortingValues[P_,distances_,m_]:=Module[{ranks},
ranks=DominationRank[P,m];
ranks*distances
]


EPOptimiseNDSGA[funcs_,nochroms_,iters_,pc_:0.25,mr_:0.01,nogenes_,genelength_,start_,end_,opts___]:=Block[{a,probs,b,c,alldata,current,best={-\[Infinity],0}},
startgene=Global`Start/.{opts}/.{Global`Start->Null};
converge=Global`Convergence/.{opts}/.{Global`Convergence->\[Infinity]};
selectmethod=ToExpression["EPOptimise`Private`Selection"<>ToString[If[MemberQ[selectionmethods,#],
Print["Using SelectionMethod \[Rule] "<>ToString[#]];
#,Print["Method not recognised: Using Roulette\nMethods \[Rule] Roulette, Universal, Truncation (TruncationThreshold) and Tournament (TournamentNumber)"];
Global`Roulette]&[Global`SelectionMethod/.{opts}/.{Global`SelectionMethod->Roulette}]]];printedsetting=False;
ruttingpopulationsize=Global`BreedingPool/.{opts}/.{Global`BreedingPool->nochroms};
If[ruttingpopulationsize<nochroms||selectmethod===EPOptimise`Private`SelectionTruncation,reinsertmethod=ToExpression["EPOptimise`Private`Reinsert"<>ToString[If[MemberQ[reinsertionmethods,#],
Print["Using ReinsertionMethod \[Rule] "<>ToString[#]<>"\nBreedingPool < Population \[Rule] Methods: Elitist and Uniform"];#,
Print["Reinsertion Method not recognised: Using Elitist\nBreedingPool < Population \[Rule] Methods: Elitist and Uniform"];
Global`Elitist]&[Global`ReinsertionMethod/.{opts}/.{Global`ReinsertionMethod->Elitist}]]],
If[ruttingpopulationsize>nochroms,
Print["Using Reinsertion Method \[Rule] Fitness (BreedingPool > Population)"];
reinsertmethod=EPOptimise`Private`ReinsertFitness,
Print["Using Reinsertion Method \[Rule] Pure (BreedingPool == Population)"];
reinsertmethod=EPOptimise`Private`ReinsertPure;
]
];
SeedRandom[];
alldata=Global`AllData/.{opts}/.{Global`AllData->True};

If[startgene===Null,P=CreateChrom[nochroms,genelength,nogenes],
P=Join[{TurnToBin[startgene,genelength,nogenes,start,end]},CreateChrom[nochroms-1,genelength,nogenes]]
];

fitdata={};rawdata={};
(*Print["Starting population = ",BinToGray[#]&/@population];*)
AllF={};
Do[
If[i>1,
Qreal=TurnToRange[#,genelength,nogenes,start,end]&/@Q;
R=Join[Preal,Qreal];
(*Print["R = ",R];*)
F=FastNonDominatedSort[R,funcs];
AppendTo[AllF,F];
i=1;Preal={};
While[Length[Preal]+Length[F[[i]]]<nochroms,
Preal=Join[Preal,F[[i]]];
i++;
];
Preal=Join[Preal,DominationSorting[F[[i]],CrowdingDistanceAssignment[F[[i]],funcs],funcs][[Range[nochroms-Length[Preal]]]]];
(*Print["Preal = ",Preal];*)
P=TurnToBin[#,genelength,nogenes,start,end]&/@Preal;
(*Print["P = ",P];*),
Preal=TurnToRange[#,genelength,nogenes,start,end]&/@P;
];

AppendTo[rawdata,(TurnToRange[#,genelength,nogenes,start,end]&/@P)];
SeedRandom[];
breedinglist={};

ruttingpopulation=selectmethod[P,CumulativeProbabilities[funcs,P,genelength,nogenes,start,end,rawdata,fitdata],ruttingpopulationsize,opts];
(*Print["breedinglist = ",breedinglist];*)

gruttingpopulation=BinToGray[#]&/@ruttingpopulation;
(*Print["Rutting population = ",gruttingpopulation];*)

If[Length[breedinglist]>1,
gbreedingpopulation=SelectforCrossover[gruttingpopulation,Length[breedinglist],pc];
gnewpopulation=Crossover[gbreedingpopulation,crossoverlist,genelength,nogenes];
(*Print["gnewpopulation = ",gnewpopulation];,*)
gnewpopulation=gruttingpopulation;
];
(*Print["crossoverlist = ",crossoverlist];*)

newpopulation=GrayToBin[#]&/@gnewpopulation;

population=reinsertmethod[P,newpopulation,breedinglist[[crossoverlist]],genelength,nogenes,start,end,funcs];
gpopulation=BinToGray[#]&/@population;
(*Print["New population = ",gpopulation];*)
gpopulation=Mutate[gpopulation,genelength,nogenes,mr];

Q=GrayToBin[#]&/@gpopulation;
(*Print["Final population = ",Q];*)

(*If[(current=(Union[MapThread[List,{Flatten[fitdata,1],Flatten[rawdata,1]}][[#]]]&[Position[Flatten[fitdata,1],Max[Flatten[fitdata,1]]][[1,1]]]))[[1]]>best[[1]],best=current;Print["New Fit Value -> ",best[[1]],"\tRaw Value -> ",best[[2]]]];
If[best[[1]]>=converge,Break[]];*)
iterationno=i;,
{i,1,iters}];

(*If[alldata,{Union[Extract[rawdata,#]&/@Position[fitdata,Max[fitdata]]],MapThread[List,{#[[1]],#[[2]]}]&/@MapThread[List,{rawdata,fitdata}]}];
Print["Best Results: "];(Union[MapThread[List,{Flatten[fitdata,1],Flatten[rawdata,1]}][[#]]]&[Position[Flatten[fitdata,1],Max[Flatten[fitdata,1]]][[1,1]]])
*)]


End[]


EndPackage[]
