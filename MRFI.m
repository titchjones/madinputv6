(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["Accelerator`MRFI`MRFI`",
{"Statistics`DataManipulation`",
"Statistics`DataSmoothing`"}]


MRFI::usage="MRFI.m is a package that implements the Multiple Resonance Frequency Identification method in a mumber of situations.";


interpolatedFrequency::usage="interpolatedFrequency[data] takes a 1 dimensional data set and returns the approximate frequency, v, of the peak with the greatest frequency (error, 1/N), the number of turns N and the summation \[Phi](v), necessary to calculate the exact frequency using the NAFF algorithm.";


peakFinder::"usage"="peakFinder[data,v] takes a 1 dimensional data set, and  the letter v, and uses the NAFF algorithm (without orthogonolisation) to  return the frequency, v, of the peak with the greatest frequency (error,  1/N^4, and the summations \[Phi](v), \[Phi](1-v) with that v substituted,  necessary to calculate the data that has contributed to that peak. This  calculation is done using the reconstructedData function.";


reconstructedData::usage="reconstructedData[data] takes a 1 dimensional data set, and uses the NAFF algorithm (without orthogonolisation) to return the frequency, v, of the peak with the greatest frequency (error, 1/N^4), the summation \[Phi](v), with that v substituted, and the data that has contributed to that peak. This data may then be subtracted from the original data, to remove that peak from the spectrum.";


findMultiplePeaks::usage="findMultiplePeaks[data,nopeaks] takes a 1 dimensional data set, and the number of peaks that you wish to find within the spectrum, and uses the NAFF algorithm (without orthogonolisation) to return a table containing the frequency, v, the summation \[Phi](v), and the data that has contributed to that peak, for each peak.";


expandPeak::usage="expandPeak[pk,{f,p},df] takes a peak object, pk, containing the peak frequency, height, lefthand and righthand bound of the peak, and compares it to the point {f,p} (the frequency and height of a point,) and expands the peak to include that point, if its close enough to the peak (using df.)";


closeto::usage="closeto[pk,{f,p}] takes a peak object, pk, containing the peak frequency, height, lefthand and righthand bound of the peak, and compares it to the point {f,p} and returns true if the point is part of that peak.";


spectralPeaks::usage="spectralPeaks[spectrum] takes the power spectrum of the data set, and returns a list of peak objects found.";


resOrder::usage="resOrder[r] finds the order of the resonance given by the res object, r.";


resonances::usage="resonances[ord,dim] creates a list of all resonances up to the order, ord, with dimension, dim. This list may be altered using selection rules.";


dotRes::usage="dotRes[q, k], takes the dot product between a list, q and a res object, k.";


dKAM::usage="dKAM[f, q, k] calculates a distance according to KAM theory between the peaks frequency and a particular resonance line given by k (res object,) q is the set of basic frequencies (tunes in the case of an accelerator).";


identifyPeak::usage="identifyPeak[{f,thiv},q,ress] takes the frequency, and \[Phi](v) or height of the peak, the set of basic frequencies, q, and the set of resonances being searched for, ress. It returns the original f and thiv entered, the distance dKAM and the resonance that is most likely to be causing that peak within the spectrum.";


turnResToLabel::usage="turnResToLabel[k] takes the res object k, and turns it into suitable format for a label on a graph.";


drawLabelledPeak::usage="drawLabelledPeak[f,res,peakdata,q,n] takes the frequency, assigned res object, the portion of original data that makes up the peak in the spectrum, the set of basic frequencies, and the maximum order of resonance searched for, n. It returns a Graphics object containing the peak in frequency space, labelled with its affecting resonance, and coloured with respect to the order of that resonance.";


returnResLines::usage="returnResLines[list,n] takes a list of pairs of resonances and the frequency position of each peak, and the maximum order of res searched for, n, found from a single particle spectrum. It returns the associated labelled resonance lines.";


ConstantsUnits::badarg = "You called `1` with argument `2`!"


Begin["`Private`"]


minGodelPrimeIndex = 10;


interpolatedFrequency[data_]:=Module[{spec,a,b,f,\[Chi],thiv,Nm},spec=Transpose[powerSpectrum[data]];a=First[spec];b=Last[spec];f=Extract[a,Position[b,Max[b]]];Nm=Length[data];\[Chi]=Table[(1-Cos[(2 n \[Pi])/Nm]),{n,1,Nm}];thiv[v]=1/Sqrt[Nm](\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(n = 1\), \(Nm\)]\(data[\([n]\)] \[Chi][\([n]\)] 
\*SuperscriptBox[\(E\), \(\(-2\)\ \[Pi]\ I\ v\ n\)]\)\));{f,Nm,thiv[v]}]


peakFinder[data_,v_]:=Module[{s,min},s=interpolatedFrequency[data];
min=FindMinimum[-Abs[s[[3]]],{v,First[s[[1]]]-1/(2*s[[2]]),First[s[[1]]]+1/(2*s[[2]])}];{{v,(1-v)}/.min[[2]],s[[3]]/.min[[2]],s[[3]]/.v->(1-v)/.min[[2]]}]


reconstructedData[data_]:=Module[{pfam,newdata,Nm},Nm=Length[data];pfam=peakFinder[data,v];newdata=Table[(1/Sqrt[Nm](pfam[[2]] E^(2 \[Pi] I pfam[[1]][[1]] n)+pfam[[3]] E^(2 \[Pi] I pfam[[1]][[2]] n))),{n,1,Nm}];{pfam[[1]][[1]],pfam[[2]],newdata}]


findMultiplePeaks[data_,nopeaks_]:=Module[{pks,datanew,altered,pmax,fp,peakFound},datanew=reconstructedData[data];
altered=data;
pks={{datanew[[1]],datanew[[2]],datanew[[3]]}};
Do[altered=altered-datanew[[3]];
datanew=reconstructedData[altered];
pks=Join[pks,{{datanew[[1]],datanew[[2]],datanew[[3]]}}],{nopeaks-1}];
Return[pks]]


expandPeak[pk_,{f_,p_},df_]:={pk[[1]],pk[[2]],Min[pk[[3]],f-df],Max[pk[[4]],f+df]}


closeto[pk_,{f_,p_}]:=pk[[3]]<f&&f<pk[[4]]


spectralPeaks[spectrum_]:=Module[{ndf,df,pk0,pks,sortspec,fmax,pmax,fp,peakFound},ndf=Max[2,Length[spectrum]/50];
df=ndf First[spectrum[[2]]-spectrum[[1]]];
sortspec=Sort[spectrum,Last[#1]>Last[#2]&];
{fmax,pmax}=First[sortspec];
pk0={fmax,pmax,fmax-df,fmax+df};
pks={pk0};
Do[fp=sortspec[[j]];
peakFound=False;
pks=Map[(If[closeto[#,fp],peakFound=True;expandPeak[#,fp,df],#])&,pks];
If[Not[peakFound],pks=Join[pks,{{fp[[1]],fp[[2]],fp[[1]]-df,fp[[1]]+df}}]],{j,2,Length[spectrum]}];
Return[pks]]


resOrder[r_res]:=Plus@@(Abs[r]/.res->List)


resonances[ord_Integer,dim_Integer]:=Complement[Select[Flatten[Outer[res,Sequence@@Table[Range[-ord,ord],{dim}]],dim-1],(resOrder[#]<=ord)&],{res[0,0,0]}]


dotRes[q_List,k_res]:=Plus@@Table[q[[i]]*k[[i]],{i,1,Length[k]}]


dKAM[f_,q_List,k_res]:=Min[Abs[f-FractionalPart[dotRes[q,k]]],Abs[f-1+FractionalPart[dotRes[q,k]]]] resOrder[k]^4


identifyPeak[{f_,thiv_},qv_List,ress_]:=Flatten[{f,thiv,First[Sort[{dKAM[f,qv,#],#}&/@ress]]},1]


turnResToLabel[k_res]:={k[[1]],k[[2]],k[[3]]}


drawLabelledPeak[infopkxn1_,infopkxn4_,pksxn3_,qq_,n_]:=Module[{freq,h,logdata},freq=infopkxn1;h=Max[Last[Transpose[powerSpectrum[pksxn3]]]];logdata=({#1[[1]],Log[#1[[2]]]}&)/@powerSpectrum[pksxn3];Graphics[{Hue[(resOrder[infopkxn4]-1)/n],Line[logdata],RGBColor[0,0,0],Text[Style[ToString[turnResToLabel[infopkxn4]],FontFamily->"Times",FontSize->10],{freq,Log[h]},{0,-1}]}]]


returnResLines[list_,ord_]:=Module[{ress,nores,lines,col},ress=Union[First[Transpose[list]]];nores=Length[ress];col=Table[resOrder[ress[[k]]],{k,nores}];lines=Table[Select[list,#1[[1]]==ress[[k]]&],{k,nores}];Table[Graphics[{Hue[(col[[k]]-1)/ord],Line[Transpose[Drop[Transpose[lines[[k]]],1]]],Hue[(col[[k]]-1)/ord],Text[Style[ToString[turnResToLabel[lines[[k]][[1]][[1]]]],FontFamily->"Times",FontSize->10],{lines[[k]][[1]][[2]],lines[[k]][[1]][[3]]},{-1,0}]}],{k,nores}]]


(* Sin/: Sin[x_]^2 := 1 - Cos[x]^2 *)


(* Protect[ Evaluate[protected] ] *)


End[ ]


Protect[Evaluate[$Context <> "*"]]


EndPackage[ ]


qptnc=toNormalCoords[makeTrackTable[tfsRead[trackTableFile["VaryIY+2"]]]];



