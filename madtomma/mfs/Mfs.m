(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["Madtomma`Mfs`Mfs`","JMJUtils`BumpEtc`"]


Mfs::usage = "Mfs.m is a package for manipulating MFS data.";


mfs::usage= "mfs is a data object type containing a set of scalar variables with values and a set of labelled columns of data; typically it can represent the data structures in TFS files.";


mfsTypes::usage="mfsTypes is a list of the types of data related to the basic mfs type.  Various mfs data functions will apply to the elements in the class."


tfsRead::usage="tfsRead[file] returns an mfs data object containing all the information in a TFS file."


removeUnwantedLines::usage:="removeUnwantedLines[infile,outfile,string] copies file infile to outfile, removing all lines containing string.";


removeQuotes::usage:="removeQuotes[x] will remove any double quotes \" explicitly included in a string x.  If x is not a string then it is returned unchanged.";


stringRemoveLeadingTrailingBlanks::usage="stringRemoveLeadingTrailingBlanks[string] removes leading and trailing blanks from a string."


tfsParseDescriptorLine::usage="tfsParseDescriptorLine[string] takes a TFS descriptor line as a string and returns a list consisting of the TFS key and its value.";


interpretTagValue::usage="interpretTagValue[{\"tag\",val}] creates a variable tag and assigms it the value val.";


tfsFormatRules::usage="tfsFormatRules is an option of tfsRead and related functions like tfsParseHeaderBlock.  It gives a set of rules for transforming TFS column formats into Mathematica data types.";


tfsParseHeaderBlock::usage="tfsParseHeaderBlock[file] returns the information in the header block of a TFS file as a structured list.  It is normally used inside readTfsTable.";


mfsInterpretKeys::usage="mfsInterpretKeys[mfsdata] creates a set of variables with values from the keys in an mfs (or related) data object. Any existing values are over-written.";


mfsInterpretColumns::usage="mfsInterpretColumns[mfsdata] creates a set of variables with values from the columns in an mfs (or related) data object. Any existing values are over-written.";


mfsInterpret::usage="mfsInterpret[mfsdata] creates a set of variables with values from the keys and columns in an mfs (or related) data object. Any existing values are over-written.\nmfsInterpret[\"filename\"] creates such variables using data from a TFS file.";


(* ::Input::RGBColor[1, 0, 0]:: *)
interpretDescriptors::usage="Obsolete function name.  Please use mfsInterpretKeys.";


mfsKeyValue::usage= "mfsKeyValue[mfsdata,key] returns the value corresponding to a descriptor key (a string) in an mfs (or related) data object.";


(* ::Input::RGBColor[1, 0, 0]:: *)
keyValue::usage="Obsolete function name.  Please use mfsKeyValue.";


mfsColumnNames::usage ="mfsColumnNames[mfsdata] returns the list of column names in an mfs data (or related) object.";


(* ::Input::RGBColor[1, 0, 0]:: *)
columnNames::usage="Obsolete function name.  Please use mfsColumnNames.";


mfsKeyNames::usage="mfsKeyNames[mfsdata] returns the list of key names in the header block of an mfs (or related) data object.";


(* ::Input::RGBColor[1, 0, 0]:: *)
descriptorNames::usage="Obsolete function name.  Please use mfsKeyNames.";


mfsColumn::usage="mfsColumn[mfsdata,colname] returns the column of data labelled by the string colname in an mfs (or related) data object. A list of colnames may also be given to return a set of columns.  If colname is absent the entire block of columns is returned.";


mfsColumnValue::usage="mfsColumnValue[mfsdata,row,key] extracts a value labelled by key in row from an mfsdata object.";


(* ::Input::RGBColor[1, 0, 0]:: *)
colValue::usage="Obsolete function name.  Please use mfsColumnValue.";


mfsSelect::usage="mfsSelect[mfsdata,criterion] extracts rows satisfying criterion (function) from an mfsdata object.";


mfsMember::usage="mfsMember[mfsdata,key,targetset] extracts rows of an mfsdata object for which values labelled by key belong to targetset.";


mfsNotMember::usage="mfsNotMember[mfsdata,key,targetset] extracts rows of an mfsdata object for which values labelled by key DO NOT belong to targetset.";


mfsRange::usage="mfsRange[mfsdata,key,{min,max}] extracts rows of an mfsdata object for which values labelled by key lie within min and max. NOTE : min must be smaller than max !!!";


mfsDrop::usage = "mfsDrop is an option for removeUnwantedLines, tfsParseHeaderBlock and tfsRead that specifieds whether informative messages should be printed."


mfsVerbose::usage = "mfsVerbose is an option for removeUnwantedLines, tfsParseHeaderBlock and tfsRead that specifieds whether informative messages should be printed."


keepTemporaryFile::usage="keepTemporaryFile is an option for tfsRead that causes a temporary file not to be deleted."


DropNaN::usage="DropNaN is an option for tfsRead that causes all occurences of NaN to be returned as 0."


VariablePrefix::usage="VariablePrefix is an option for tfsRead that causes all column names to be prefixed with a string."


mfsAddKey::usage="mfsAddKey[mfsdata,{\"KEY\",value}] returns the mfs (or related) data object mfsdata with an additional key and value.";


(* ::Input::RGBColor[1, 0, 0]:: *)
addDescriptor::usage="Obsolete function name.  Please use mfsAddKey.";


mfsEditKey::usage = "mfsEditKey[mfsdata,{key,newValue}] returns the mfs (or related) data object mfsdata with the value corresponding to the descriptor key replaced by newValue." 


(* ::Input::RGBColor[1, 0, 0]:: *)
editDescriptor::usage="Obsolete function name.  Please use mfsEditKey.";


mfsDeleteKey::usage = "mfsDeleteKey[mfsdata,key] returns  the mfs (or related) data object mfsdata with the descriptor key removed.";


(* ::Input::RGBColor[1, 0, 0]:: *)
deleteDescriptor::usage="Obsolete function name.  Please use mfsDeleteKey.";


mfsDeleteColumn::usage="mfsDeleteColumn[qp,\"colname\"] returns an mfs object equal to qp but with the column labelled colname removed. A list of column names can also be given.";


mfsAddColumn::usage="mfsAddColumn[qp,\"colname\",coldata] returns an mfs object equal to qp but with a new column labelled colname and containing data coldata added. A list of column names and columns of data can also be given.";


mfsReverse::usage="mfsReverse[mfsdata] returns the mfs object with the rows of the main block of columns in reverse order.";


mfsColumnMatch::usage="mfsColumnMatch[{qp1,qp2,...},{\"col1\",\"col2\",...}] tests whether a list of column namesmatch in all the mfs objects in which they appear.";


mfsMerge::usage="mfsMerge[{qp1,qp2,...}] nerges a list of mfs objects into a single one containing all the header and column information in each of them.  The column lengths must match."


matchColumns::usage="matchColumns is an option for mfsMerge that gives a list of column names that must match in all the mfs objects in which they appear.  The value Automatic insists that all possible matches hold.";


mfsFixMAD8inconsistencies::usage="mfsFixMAD8inconsistencies[qp] returns a new mfs object with corrections for inconsistencies that may arise from it's having been generated by MAD Version 8."


(* ::Input::RGBColor[1, 0, 0]:: *)
mfsVersion2Update::usage="mfsVersion2Update[oldfile,newfile] will create a new version of a file in which names of functions in Version 1.x of the Madtomma`Mfs`Mfs` package are changed to their equivalents in Version 2.x."


(* ::Input::RGBColor[1, 0, 0]:: *)
mfsVersion2UpdateRules::usage="mfsVersion2UpdateRules is a list of string replacement rules that will change names of functions in Version 1.x of the Madtomma`Mfs`Mfs` package to their equivalents in Version 2.x.";


mfsKeyValue::notfound = "Descriptor `1` not found.";


mfsKeyValue::notkey = "`1` is not a string, hence not a possible key.";


mfsColumn::notfound = "Column `1` not found.";


mfsAddKey::badarg = "`1` not valid key-value pair";


mfsEditKey::badarg = "`1` not valid key-value pair";


mfsDeleteKey::badarg = "`1` not valid key-value pair";


mfsColumnValue::notfound="`1` is not a proper column name.";


mfsRange::badarg="The first element of a range specification (`1`) should be smaller than the second one (`2`).";


mfsAddColumn::collength="Columns with different column lengths cannot be merged into an mfs object." ;


(* ::Input::RGBColor[1, 0, 0]:: *)
mfs::oldname="`1` is an obsolete function name.  Please use `2` from now on.";


mfsMerge::badmatch="Some columns specified by the matchColumns option do not match."


mfsMerge::collength="Not all columns have the same length. mfs objects cannot be merged."


interpretTagValue::changename="Invalid variable name `1` changed to `2`";


Begin["`Private`"]


mfsTypes={mfs}


removeUnwantedLines[rawFile_String,filteredFile_String,unwanted_String,opts___Rule]:=Module[{oo},oo=OpenWrite[filteredFile];removeUnwantedLines[rawFile,oo,unwanted,opts];Close[oo]]


removeUnwantedLines[rawFile_String,oo_OutputStream,unwanted_String,opts___Rule]:=Module[{tt,ll},
		tt=OpenRead[rawFile];
		verbose=mfsVerbose/.{opts} /. Options[removeUnwantedLines];
		If[verbose,Print["Input file: ",tt,"  Output file: ",oo],Null];
		ll="0Segment0";
		While[Not[ll===EndOfFile],
			If[StringMatchQ[ToLowerCase[ToString[ll]],"*"<>ToLowerCase[unwanted]<>"*"],Null,WriteString[oo,ll<>"\n"]];
			ll=Read[tt,Record]];
		Close[tt];
	]


removeQuotes[x_Real]:=x;
removeQuotes[x_String]:=StringReplace[x,"\""->""];
removeQuotes[x_]:=x


stringRemoveLeadingTrailingBlanks[str_]:=
	Module[{after,before},
		StringJoin[
			(Characters[str]
						//.{" ",after___}->{after}
			)//.{before___," "}->{before}
		]
	]


tfsParseDescriptorLine[str_String]:=Module[{tp,tp2,tp3,data1,data2},tp=First[ReadList[(data1=StringToStream[str]),{Word,Word,String},WordSeparators->{" ","\"","\t","@"}]];
tp2=Flatten[{First[tp],If[StringTake[tp[[2]],{-1}]=="s",StringReplace[stringRemoveLeadingTrailingBlanks[Last[tp]],{"\" "->""," \""->"","\""->""}],tp3=ReadList[(data2=StringToStream[Last[tp]]),Number];
Close[data2];tp3]}];Close[data1];tp2]


Options[tfsParseHeaderBlock]={mfsVerbose->False,tfsFormatRules->{"%e"->Number,"%hd"->Number,"%d"->Number,"%lf"->Number,"%f"->Number,"%le"->Number,"%s"->Word,"%16s"->Word,"%32s"->Word,"~"->Word}};


tfsParseHeaderBlock[tfsFile_String, opts___Rule] := Module[{tt, headers, keyvals, lastKeyPos, fmtrules, data, data2, verbose, ll, fmts},
  			verbose = mfsVerbose /. {opts} /. Options[tfsParseHeaderBlock];
  		fmtrules = tfsFormatRules /. {opts}  /. Options[tfsParseHeaderBlock];
  		tt = OpenRead[tfsFile]; (* get column header info *)
                ll = Find[tt, "*", AnchoredSearch -> True];
  		headers = ReadList[(data = StringToStream[ll]), Word, WordSeparators -> {" ", "*", ","}];
  		Close[tt]; Close[data];
  		tt = OpenRead[tfsFile]; (* get column format info *)
  		ll = Find[tt, "$", AnchoredSearch -> True];
  		fmts = ReadList[(data2 = StringToStream[ll]), Word, WordSeparators -> {" ", "$", ","}] /. Flatten[fmtrules]; Close[data2];
  		If[verbose, Print[fmts]];
  		Close[tt];
  		tt = OpenRead[tfsFile];
  		ll = ""; keyvals = {}; lastKeyPos = 0;
  		While[
   			Not[ll === EndOfFile],
   			If[StringLength[ll] > 0 && (StringTake[ll, 1] == "@"),
			AppendTo[keyvals, tfsParseDescriptorLine[ll]]
    			];
		     lastKeyPos = StreamPosition[tt];	
   		  ll = Find[tt, {"@", "$", "*"}, AnchoredSearch -> True];
   			];
  		Close[tt]; {keyvals, fmts, headers, lastKeyPos}
  	]


Options[tfsRead]=Options[tfsParseHeaderBlock]\[Union]{keepTemporaryFile->False,DropNaN->False,VariablePrefix->""}


tfsRead[tfsFile_String,opts___Rule]:=Block[{tempFile,tt,hh,cols,particles,turns,tempStream,verbose,keepTemp,dropNaN,prefix},
tempStream=OpenWrite[];
verbose=mfsVerbose/. {opts}/. Options[tfsRead];
keepTemp=keepTemporaryFile/. {opts}/. Options[tfsRead];
dropNaN=DropNaN/. {opts}/. Options[tfsRead];
prefix=VariablePrefix/.{opts}/.Options[tfsRead];
removeUnwantedLines[tfsFile,tempStream,"Segment"];
Close[tempStream];
tempFile=First[tempStream];
hh=tfsParseHeaderBlock[tempFile,opts];
hh[[-2]]=Map[prefix<>#&,hh[[-2]]];
If[verbose,Print["Header block:\n",First[hh],"\nColumns labels:  ",hh[[-2]],"\nColumn formats:  ",hh[[-3]],"\nColumn data starts at position ",Last[hh]," in ",tempFile]];
tt=OpenRead[tempFile];
SetStreamPosition[tt,Last[hh]];
If[dropNaN,
cols=Map[removeQuotes,(ToExpression[StringReplace[#1,{"E"->"*10^","NaN"->"\[Infinity]"}]]&)/@ReadList[tt,hh[[-3]]/. {Number->Word}],{-1}];,
cols=Map[removeQuotes,ReadList[tt,hh[[-3]]],{-1}];];
Close[tt];
If[keepTemp,Print["Temporary file not deleted: ",tempFile],DeleteFile[tempFile]];
mfs[First[hh],hh[[-2]],cols]]


interpretTagValue[{tag_String,value_}]:=Block[{temp,newtag},
temp=value;
newtag=StringReplace[tag,{"_"->"$$"}];
If[newtag!=tag,Message[interpretTagValue::changename,tag,newtag]];
ToExpression["Global`"<>newtag<>" = "<>"Madtomma`Mfs`Mfs`Private`temp"]
		]


mfsInterpretKeys[qp_mfs,opts___]:=(interpretTagValue/@First[qp];If[(mfsVerbose/.{opts}/.Options[mfsInterpret])===True,Print["Variables (re-)assigned: ",mfsKeyNames[qp]]])


mfsInterpretColumns[qp_mfs,opts___]:=(If[(mfsDrop/.{opts}/.Options[mfsInterpret]),
interpretTagValue/@Transpose[{qp[[-2]],Transpose[Rest[Drop[Last[qp],-1]]]}],
interpretTagValue/@Transpose[{qp[[-2]],Transpose[Last[qp]]}]];
If[(mfsVerbose/.{opts}/.Options[mfsInterpret])===True,Print["Variables (re-)assigned: ",mfsColumnNames[qp]]])


Options[mfsInterpret]={mfsVerbose->False,mfsDrop->True};


mfsInterpret[qp_mfs,opts___]:=(mfsInterpretKeys[qp,opts];mfsInterpretColumns[qp,opts];)


mfsInterpret[fn_String,opts___]:=mfsInterpret[tfsRead[fn,opts],opts];


mfsKeyNames[qp_mfs]:=First[Transpose[First[qp]]]


mfsKeyValue[qp_mfs,key_String]:=Module[{qp1,pp},
		qp1=First[qp];
		pp=Position[qp1,key];
		If[pp=={},
			(Message[mfsKeyValue::notfound,key];Null),Extract[qp1,MapAt[(#+1)&,First[pp],-1] ]]
	]


mfsKeyValue[qp_mfs,keys_List]:=(mfsKeyValue[qp,#])& /@ keys


mfsKeyValue[qp_mfs,key_]:=(Message[mfsKeyValue::notkey,key];Null)


mfsColumnNames[qp_mfs]:=qp[[-2]]


mfsColumn[qp_mfs,key_String]:=Module[{},
		pos=Position[mfsColumnNames[qp],key];
		If[pos=={},(Message[mfsColumn::notfound,key];Null),Column[Last[qp],pos[[1,1]] ]]
	]


mfsColumn[qp_mfs,keys_List]:= mfsColumn[qp,#]& /@ keys


mfsColumn[qp_mfs]:=Last[qp]


mfsColumnValue[qp_mfs,row_List,key_String]:=
If[MemberQ[mfsColumnNames[qp],key],	
First[Take[row,First[Position[mfsColumnNames[qp],key]]]],Message[mfsColumnValue::notfound,key]]


mfsSelect[qp_mfs,crit_Function]:=Module[{},
		ReplacePart[qp,
			Select[Last[qp],crit[#]& ]
		,{-1}]
	]


mfsMember[qp_mfs,key_String,targetset_List]:=mfsSelect[qp,(MemberQ[targetset,mfsColumnValue[qp,#,key]])&]


mfsNotMember[qp_mfs,key_String,targetset_List]:=mfsSelect[qp, !(MemberQ[targetset,mfsColumnValue[qp,#1,key]])&]


mfsRange[qp_mfs,key_String,{min_,max_}]:=
	If[min<max,mfsSelect[qp,( (mfsColumnValue[qp,#,key]>=min) && (mfsColumnValue[qp,#,key]<=max))&],Message[mfsRange::badarg,min,max]]


mfsAddKey[qp_mfs,{key_String,value_}]:=
	ReplacePart[qp,Join[qp[[1]],{{key,value}}],1];
mfsAddKey[qp_mfs,badarg_]:=	(Message[mfsAddKey::badarg,badarg];Null)


mfsDeleteKey[qp_mfs,key_String]:=
	Module[{qp1,pp},
		qp1=First[qp];
		pp=Position[qp1,key];
		If[pp=={},
			(Message[mfsKeyValue::notfound,key];Null),ReplacePart[qp,Select[qp1,(Not[First[#]==key])&],1]
	]];
mfsDeleteKey[qp_mfs,badarg_]:=	(Message[mfsDeleteKey::badarg,badarg];Null)


mfsEditKey[qp_mfs,{key_String,newValue_}]:=Module[{qp1,pp},
		qp1=First[qp];
		pp=Position[qp1,key];
		If[pp=={},
			(Message[mfsKeyValue::notfound,key];Null),ReplacePart[qp,ReplacePart[qp1,newValue,MapAt[(#+1)&,First[pp],-1]],1]
	]];
mfsEditKey[qp_mfs,badarg_]:=	(Message[mfsEditKey::badarg,badarg];Null)


mfsReverse[qp_mfs]:= ReplacePart[qp,Reverse[Last[qp]],-1]


mfsDeleteColumn[qp_mfs,colname_String]:=
	Module[{colpos},
		colpos=Position[mfsColumnNames[qp],colname];
		mfs[
			First[qp],
			Drop[qp[[-2]],First[colpos]],
			Drop[#,First[colpos]]&/@Last[qp]
		]
	];


mfsDeleteColumn[qp_mfs,colnames:{__String}]:=
	Module[{cols=colnames,qpr=qp},
		While[cols=!={},
			qpr=mfsDeleteColumn[qpr,First[cols]];
			cols=Rest[cols]
		];
		qpr
	]


mfsAddColumn[qp_mfs,colname_String,col_List]:=
	mfsMerge[{qp,mfs[{},{colname},Transpose[{col}]]}]


mfsAddColumn[qp_mfs,colnames:{__String},cols:{__List}]:=
	If[Equal@@(Length/@cols),
		mfsMerge[{qp,mfs[{},colnames,Transpose[cols]]}],
		(Message[mfsAddColumn::collength];Null)
		]


mfsHeaderMerge[h:{__List}]:=
	Module[{done={},rest=Union@@h,key,tomerge},
		While[rest=!={},
			key=First[First[rest]];
			tomerge= Select[rest,(First[#]==key&)];
			AppendTo[done,
				If[Length[tomerge]==1,First[tomerge],{key,Last/@tomerge}]
			];
			rest=Complement[rest,tomerge];
			];
		done
	]


mfsColumnMatch[qp:{__mfs},mcol_String]:=
	Module[{},
		Equal@@(mfsColumn[#,mcol]& /@ (Select[qp,MemberQ[mfsColumnNames[#],mcol]&]))
			]


mfsColumnMatch[qp:{__mfs},matchCols:{__String}]:=And@@(mfsColumnMatch[qp,#1]&)/@matchCols


mfsColumnMatch[qp:{__mfs},{}]:=True;
mfsColumnMatch[qp:{__mfs}]:=True


Options[mfsMerge]={matchColumns->{"NAME"}};


mfsMerge[qp:{__mfs},opts___?OptionQ]:=
	Module[{matchCols,colnameswanted,allcolnames},
		matchCols=matchColumns/.{opts}/.Options[mfsMerge];
		If[matchCols==Automatic,
			matchCols=Union@@(mfsColumnNames/@qp)
		];
		If[mfsColumnMatch[qp,matchCols],
			If[Equal@@(Length[Last[#]]&/@qp),
				colnameswanted=Union[allcolnames=Join@@(Part[#,-2]&/@qp)];
		mfs[
					mfsHeaderMerge[First/@qp],
					colnameswanted,
					Transpose[Extract[Transpose[MapThread[Join,Last/@qp]],First/@(Position[allcolnames,#]&/@colnameswanted)]]
				],
			(Message[mfsMerge::badmatch];Null)
			],
		(Message[mfsMerge::collength];Null)
		]
	]


mfsFixMAD8inconsistencies[qp_mfs]:=Module[{kv,ch},
kv=First[qp]/.{
{"X",x_}->{"XC",x},
{"PX",px_}->{"PXC",px},
{"Y",y_}->{"YC",y},
{"PY",py_}->{"PYC",py},
{"T",t_}->{"TC",x},
{"DELTAP",pt_}->{"PTC",pt}
};
ch=qp[[-2]]/.{"DELTAP"->"PT"};
ReplacePart[
ReplacePart[qp,kv,{1}],
ch,{-2}
]
]


(* ::Input::RGBColor[1, 0, 0]:: *)
interpretDescriptors[x__]:=(
		Message[mfs:oldname,"interpretDescriptors","mfsInterpretKeys"];
		mfsInterpretKeys[x]
	);


(* ::Input::RGBColor[1, 0, 0]:: *)
keyValue[x__]:=(
		Message[mfs:oldname,"keyValue","mfsKeyValue"];
		mfsKeyValue[x]
	);


(* ::Input::RGBColor[1, 0, 0]:: *)
columnNames[x__]:=(
		Message[mfs:oldname,"columnNames","mfsColumnNames"];
		mfsColumnNames[x]
	);


(* ::Input::RGBColor[1, 0, 0]:: *)
descriptorNames[x__]:=(
		Message[mfs:oldname,"descriptorNames","mfsKeyNames"];
		mfsKeyNames[x]
	);


(* ::Input::RGBColor[1, 0, 0]:: *)
colValue[x__]:=(
		Message[mfs:oldname,"colValue","mfsColumnValue"];
		mfsColumnValue[x]
	);


(* ::Input::RGBColor[1, 0, 0]:: *)
addDescriptor[x__]:=(
		Message[mfs:oldname,"addDescriptor","mfsAddKey"];
		mfsAddKey[x]
	);


(* ::Input::RGBColor[1, 0, 0]:: *)
editDescriptor[x__]:=(
		Message[mfs:oldname,"editDescriptor","mfsEditKey"];
		mfsEditKey[x]
	);


(* ::Input::RGBColor[1, 0, 0]:: *)
deleteDescriptor[x__]:=(
		Message[mfs:oldname,"deleteDescriptor","mfsDeleteKey"];
		mfsDeleteKey[x]
	);


(* ::Input::RGBColor[1, 0, 0]:: *)
mfsVersion2UpdateRules={"interpretDescriptors"->"mfsInterpretKeys","keyValue"->"mfsKeyValue","columnNames"->"mfsColumnNames","descriptorNames"->"mfsKeyNames","colValue"->"mfsColumnValue","addDescriptor"->"mfsAddKey","editDescriptor"->"mfsEditKey","deleteDescriptor"->"mfsDeleteKey","symplecticJ"->"SymplecticJ"}


(* ::Input::RGBColor[1, 0, 0]:: *)
mfsVersion2Update[oldFile_String,newFile_String]:=stringReplaceInFile[oldFile,newFile,mfsVersion2UpdateRules]


End[ ]


Protect[mfsTypes,removeUnwantedLines,tfsParseDescriptorLine,interpretTagValue,(*tfsInterpretDescriptorLine,*)tfsParseHeaderBlock,mfsColumn,mfsSelect, mfsMember, mfsRange,mfsReverse,mfsAddKey,mfsKeyNames,mfsColumnNames,mfsInterpretKeys,mfsKeyValue,mfsColumnValue,mfsEditKey,mfsDeleteColumn,mfsAddColumn,mfsMerge,mfsDeleteKey,
	addDescriptor,editDescriptor,interpretDescriptors,deleteDescriptor, colValue, keyValue,columnNames,descriptorNames
]


EndPackage[ ]


(*If[$Remote,Print["Remote kernel: MfsPalette.nb will not be opened"],NotebookOpen[ToFileName[packageSourceDirectory["Mfs"],"MfsPalette.nb"]]]*)


Print["Version 2.21 of Madtomma`Mfs`Mfs` loaded.  Note function name changes since Version 1.x:\n",TableForm[mfsVersion2UpdateRules]]



