(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Needs["sddsBinaryInterpret`"]


(* ::Input::Initialization:: *)
Needs["numberRight`"]


(* ::Input::Initialization:: *)
elementDefinition::usage=""


(* ::Input::Initialization:: *)
elementLine::usage=""


(* ::Input::Initialization:: *)
commandDefinition::usage=""


(* ::Input::Initialization:: *)
elementInterpretLTE::usage=""


(* ::Input::Initialization:: *)
ElegantTwiss::usage=""


(* ::Input::Initialization:: *)
ElementDraw::usage=""


(* ::Input::Initialization:: *)
ElementPositions::usage=""


(* ::Input::Initialization:: *)
ElementFootPrint::usage=""


(* ::Input::Initialization:: *)
allElements={};


(* ::Input::Initialization:: *)
SetAttributes[replaceRuleNames,{HoldAll,Listable}];
replaceRuleNames[Rule[x_,y_]]:=Block[{},
Rule[ToUpperCase[ToString[HoldForm[x]]],y]
]


(* ::Input::Initialization:: *)
element[list__Rule]/;MemberQ[{list}[[All,1]],"NAME"]:=Block[{name},
name="NAME"/.{list};
allElements=Union[AppendTo[allElements,name]];
Clear[Evaluate[name]];
Evaluate[Symbol@name]=elementDefinition[list]
]


(* ::Input::Initialization:: *)
element[magnet_,var__Symbol]:=var/.Evaluate[magnet]


(* ::Input::Initialization:: *)
Clear[GetProperty];
GetProperty[elementDefinition[list__],var_]:=Block[{},
ToUpperCase[var]/.{list}
]


(* ::Input::Initialization:: *)
Unprotect[SetProperty];


(* ::Input::Initialization:: *)
SetProperty[elementDefinition[x__], {y_Rule}] := SetProperty[elementDefinition[x], Rule[ToUpperCase[ToString[y[[1]]]], y[[2]]]]


(* ::Input::Initialization:: *)
SetProperty[elementDefinition[x__], rules_List] := Fold[SetProperty[#1, {#2}] &, elementDefinition[x], rules]


(* ::Input::Initialization:: *)
SetProperty::"wrongtype" = "There are no elements of type \"`1`\" to modify.";


(* ::Input::Initialization:: *)
SetProperty[type_String, {y__Rule}] := Block[{list},
  list = Select[ToExpression[allElements], MemberQ[Map[ToUpperCase,#,{2}], Rule["TYPE",ToUpperCase[type]], 2] &];
  If[Length[list] > 0,
SetProperty[#, y] & /@ list,
Message[SetProperty::"wrongtype", type]
]
]


(* ::Input::Initialization:: *)
elementDefinition/:SetProperty[elementDefinition[x__],y__Rule]:=Block[{name},
name="NAME"/.Join[{y},{x}];
element[Sequence@@Map[Rule[#,#/.Join[{y},{x}]]&,Union[Join[{y},{x}][[All,1]]]]]
]


(* ::Input::Initialization:: *)
elementDefinition/:SetProperty[elementDefinition[x__],Rule[y_,Null]]:=Block[{name},
name="NAME"/.Join[{Rule[y,Null]},{x}];
element[Sequence@@Map[Rule[#,#/.{x}]&,Complement[{x}[[All,1]],{y}]]]
]


(* ::Input::Initialization:: *)
elementDefinition/:Rule[elementDefinition[list__][var_String],val_]:=SetProperty[elementDefinition[list], Rule[ToUpperCase[var],val]]


(* ::Input::Initialization:: *)
elementDefinition/:elementDefinition[list__][Rule[var_String,val_]]:=SetProperty[elementDefinition[list], Rule[ToUpperCase[var],val]]


(* ::Input::Initialization:: *)
elementDefinition/:elementDefinition[list__][rules__Rule]:=SetProperty[elementDefinition[list],Map[Rule[ToUpperCase[#[[1]]],#[[2]]]&,{rules}]]


(* ::Input::Initialization:: *)
elementDefinition/:Rule[elementDefinition[list__][var_String],val_]:=SetProperty[elementDefinition[list], Rule[ToUpperCase[var],val]]


(* ::Input::Initialization:: *)
elementDefinition /: Part[elementDefinition[list__], var_] := If[#===ToUpperCase[var],0,#]&[ToUpperCase[var] /. {list}]


(* ::Input::Initialization:: *)
elementDefinition /: elementDefinition[list__][ var_String] := If[#===ToUpperCase[var],0,#]&[ToUpperCase[var] /. {list}]


(* ::Input::Initialization:: *)
elementDefinition /: elementDefinition[list__][ var_String]/;ToUpperCase[var]=="LENGTH" := Block[{val},If[(val="LENGTH" /. {list})==="LENGTH",If[(val="L" /. {list})==="L",0,val],val]]


(* ::Input::Initialization:: *)
elementDefinition/:ReplaceAll[var_String|var_Symbol,elementDefinition[list__]]:=ToUpperCase[ToString[var]]/.{list}


(* ::Input::Initialization:: *)
commandDefinition/:ReplaceAll[var_String|var_Symbol,commandDefinition[list__]]:=ToUpperCase[ToString[var]]/.{list}


(* ::Input::Initialization:: *)
elementDefinition/:ReplaceAll[var_List,elementDefinition[list__]]:=ToUpperCase[ToString[#]]/.{list}&/@var


(* ::Input::Initialization:: *)
commandDefinition/:ReplaceAll[var_List,commandDefinition[list__]]:=ToUpperCase[ToString[#]]/.{list}&/@var


(* ::Input::Initialization:: *)
elementDefinition/:capitalRuleNames[elementDefinition[list__]]:=Map[Rule[ToUpperCase[#[[1]]],#[[2]]]&,{list}]


(* ::Input::Initialization:: *)
commandDefinition/:capitalRuleNames[commandDefinition[list__]]:=Map[Rule[StringReplace[ToLowerCase[#[[1]]],"sdds"->"SDDS"],#[[2]]]&,{list}]


(* ::Input::Initialization:: *)
elementLine/:ReplaceAll[var_,elementLine[list_]]/;Length[{list}]>1:=ToUpperCase[ToString[var]]/.{#}&/@list


(* ::Input::Initialization:: *)
elementLine/:ReplaceAll[var_,elementLine[list_]]/;Length[{list}]==1:=ToUpperCase[ToString[var]]/.list


(* ::Input::Initialization:: *)
elementLine/:-elementLine[list__]:=elementLine[Sequence@@Cases[{list},Except[Rule["REVERSED",_Boolean]]],"REVERSED"->True]


(* ::Input::Initialization:: *)
elementLine/:-elementLine[list__]:=elementLine[Sequence@@Reverse[Cases[{list},Except[Rule["REVERSED",_Boolean]]]],"REVERSED"->True]


(* ::Input::Initialization:: *)
elementDefinition/:Times[elementDefinition[list__],multiplier_]:=Sequence@@Table[elementDefinition[list],multiplier]
elementDefinition/:Times[multiplier_,elementDefinition[list__]]:=Sequence@@Table[elementDefinition[list],multiplier]


(* ::Input::Initialization:: *)
elementLine/:Times[elementLine[list__],multiplier_]:=Sequence@@Table[elementLine[list],multiplier]
elementLine/:Times[multiplier_,elementLine[list__]]:=Sequence@@Table[elementLine[list],multiplier]


(* ::Input::Initialization:: *)
elementLine/:Names[a:elementLine[list__],ignoreReverse_:False]:=Block[{reversed},
reversed="REVERSED"/.a/.{"REVERSED"->False};
If[ignoreReverse&&reversed,Reverse[#],#]&@
Flatten[(-2 Boole["REVERSED"/.#/.{"REVERSED"->False}]+1) ("NAME"/.#/.{"NAME"->{}})&/@Select[{list},(Head[#]===elementDefinition||Head[#]===elementLine&)]]
]


(* ::Input::Initialization:: *)
elementLine/:Names[a:elementLine[list__],n_Integer:1]:=Flatten[(-2 Boole["REVERSED"/.#/.{"REVERSED"->False}]+1) ("NAME"/.#/.{"NAME"->{}})&/@Cases[a,_elementDefinition|_elementLine,n]]


(* ::Input::Initialization:: *)
elementLine/:Names[a:elementLine[list__],\[Infinity]]:=Flatten[(-2 Boole["REVERSED"/.#/.{"REVERSED"->False}]+1) ("NAME"/.#/.{"NAME"->{}})&/@Join[Cases[a,elementDefinition[__],\[Infinity]]]]


(* ::Input::Initialization:: *)
elementDefinition/:Length[elementDefinition[list__]]:=Block[{},elementDefinition[list]["LENGTH"]]


(* ::Input::Initialization:: *)
elementLine/:Length[elementLine[list__]]:=Block[{},Total@Flatten[(-2Boole["REVERSED"/.#/.{"REVERSED"->False}]+1)("LENGTH"/.#/.{"LENGTH"->{}})&/@Map[Cases[#,_Rule,\[Infinity]]&,Flatten[elementLine[list]]]]]


(* ::Input::Initialization:: *)
elementLine/:Lengths[elementLine[list__]]:=Block[{},Flatten[(-2Boole["REVERSED"/.#/.{"REVERSED"->False}]+1)("LENGTH"/.#/.{"LENGTH"->0})&/@Map[Cases[#,_Rule,\[Infinity]]&,Flatten[elementLine[list]]]]]


(* ::Input::Initialization:: *)
elementLine/:Length[list__elementLine]:=Block[{},Total@Map[Length,Flatten[{list}]]]


(* ::Input::Initialization:: *)
elementLine/:CumulativeLength[list__elementLine]:=Block[{},Accumulate[Length/@Flatten[{list}]]]


(* ::Input::Initialization:: *)
elementLine/:ReplaceAll[var_String|var_Symbol,elementLine[list__]]:=ToUpperCase[ToString[var]]/.Cases[{list},_Rule]


(* ::Input::Initialization:: *)
elementLine/:Flatten[a:elementLine[list__]]:=ToExpression[Names[a,\[Infinity]]]


(* ::Input::Initialization:: *)
elementLine/:Flatten[a:elementLine[list__],n_Integer]:=ToExpression[Names[a,Integer]]


(* ::Input::Initialization:: *)
elementLine/:Flatten[a__elementLine]:=ToExpression[Names[elementLine[a],\[Infinity]]]


(* ::Input::Initialization:: *)
elementLine/:Part[elementLine[a__],pos_]:=Flatten[elementLine[a]][[pos]]


(* ::Input::Initialization:: *)
Unprotect[Flatten];
Flatten[{a__elementLine}]:=ToExpression[Names[elementLine[a],\[Infinity]]]
Protect[Flatten];


(* ::Input::Initialization:: *)
elementLine/:(a:elementLine[list__])[var_]:=If[#===ToUpperCase[var],0,#]&[ToUpperCase[var] /. #]&/@Flatten[a]


(* ::Input::Initialization:: *)
elementLine/:(a:elementLine[list__])["NAME"]:=("NAME"/.a/.{"NAME"->{}})


(* ::Input::Initialization:: *)
elementLine/:Join[a__elementLine]:=elementLine[a]


(* ::Input::Initialization:: *)
Clear[line];
ClearAttributes[line,HoldAll];
SetAttributes[line,HoldAll];
line[name_,{list__}]:=Block[{nameS},
Clear[Evaluate[ToString[HoldForm[name]]]];
(*If[ToString[HoldForm[name]]==="SPERIOD1VMX",Print[Names[elementLine[list]]]];*)
Evaluate[ToExpression[ToString[HoldForm[name]]]]:=elementLine["NAME"->ToString[HoldForm[name]],Sequence@@
Map[
Which[
Head[#]===Times,#[[1]]*ToExpression[#[[2]]],
True,ToExpression[#]
]&,
Names[elementLine[list]]]];
name
]


(* ::Input::Initialization:: *)
allowedElegantCharacters:=(WordCharacter|DigitCharacter|"~"|"@"|"$"|"%"|"^"|"&"|"-"|"_"|"+"|"="|"{"|"}"|"["|"]"|"|"|"\\"|"/"|"?"|"<"|">"|"."|"\"")


(* ::Input::Initialization:: *)
convertNames[string_String]:=StringReplace[string,{a:allowedElegantCharacters~~("_"|"-"|"."):>(a~~"$"),"\""->""}]


(* ::Input::Initialization:: *)
Unprotect[quad,sext,sbend,rbend,drift]


(* ::Input::Initialization:: *)
Clear[quad,sext,sbend,csbend,quadrupole,kquadrupole,sextupole,ksextupole,sectorbend,rbend,crbend,csrcsbend,drift,marker,monitor,bpm,hkick,vkick,kick,lcav,rfca,profile,watch]


(* ::Input::Initialization:: *)
SetAttributes[watch,HoldAll];
watch[name_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Watch","FILENAME"->"\"%s-%03ld.w1\"","NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->If[label=="",Null,label],Sequence@@replaceRuleNames[{extra}]]
]
watch[name_,filename_String:"\"%s-%03ld.w1\"",label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Watch","FILENAME"->filename,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->If[label=="",Null,label],Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[quad,HoldAll];
quad[in__]:=kquadrupole[in]


(* ::Input::Initialization:: *)
SetAttributes[quadrupole,HoldAll];
quadrupole[name_,length_,strength_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Quadrupole","LENGTH"->length,"K1"->strength,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[kquadrupole,HoldAll];
kquadrupole[name_,length_,strength_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"KQuad","LENGTH"->length,"K1"->strength,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[sextupole,HoldAll];
sextupole[name_,length_,strength_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Sextupole","LENGTH"->length,"K2"->strength,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
Clear[sext];
SetAttributes[sext,HoldAll];
sext[in__]:=ksextupole[in]


(* ::Input::Initialization:: *)
SetAttributes[ksextupole,HoldAll];
ksextupole[name_,length_,strength_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"KSext","LENGTH"->length,"K2"->strength,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[sectorbend,HoldAll];
sectorbend[name_,length_,strength_,angle_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"SectorBend","LENGTH"->length,"K1"->strength,"BENDANGLE"->angle,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[sbend,HoldAll];
sbend[in__]:=csbend[in]


(* ::Input::Initialization:: *)
SetAttributes[rbend,HoldAll];
rbend[in__]:=crbend[in]


(* ::Input::Initialization:: *)
SetAttributes[csbend,HoldAll];
csbend[name_,length_,strength_,angle_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"CSBend","LENGTH"->length,"K1"->strength,"BENDANGLE"->angle,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[crbend,HoldAll];
crbend[in__]:=Block[{elem},
elem=csbend[in];
SetProperty[elem,{"E1"->elem[["E1"]]+elem[["BENDANGLE"]]/2,"E2"->elem[["E2"]]+elem[["BENDANGLE"]]/2}]
]


(* ::Input::Initialization:: *)
SetAttributes[csrcsbend,HoldAll];
csrcsbend[name_,length_,strength_,angle_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"CSRCSBend","LENGTH"->length,"K1"->strength,"BENDANGLE"->angle,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[drift,HoldAll];
drift[name_,length_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"EDrift","LENGTH"->length,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[marker,HoldAll];
marker[name_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Mark","NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[bpm,HoldAll];
bpm[in__]:=monitor[in]


(* ::Input::Initialization:: *)
SetAttributes[vbpm,HoldAll];
vbpm[in__]:=vmonitor[in]


(* ::Input::Initialization:: *)
SetAttributes[hbpm,HoldAll];
hbpm[in__]:=hmonitor[in]


(* ::Input::Initialization:: *)
SetAttributes[vmonitor,HoldAll];
vmonitor[name_,length_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"VMon","LENGTH"->length,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[hmonitor,HoldAll];
hmonitor[name_,length_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"HMon","LENGTH"->length,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[monitor,HoldAll];
monitor[name_,length_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Monitor","LENGTH"->length,"CO_FITPOINT"->0,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[hkick,HoldAll];
hkick[name_,length_,kick_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"HKicker","LENGTH"->length,"KICK"->kick,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[vkick,HoldAll];
vkick[name_,length_,kick_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"VKicker","LENGTH"->length,"KICK"->kick,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[kick,HoldAll];
kick[name_,length_,hkick_,vkick_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Kicker","LENGTH"->length,"KICK"->hkick,"VKICK"->vkick,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[lcav,HoldAll];
lcav[in__]:=Block[{elem},
elem=rfca[in];
SetProperty[elem,{"PHASE"->elem[["CAVITYPHASE"]]*360+90,"VOLT"->elem[["VOLTAGEGAIN"]]*10^6,"FREQ"->elem[["FREQUENCY"]]*10^6,"CAVITYPHASE"->Null,"VOLTAGEGAIN"->Null,"FREQUENCY"->Null}]
]


(* ::Input::Initialization:: *)
SetAttributes[rfca,HoldAll];
rfca[name_,length_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"RFCA","LENGTH"->length,"NAME"->convertNames[ToString[HoldForm[name]]],"LABEL"->If[label=="",Null,label],Sequence@@replaceRuleNames[{extra}]]
]


(* ::Input::Initialization:: *)
SetAttributes[profile,HoldAll];
profile[name_,length_,label_String:"",extra___Rule]:=monitor[name,length,label,extra]


(* ::Input::Initialization:: *)
wrapString[inputstring_String]:=Block[{splitstring=StringSplit[inputstring,"\n"],stringpos,wrappedstrings},
wrappedstrings=Block[{string=#,string2=""},
If[StringLength[string]>80,
stringpos:=Last[Select[StringPosition[string,","][[All,1]],#<80&]];
While[StringLength[string]>80,string2=StringJoin[string2,StringTake[string,stringpos]<>"&\n"];string=StringDrop[string,stringpos]];
string2=StringJoin[string2,string],
string2=string;
string2];
string2<>"\n"
]&/@splitstring;
StringJoin@@wrappedstrings
]


(* ::Input::Initialization:: *)
MADRules["SectorBend"]={"TYPE"->"sbend","LENGTH"->"L","K1","BENDANGLE"->"angle","LABEL"->"Type","E1","E2"}


(* ::Input::Initialization:: *)
MADRules["Quadrupole"]={"LENGTH"->"L","K1","LABEL"->"TYPE"}


(* ::Input::Initialization:: *)
MADRules["Drift"]={"LENGTH"->"L","LABEL"->"TYPE"}


(* ::Input::Initialization:: *)
ElegantRules["ALPH"]={"XMAX", "XS1", "XS2", "DP1", "DP2", "XPUCK", "WIDTHPUCK", "DX", "DY", "DZ", "TILT", "PART", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["BGGEXP"]={"LFIELD", "FILENAME", "STRENGTH", "TILT", "DX", "DY", "DZ", "MAXIMUM_M", "MAXIMUM_2N", "Z_INTERVAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["BMAPXY"]={"STRENGTH", "ACCURACY", "METHOD", "FILENAME", "FX", "FY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["BMXYZ"]={"LFIELD", "STRENGTH", "ACCURACY", "METHOD", "FILENAME", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["BRAT"]={"ANGLE", "FSE", "ACCURACY", "METHOD", "FILENAME", "XVERTEX", "ZVERTEX", "XENTRY", "ZENTRY", "XEXIT", "ZEXIT", "DXMAP", "DZMAP", "YAWMAP", "FACTOR", "USE_FTABLE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["BUMPER"]={"ANGLE", "TILT", "DX", "DY", "DZ", "B2", "TIME_OFFSET", "PERIODIC", "PHASE_REFERENCE", "FIRE_ON_PASS", "N_KICKS", "WAVEFORM", "DEFLECTION_MAP", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["CENTER"]={"X", "XP", "Y", "YP", "S", "DELTA", "T", "ONCE_ONLY", "ON_PASS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["CEPL"]={"RAMP_TIME", "TIME_OFFSET", "VOLTAGE", "GAP", "STATIC_VOLTAGE", "TILT", "ACCURACY", "X_MAX", "Y_MAX", "DX", "DY", "PHASE_REFERENCE", "N_STEPS", "METHOD", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["CHARGE"]={"TOTAL", "PER_PARTICLE", "ALLOW_TOTAL_CHANGE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["CLEAN"]={"MODE", "XLIMIT", "XPLIMIT", "YLIMIT", "YPLIMIT", "TLIMIT", "DELTALIMIT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["CORGPIPE"]={"RADIUS", "PERIOD", "GAP", "DEPTH", "DT", "TMAX", "N_BINS", "INTERPOLATE", "SMOOTHING", "SG_HALFWIDTH", "SG_ORDER", "CHANGE_P0", "ALLOW_LONG_BEAM", "RAMP_PASSES", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["CSBEND"]={"ANGLE", "K1", "K2", "K3", "K4", "K5", "K6", "K7", "K8", "E1", "E2", "TILT", "H1", "H2", "HGAP", "FINT", "DX", "DY", "DZ", "FSE", "ETILT", "N_KICKS", "NONLINEAR", "SYNCH_RAD", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "EDGE_ORDER", "FRINGE", "INTEGRATION_ORDER", "EDGE1_KICK_LIMIT", "EDGE2_KICK_LIMIT", "KICK_LIMIT_SCALING", "USE_BN", "EXPANSION_ORDER", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "XREFERENCE", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "ISR", "ISR1PART", "SQRT_ORDER", "USE_RAD_DIST", "ADD_OPENING_ANGLE", "PHOTON_OUTPUT_FILE", "PHOTON_LOW_ENERGY_CUTOFF", "REFERENCE_CORRECTION", "TRACKING_MATRIX", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["CSRCSBEND"]={"ANGLE", "K1", "K2", "K3", "K4", "K5", "K6", "K7", "K8", "E1", "E2", "TILT", "H1", "H2", "HGAP", "FINT", "DX", "DY", "DZ", "FSE", "ETILT", "N_KICKS", "NONLINEAR", "LINEARIZE", "SYNCH_RAD", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "EDGE_ORDER", "INTEGRATION_ORDER", "BINS", "BIN_ONCE", "BIN_RANGE_FACTOR", "SG_HALFWIDTH", "SG_ORDER", "SGDERIV_HALFWIDTH", "SGDERIV_ORDER", "TRAPAZOID_INTEGRATION", "OUTPUT_FILE", "OUTPUT_INTERVAL", "OUTPUT_LAST_WAKE_ONLY", "STEADY_STATE", "IGF", "USE_BN", "EXPANSION_ORDER", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "ISR", "ISR1PART", "CSR", "BLOCK_CSR", "DERBENEV_CRITERION_MODE", "PARTICLE_OUTPUT_FILE", "PARTICLE_OUTPUT_INTERVAL", "SLICE_ANALYSIS_INTERVAL", "LOW_FREQUENCY_CUTOFF0", "LOW_FREQUENCY_CUTOFF1", "HIGH_FREQUENCY_CUTOFF0", "HIGH_FREQUENCY_CUTOFF1", "CLIP_NEGATIVE_BINS", "WAKE_FILTER_FILE", "WFF_FREQ_COLUMN", "WFF_REAL_COLUMN", "WFF_IMAG_COLUMN", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["CSRDRIFT"]={"ATTENUATION_LENGTH", "DZ", "N_KICKS", "SPREAD", "USE_OVERTAKING_LENGTH", "OL_MULTIPLIER", "USE_SALDIN54", "SALDIN54POINTS", "CSR", "SALDIN54NORM_MODE", "SPREAD_MODE", "WAVELENGTH_MODE", "BUNCHLENGTH_MODE", "SALDIN54_OUTPUT", "USE_STUPAKOV", "STUPAKOV_OUTPUT", "STUPAKOV_OUTPUT_INTERVAL", "SLICE_ANALYSIS_INTERVAL", "LINEARIZE", "LSC_BINS", "LSC_INTERPOLATE", "LSC_LOW_FREQUENCY_CUTOFF0", "LSC_LOW_FREQUENCY_CUTOFF1", "LSC_HIGH_FREQUENCY_CUTOFF0", "LSC_HIGH_FREQUENCY_CUTOFF1", "LSC_RADIUS_FACTOR", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["CWIGGLER"]={"B_MAX", "BX_MAX", "BY_MAX", "DX", "DY", "DZ", "TILT", "PERIODS", "STEPS_PER_PERIOD", "INTEGRATION_ORDER", "BY_FILE", "BX_FILE", "BY_SPLIT_POLE", "BX_SPLIT_POLE", "SYNCH_RAD", "ISR", "ISR1PART", "SINUSOIDAL", "VERTICAL", "HELICAL", "FORCE_MATCHED", "FIELD_OUTPUT", "VERBOSITY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["DRIF"]={"ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["DSCATTER"]={"PLANE", "FILENAME", "VALUENAME", "CDFNAME", "PDFNAME", "ONCEPERPARTICLE", "FACTOR", "PROBABILITY", "GROUPID", "RANDOMSIGN", "LIMITPERPASS", "LIMITTOTAL", "STARTONPASS", "ENDONPASS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["ECOL"]={"X_MAX", "Y_MAX", "DX", "DY", "OPEN_SIDE", "EXPONENT", "YEXPONENT", "INVERT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["ECOLLIMATOR"]:=ElegantRules["ECOL"]


(* ::Input::Initialization:: *)
ElegantRules["EDRIFT"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["EHKICK"]={"KICK", "TILT", "CALIBRATION", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["EKICKER"]={"HKICK", "VKICK", "TILT", "HCALIBRATION", "VCALIBRATION", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["ELSE"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["EMATRIX"]={"ANGLE", "DX", "DY", "DZ", "TILT", "YAW", "PITCH", "ORDER", "C1", "C2", "C3", "C4", "C5", "C6", "DELTAP", "R11", "R12", "R13", "R14", "R15", "R16", "R21", "R22", "R23", "R24", "R25", "R26", "R31", "R32", "R33", "R34", "R35", "R36", "R41", "R42", "R43", "R44", "R45", "R46", "R51", "R52", "R53", "R54", "R55", "R56", "R61", "R62", "R63", "R64", "R65", "R66", "T111", "T121", "T122", "T131", "T132", "T133", "T141", "T142", "T143", "T144", "T151", "T152", "T153", "T154", "T155", "T161", "T162", "T163", "T164", "T165", "T166", "T211", "T221", "T222", "T231", "T232", "T233", "T241", "T242", "T243", "T244", "T251", "T252", "T253", "T254", "T255", "T261", "T262", "T263", "T264", "T265", "T266", "T311", "T321", "T322", "T331", "T332", "T333", "T341", "T342", "T343", "T344", "T351", "T352", "T353", "T354", "T355", "T361", "T362", "T363", "T364", "T365", "T366", "T411", "T421", "T422", "T431", "T432", "T433", "T441", "T442", "T443", "T444", "T451", "T452", "T453", "T454", "T455", "T461", "T462", "T463", "T464", "T465", "T466", "T511", "T521", "T522", "T531", "T532", "T533", "T541", "T542", "T543", "T544", "T551", "T552", "T553", "T554", "T555", "T561", "T562", "T563", "T564", "T565", "T566", "T611", "T621", "T622", "T631", "T632", "T633", "T641", "T642", "T643", "T644", "T651", "T652", "T653", "T654", "T655", "T661", "T662", "T663", "T664", "T665", "T666", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["EMITTANCE"]={"EMITX", "EMITY", "EMITNX", "EMITNY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["ENERGY"]={"CENTRAL_ENERGY", "CENTRAL_MOMENTUM", "MATCH_BEAMLINE", "MATCH_PARTICLES", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["EVKICK"]={"KICK", "TILT", "CALIBRATION", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["FLOOR"]={"X", "Y", "Z", "THETA", "PHI", "PSI", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["FMULT"]={"TILT", "DX", "DY", "DZ", "FSE", "N_KICKS", "SYNCH_RAD", "FILENAME", "SQRT_ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["FRFMODE"]={"FILENAME", "BIN_SIZE", "N_BINS", "RIGID_UNTIL_PASS", "USE_SYMM_DATA", "FACTOR", "CUTOFF", "OUTPUT_FILE", "FLUSH_INTERVAL", "RAMP_PASSES", "RESET_FOR_EACH_STEP", "LONG_RANGE_ONLY", "N_CAVITIES", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["FTABLE"]={"ANGLE", "L1", "L2", "E1", "E2", "TILT", "DX", "DY", "DZ", "FACTOR", "THRESHOLD", "INPUT_FILE", "N_KICKS", "VERBOSE", "SIMPLE_INPUT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["FTRFMODE"]={"FILENAME", "BIN_SIZE", "N_BINS", "RIGID_UNTIL_PASS", "USE_SYMM_DATA", "DX", "DY", "XFACTOR", "YFACTOR", "CUTOFF", "OUTPUT_FILE", "FLUSH_INTERVAL", "RAMP_PASSES", "RESET_FOR_EACH_STEP", "LONG_RANGE_ONLY", "N_CAVITIES", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["GFWIGGLER"]={"B_MAX", "SHIM_SCALE", "DX", "DY", "DZ", "TILT", "PERIODS", "STEP", "ORDER", "END_POLE", "SHIM_ON", "INPUT_FILE", "SHIM_INPUT", "SYNCH_RAD", "ISR", "ISR1PART", "X0", "GAP0", "D_GAP", "PHASE_1", "PHASE_2", "PHASE_3", "PHASE_4", "VERBOSITY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["HISTOGRAM"]={"INTERVAL", "START_PASS", "BINS", "FIXED_BIN_SIZE", "X_DATA", "Y_DATA", "LONGIT_DATA", "BIN_SIZE_FACTOR", "NORMALIZE", "DISABLE", "SPARSE", "START_PID", "END_PID", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["HKICK"]={"KICK", "TILT", "B2", "CALIBRATION", "EDGE_EFFECTS", "ORDER", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["HMON"]={"DX", "DY", "WEIGHT", "TILT", "CALIBRATION", "SETPOINT", "ORDER", "READOUT", "CO_FITPOINT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["IBSCATTER"]={"FACTOR", "DO_X", "DO_Y", "DO_Z", "NSLICE", "SMOOTH", "FORCE_MATCHED_TWISS", "ISRING", "INTERVAL", "FILENAME", "BUNCHED_BEAM_MODE", "VERBOSE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["ILMATRIX"]={"NUX", "NUY", "NUX1M", "NUY1M", "NUX2M", "NUY2M", "NUX3M", "NUY3M", "NUX1AX", "NUY1AX", "NUX1AY", "NUY1AY", "NUX2AX", "NUY2AX", "NUX2AY", "NUY2AY", "NUX1AX1AY", "NUY1AX1AY", "BETAX", "BETAY", "BETAX1M", "BETAY1M", "ALPHAX", "ALPHAY", "ALPHAX1M", "ALPHAY1M", "ETAX", "ETAPX", "ETAY", "ETAPY", "ETAX1", "ETAPX1", "ETAY1", "ETAPY1", "ALPHAC", "ALPHAC2", "ALPHAC3", "DS1AX", "DS1AY", "DS2AX", "DS2AY", "DS1AX1AY", "TILT", "CROSS_RESONANCE", "VERBOSITY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["KICKER"]={"HKICK", "VKICK", "TILT", "B2", "HCALIBRATION", "VCALIBRATION", "EDGE_EFFECTS", "ORDER", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["KOCT"]={"K3", "TILT", "BORE", "B", "DX", "DY", "DZ", "FSE", "N_KICKS", "SYNCH_RAD", "SYSTEMATIC_MULTIPOLES", "RANDOM_MULTIPOLES", "INTEGRATION_ORDER", "SQRT_ORDER", "ISR", "ISR1PART", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["KPOLY"]={"COEFFICIENT", "TILT", "DX", "DY", "DZ", "FACTOR", "ORDER", "PLANE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["KQUAD"]={"K1", "TILT", "BORE", "B", "DX", "DY", "DZ", "FSE", "HKICK", "VKICK", "HCALIBRATION", "VCALIBRATION", "HSTEERING", "VSTEERING", "N_KICKS", "SYNCH_RAD", "SYSTEMATIC_MULTIPOLES", "EDGE_MULTIPOLES", "RANDOM_MULTIPOLES", "STEERING_MULTIPOLES", "INTEGRATION_ORDER", "SQRT_ORDER", "ISR", "ISR1PART", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "LEFFECTIVE", "I0P", "I1P", "I2P", "I3P", "LAMBDA2P", "I0M", "I1M", "I2M", "I3M", "LAMBDA2M", "EDGE1_LINEAR", "EDGE2_LINEAR", "EDGE1_NONLINEAR_FACTOR", "EDGE2_NONLINEAR_FACTOR", "RADIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["KQUSE"]={"K1", "K2", "TILT", "DX", "DY", "DZ", "FSE1", "FSE2", "N_KICKS", "SYNCH_RAD", "INTEGRATION_ORDER", "ISR", "ISR1PART", "MATRIX_TRACKING", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["KSBEND"]={"ANGLE", "K1", "K2", "K3", "K4", "E1", "E2", "TILT", "H1", "H2", "HGAP", "FINT", "DX", "DY", "DZ", "FSE", "ETILT", "N_KICKS", "NONLINEAR", "SYNCH_RAD", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "EDGE_ORDER", "PARAXIAL", "TRANSPORT", "METHOD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["KSEXT"]={"K2", "TILT", "BORE", "B", "DX", "DY", "DZ", "FSE", "HKICK", "VKICK", "HCALIBRATION", "VCALIBRATION", "HSTEERING", "VSTEERING", "N_KICKS", "SYNCH_RAD", "SYSTEMATIC_MULTIPOLES", "EDGE_MULTIPOLES", "RANDOM_MULTIPOLES", "STEERING_MULTIPOLES", "INTEGRATION_ORDER", "SQRT_ORDER", "ISR", "ISR1PART", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["LMIRROR"]={"RX", "RY", "THETA", "DX", "DY", "DZ", "TILT", "YAW", "PITCH", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["LRWAKE"]={"INPUTFILE", "TCOLUMN", "WXCOLUMN", "WYCOLUMN", "WZCOLUMN", "QXCOLUMN", "QYCOLUMN", "FACTOR", "XFACTOR", "YFACTOR", "ZFACTOR", "QXFACTOR", "QYFACTOR", "TURNS_TO_KEEP", "RAMP_PASSES", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["LSCDRIFT"]={"LEFFECTIVE", "BINS", "SMOOTHING", "SG_HALFWIDTH", "SG_ORDER", "INTERPOLATE", "LOW_FREQUENCY_CUTOFF0", "LOW_FREQUENCY_CUTOFF1", "HIGH_FREQUENCY_CUTOFF0", "HIGH_FREQUENCY_CUTOFF1", "RADIUS_FACTOR", "LSC", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["LSRMDLTR"]={"BU", "PERIODS", "METHOD", "FIELD_EXPANSION", "ACCURACY", "N_STEPS", "POLE_FACTOR1", "POLE_FACTOR2", "POLE_FACTOR3", "LASER_WAVELENGTH", "LASER_PEAK_POWER", "LASER_W0", "LASER_PHASE", "LASER_X0", "LASER_Y0", "LASER_Z0", "LASER_TILT", "LASER_M", "LASER_N", "SYNCH_RAD", "ISR", "TIME_PROFILE", "TIME_OFFSET", "HELICAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["LTHINLENS"]={"FX", "FY", "DX", "DY", "DZ", "TILT", "YAW", "PITCH", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MAGNIFY"]={"MX", "MXP", "MY", "MYP", "MS", "MDP", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MALIGN"]={"DXP", "DYP", "DX", "DY", "DZ", "DT", "DP", "DE", "ON_PASS", "FORCE_MODIFY_MATRIX", "START_PID", "END_PID", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MAPSOLENOID"]={"DX", "DY", "ETILT", "EYAW", "EPITCH", "N_STEPS", "INPUTFILE", "RCOLUMN", "ZCOLUMN", "BRCOLUMN", "BZCOLUMN", "FACTOR", "BXUNIFORM", "BYUNIFORM", "LUNIFORM", "ACCURACY", "METHOD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MARK"]={"DX", "DY", "FITPOINT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MATR"]={"ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MATTER"]={"LEFFECTIVE", "XO", "ENERGY_DECAY", "ENERGY_STRAGGLE", "NUCLEAR_BREMSSTRAHLUNG", "ELECTRON_RECOIL", "Z", "A", "RHO", "PLIMIT", "WIDTH", "SPACING", "TILT", "CENTER", "N_SLOTS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MAXAMP"]={"X_MAX", "Y_MAX", "ELLIPTICAL", "EXPONENT", "YEXPONENT", "OPEN_SIDE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MBUMPER"]={"STRENGTH", "TILT", "DX", "DY", "DZ", "TIME_OFFSET", "ORDER", "PERIODIC", "PHASE_REFERENCE", "FIRE_ON_PASS", "N_KICKS", "WAVEFORM", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MHISTOGRAM"]={"FILE1D", "FILE2DH", "FILE2DV", "FILE2DL", "FILE4D", "FILE6D", "INPUT_BINS", "INTERVAL", "START_PASS", "NORMALIZE", "DISABLE", "LUMPED", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MODRF"]={"VOLT", "PHASE", "FREQ", "Q", "PHASE_REFERENCE", "AMMAG", "AMPHASE", "AMFREQ", "AMDECAY", "PMMAG", "PMPHASE", "PMFREQ", "PMDECAY", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MONI"]={"DX", "DY", "WEIGHT", "TILT", "XCALIBRATION", "YCALIBRATION", "XSETPOINT", "YSETPOINT", "ORDER", "XREADOUT", "YREADOUT", "CO_FITPOINT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MRFDF"]={"FACTOR", "TILT", "A1", "A2", "A3", "A4", "A5", "B1", "B2", "B3", "B4", "B5", "FREQUENCY1", "FREQUENCY2", "FREQUENCY3", "FREQUENCY4", "FREQUENCY5", "PHASE1", "PHASE2", "PHASE3", "PHASE4", "PHASE5", "PHASE_REFERENCE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["MULT"]={"KNL", "TILT", "BORE", "BTIPL", "DX", "DY", "DZ", "FACTOR", "ORDER", "N_KICKS", "SYNCH_RAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["NIBEND"]={"ANGLE", "E1", "E2", "TILT", "DX", "DY", "DZ", "FINT", "HGAP", "FP1", "FP2", "FP3", "FP4", "FSE", "ETILT", "ACCURACY", "MODEL", "METHOD", "SYNCH_RAD", "ADJUST_BOUNDARY", "ADJUST_FIELD", "FUDGE_PATH_LENGTH", "FRINGE_POSITION", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["NISEPT"]={"ANGLE", "E1", "B1", "Q1REF", "FLEN", "ACCURACY", "METHOD", "MODEL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["OCTU"]={"K3", "TILT", "DX", "DY", "DZ", "FSE", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["PEPPOT"]={"RADII", "TRANSMISSION", "TILT", "THETA_RMS", "N_HOLES", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["PFILTER"]={"DELTALIMIT", "LOWERFRACTION", "UPPERFRACTION", "FIXPLIMITS", "BEAMCENTERED", "BINS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["QUAD"]={"K1", "TILT", "DX", "DY", "DZ", "FSE", "HKICK", "VKICK", "HCALIBRATION", "VCALIBRATION", "HSTEERING", "VSTEERING", "ORDER", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "FRINGE_TYPE", "FFRINGE", "LEFFECTIVE", "I0P", "I1P", "I2P", "I3P", "LAMBDA2P", "I0M", "I1M", "I2M", "I3M", "LAMBDA2M", "RADIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["QUFRINGE"]={"K1", "TILT", "DX", "DY", "DZ", "FSE", "DIRECTION", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RAMPP"]={"WAVEFORM", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RAMPRF"]={"VOLT", "PHASE", "FREQ", "PHASE_REFERENCE", "VOLT_WAVEFORM", "PHASE_WAVEFORM", "FREQ_WAVEFORM", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RBEN"]={"ANGLE", "K1", "E1", "E2", "TILT", "K2", "H1", "H2", "HGAP", "FINT", "DX", "DY", "DZ", "FSE", "ETILT", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "ORDER", "EDGE_ORDER", "TRANSPORT", "USE_BN", "B1", "B2", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RCOL"]={"X_MAX", "Y_MAX", "DX", "DY", "OPEN_SIDE", "INVERT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RECIRC"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["REFLECT"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["REMCOR"]={"X", "XP", "Y", "YP", "WITH", "ONCE_ONLY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RFCA"]={"VOLT", "PHASE", "FREQ", "Q", "PHASE_REFERENCE", "CHANGE_P0", "CHANGE_T", "FIDUCIAL", "END1_FOCUS", "END2_FOCUS", "BODY_FOCUS_MODEL", "N_KICKS", "DX", "DY", "T_REFERENCE", "LINEARIZE", "LOCK_PHASE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RFCW"]={"CELL_LENGTH", "VOLT", "PHASE", "FREQ", "Q", "PHASE_REFERENCE", "CHANGE_P0", "CHANGE_T", "FIDUCIAL", "END1_FOCUS", "END2_FOCUS", "BODY_FOCUS_MODEL", "N_KICKS", "ZWAKE", "TRWAKE", "WAKEFILE", "ZWAKEFILE", "TRWAKEFILE", "TCOLUMN", "WXCOLUMN", "WYCOLUMN", "WZCOLUMN", "N_BINS", "INTERPOLATE", "SMOOTHING", "SG_HALFWIDTH", "SG_ORDER", "DX", "DY", "LINEARIZE", "LSC", "LSC_BINS", "LSC_INTERPOLATE", "LSC_LOW_FREQUENCY_CUTOFF0", "LSC_LOW_FREQUENCY_CUTOFF1", "LSC_HIGH_FREQUENCY_CUTOFF0", "LSC_HIGH_FREQUENCY_CUTOFF1", "LSC_RADIUS_FACTOR", "WAKES_AT_END", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RFDF"]={"PHASE", "TILT", "FREQUENCY", "VOLTAGE", "FSE", "B2", "TIME_OFFSET", "N_KICKS", "PHASE_REFERENCE", "STANDING_WAVE", "VOLTAGE_WAVEFORM", "VOLTAGE_PERIODIC", "ALIGN_WAVEFORMS", "VOLTAGE_NOISE", "PHASE_NOISE", "GROUP_VOLTAGE_NOISE", "GROUP_PHASE_NOISE", "VOLTAGE_NOISE_GROUP", "PHASE_NOISE_GROUP", "START_PASS", "END_PASS", "DRIFT_MATRIX", "DX", "DY", "DZ", "MAGNETIC_DEFLECTION", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RFMODE"]={"RA", "RS", "Q", "FREQ", "CHARGE", "INITIAL_V", "INITIAL_PHASE", "INITIAL_T", "BETA", "BIN_SIZE", "N_BINS", "INTERPOLATE", "PRELOAD", "PRELOAD_CHARGE", "PRELOAD_FACTOR", "PRELOAD_HARMONIC", "RIGID_UNTIL_PASS", "DETUNED_UNTIL_PASS", "SAMPLE_INTERVAL", "FLUSH_INTERVAL", "RECORD", "SINGLE_PASS", "PASS_INTERVAL", "FREQ_WAVEFORM", "Q_WAVEFORM", "RAMP_PASSES", "BINLESS", "RESET_FOR_EACH_STEP", "LONG_RANGE_ONLY", "N_CAVITIES", "BUNCHED_BEAM_MODE", "BUNCH_INTERVAL", "DRIVE_FREQUENCY", "V_SETPOINT", "PHASE_SETPOINT", "UPDATE_INTERVAL", "AMPLITUDE_FILTER", "PHASE_FILTER", "IN_PHASE_FILTER", "QUADRATURE_FILTER", "FEEDBACK_RECORD", "MUTE_GENERATOR", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RFTM110"]={"PHASE", "TILT", "FREQUENCY", "VOLTAGE", "PHASE_REFERENCE", "VOLTAGE_WAVEFORM", "VOLTAGE_PERIODIC", "ALIGN_WAVEFORMS", "VOLTAGE_NOISE", "PHASE_NOISE", "GROUP_VOLTAGE_NOISE", "GROUP_PHASE_NOISE", "VOLTAGE_NOISE_GROUP", "PHASE_NOISE_GROUP", "START_PASS", "END_PASS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RFTMEZ0"]={"FREQUENCY", "PHASE", "EZ_PEAK", "TIME_OFFSET", "PHASE_REFERENCE", "DX", "DY", "DZ", "ETILT", "EYAW", "EPITCH", "N_STEPS", "RADIAL_ORDER", "CHANGE_P0", "INPUTFILE", "ZCOLUMN", "EZCOLUMN", "SOLENOID_FILE", "SOLENOID_ZCOLUMN", "SOLENOID_RCOLUMN", "SOLENOID_BZCOLUMN", "SOLENOID_BRCOLUMN", "SOLENOID_FACTOR", "SOLENOID_DX", "SOLENOID_DY", "SOLENOID_DZ", "SOLENOID_ETILT", "SOLENOID_EYAW", "SOLENOID_EPITCH", "BX_STRAY", "BY_STRAY", "ACCURACY", "METHOD", "FIDUCIAL", "FIELD_TEST_FILE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RIMULT"]={"FACTOR", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["RMDF"]={"TILT", "RAMP_TIME", "VOLTAGE", "GAP", "TIME_OFFSET", "N_SECTIONS", "PHASE_REFERENCE", "DX", "DY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["ROTATE"]={"TILT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["SAMPLE"]={"FRACTION", "INTERVAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["SBEN"]={"ANGLE", "K1", "E1", "E2", "TILT", "K2", "H1", "H2", "HGAP", "FINT", "DX", "DY", "DZ", "FSE", "ETILT", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "ORDER", "EDGE_ORDER", "TRANSPORT", "USE_BN", "B1", "B2", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["SCATTER"]={"X", "XP", "Y", "YP", "DP", "PROBABILITY", "STARTONPASS", "ENDONPASS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["SCMULT"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["SCRAPER"]={"XO", "ENERGY_DECAY", "ENERGY_STRAGGLE", "NUCLEAR_BREMSSTRAHLUNG", "ELECTRON_RECOIL", "Z", "A", "RHO", "PLIMIT", "POSITION", "DX", "DY", "INSERT_FROM", "DIRECTION", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["SCRIPT"]={"COMMAND", "USE_CSH", "VERBOSITY", "START_PASS", "END_PASS", "PASS_INTERVAL", "ON_PASS", "DIRECTORY", "ROOTNAME", "INPUT_EXTENSION", "OUTPUT_EXTENSION", "KEEP_FILES", "DRIFT_MATRIX", "USE_PARTICLE_ID", "NO_NEW_PARTICLES", "NP0", "NP1", "NP2", "NP3", "NP4", "NP5", "NP6", "NP7", "NP8", "NP9", "SP0", "SP1", "SP2", "SP3", "SP4", "SP5", "SP6", "SP7", "SP8", "SP9", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["SEXT"]={"K2", "TILT", "DX", "DY", "DZ", "FSE", "FFRINGE", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["SOLE"]={"KS", "B", "DX", "DY", "DZ", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["SREFFECTS"]={"JX", "JY", "JDELTA", "EXREF", "EYREF", "SDELTAREF", "DDELTAREF", "PREF", "COUPLING", "FRACTION", "DAMPING", "QEXCITATION", "LOSSES", "CUTOFF", "INCLUDE_OFFSETS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["STRAY"]={"LBX", "LBY", "GBX", "GBY", "GBZ", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TFBDRIVER"]={"ID", "STRENGTH", "KICK_LIMIT", "DELAY", "LONGITUDINAL", "OUTPUT_FILE", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "BUNCHED_BEAM_MODE", "UPDATE_INTERVAL", "OUTPUT_INTERVAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TFBPICKUP"]={"ID", "PLANE", "RMS_NOISE", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "BUNCHED_BEAM_MODE", "UPDATE_INTERVAL", "REFERENCE_FREQUENCY", "DX", "DY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TMCF"]={"FREQUENCY", "PHASE", "TIME_OFFSET", "RADIAL_OFFSET", "TILT", "ER", "BPHI", "EZ", "ACCURACY", "X_MAX", "Y_MAX", "DX", "DY", "PHASE_REFERENCE", "N_STEPS", "METHOD", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TRCOUNT"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TRFMODE"]={"RA", "RS", "Q", "FREQ", "CHARGE", "BETA", "BIN_SIZE", "N_BINS", "INTERPOLATE", "PLANE", "SAMPLE_INTERVAL", "PER_PARTICLE_OUTPUT", "RECORD", "SINGLE_PASS", "RIGID_UNTIL_PASS", "DX", "DY", "XFACTOR", "YFACTOR", "RAMP_PASSES", "BINLESS", "RESET_FOR_EACH_STEP", "LONG_RANGE_ONLY", "N_CAVITIES", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TRWAKE"]={"INPUTFILE", "TCOLUMN", "WXCOLUMN", "WYCOLUMN", "CHARGE", "FACTOR", "XFACTOR", "YFACTOR", "N_BINS", "INTERPOLATE", "SMOOTHING", "SG_HALFWIDTH", "SG_ORDER", "DX", "DY", "TILT", "X_DRIVE_EXPONENT", "Y_DRIVE_EXPONENT", "X_PROBE_EXPONENT", "Y_PROBE_EXPONENT", "RAMP_PASSES", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TSCATTER"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TUBEND"]={"ANGLE", "FSE", "OFFSET", "MAGNET_WIDTH", "MAGNET_ANGLE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TWISS"]={"BETAX", "ALPHAX", "ETAX", "ETAXP", "BETAY", "ALPHAY", "ETAY", "ETAYP", "FROM_BEAM", "FROM_0VALUES", "COMPUTE_ONCE", "APPLY_ONCE", "VERBOSE", "DISABLE", "BETAX0", "ALPHAX0", "ETAX0", "ETAXP0", "BETAY0", "ALPHAY0", "ETAY0", "ETAYP0", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TWLA"]={"FREQUENCY", "PHASE", "TIME_OFFSET", "EZ", "B_SOLENOID", "ACCURACY", "X_MAX", "Y_MAX", "DX", "DY", "BETA_WAVE", "ALPHA", "PHASE_REFERENCE", "N_STEPS", "FOCUSSING", "METHOD", "FIDUCIAL", "CHANGE_P0", "SUM_BN2", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TWMTA"]={"FREQUENCY", "PHASE", "EZ", "ACCURACY", "X_MAX", "Y_MAX", "DX", "DY", "KX", "BETA_WAVE", "BSOL", "ALPHA", "PHASE_REFERENCE", "N_STEPS", "METHOD", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["TWPL"]={"RAMP_TIME", "TIME_OFFSET", "VOLTAGE", "GAP", "STATIC_VOLTAGE", "TILT", "ACCURACY", "X_MAX", "Y_MAX", "DX", "DY", "PHASE_REFERENCE", "N_STEPS", "METHOD", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["UKICKMAP"]={"TILT", "DX", "DY", "DZ", "FIELD_FACTOR", "XY_FACTOR", "INPUT_FILE", "N_KICKS", "PERIODS", "KREF", "SYNCH_RAD", "ISR", "GROUP", "x \[LongDash] Horizontal position in meters.","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["VKICK"]={"KICK", "TILT", "B2", "CALIBRATION", "EDGE_EFFECTS", "ORDER", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["VMON"]={"DX", "DY", "WEIGHT", "TILT", "CALIBRATION", "SETPOINT", "ORDER", "READOUT", "CO_FITPOINT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["WAKE"]={"INPUTFILE", "TCOLUMN", "WCOLUMN", "CHARGE", "FACTOR", "N_BINS", "INTERPOLATE", "SMOOTHING", "SG_HALFWIDTH", "SG_ORDER", "CHANGE_P0", "ALLOW_LONG_BEAM", "RAMP_PASSES", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["WATCH"]={"FRACTION", "START_PID", "END_PID", "INTERVAL", "START_PASS", "END_PASS", "FILENAME", "LABEL", "MODE", "X_DATA", "Y_DATA", "LONGIT_DATA", "EXCLUDE_SLOPES", "FLUSH_INTERVAL", "DISABLE", "USE_DISCONNECT", "INDEX_OFFSET", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["WIGGLER"]={"RADIUS", "K", "B", "DX", "DY", "DZ", "TILT", "POLES", "FOCUSING", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["ZLONGIT"]={"CHARGE", "BROAD_BAND", "RA", "RS", "Q", "FREQ", "ZREAL", "ZIMAG", "BIN_SIZE", "N_BINS", "MAX_N_BINS", "WAKES", "WAKE_INTERVAL", "WAKE_START", "WAKE_END", "AREA_WEIGHT", "INTERPOLATE", "SMOOTHING", "SG_ORDER", "SG_HALFWIDTH", "REVERSE_TIME_ORDER", "FACTOR", "START_ON_PASS", "RAMP_PASSES", "HIGH_FREQUENCY_CUTOFF0", "HIGH_FREQUENCY_CUTOFF1", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["ZTRANSVERSE"]={"CHARGE", "BROAD_BAND", "RS", "Q", "FREQ", "INPUTFILE", "FREQCOLUMN", "ZXREAL", "ZXIMAG", "ZYREAL", "ZYIMAG", "BIN_SIZE", "INTERPOLATE", "N_BINS", "MAX_N_BINS", "SMOOTHING", "SG_ORDER", "SG_HALFWIDTH", "DX", "DY", "FACTOR", "XFACTOR", "YFACTOR", "WAKES", "WAKE_INTERVAL", "WAKE_START", "WAKE_END", "START_ON_PASS", "RAMP_PASSES", "HIGH_FREQUENCY_CUTOFF0", "HIGH_FREQUENCY_CUTOFF1", "X_DRIVE_EXPONENT", "Y_DRIVE_EXPONENT", "X_PROBE_EXPONENT", "Y_PROBE_EXPONENT", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


(* ::Input::Initialization:: *)
ElegantRules["SECTORBEND"]={"TYPE"->"SBEN","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE","K1","E1","E2","TILT","K2","H1","H2","HGAP","FINT","DX","DY","DZ","FSE","ETILT","EDGE1_EFFECTS","EDGE2_EFFECTS","ORDER","EDGE_ORDER","TRANSPORT","USE_BN","B1","B2","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["CSBEND"]={"TYPE"->"CSBEN","LENGTH"->"L","L","BENDANGLE"->"ANGLE","ANGLE","K1","K2","K3","K4","K5","K6","K7","K8","E1","E2","TILT","H1","H2","HGAP","FINT","DX","DY","DZ","FSE","ETILT","N_KICKS","NONLINEAR","SYNCH_RAD","EDGE1_EFFECTS","EDGE2_EFFECTS","EDGE_ORDER","FRINGE","INTEGRATION_ORDER","EDGE1_KICK_LIMIT","EDGE2_KICK_LIMIT","KICK_LIMIT_SCALING","USE_BN","EXPANSION_ORDER","B1","B2","B3","B4","B5","B6","B7","B8","XREFERENCE","F1","F2","F3","F4","F5","F6","F7","F8","ISR","ISR1PART","SQRT_ORDER","USE_RAD_DIST","ADD_OPENING_ANGLE","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["CSRCSBEND"]={"TYPE"->"CSRCSBEND","LENGTH"->"L","L","BENDANGLE"->"ANGLE","ANGLE","K1","K2","K3","K4","K5","K6","K7","K8","E1","E2","TILT","H1","H2","HGAP","FINT","DX","DY","DZ","FSE","ETILT","N_KICKS","NONLINEAR","LINEARIZE","SYNCH_RAD","EDGE1_EFFECTS","EDGE2_EFFECTS","EDGE_ORDER","INTEGRATION_ORDER","BINS","BIN_ONCE","BIN_RANGE_FACTOR","SG_HALFWIDTH","SG_ORDER","SGDERIV_HALFWIDTH","SGDERIV_ORDER","TRAPAZOID_INTEGRATION","OUTPUT_FILE","OUTPUT_INTERVAL","OUTPUT_LAST_WAKE_ONLY","STEADY_STATE","IGF","USE_BN","EXPANSION_ORDER","B1","B2","B3","B4","B5","B6","B7","B8","ISR","ISR1PART","CSR","BLOCK_CSR","DERBENEV_CRITERION_MODE","PARTICLE_OUTPUT_FILE","PARTICLE_OUTPUT_INTERVAL","SLICE_ANALYSIS_INTERVAL","LOW_FREQUENCY_CUTOFF0","LOW_FREQUENCY_CUTOFF1","HIGH_FREQUENCY_CUTOFF0","HIGH_FREQUENCY_CUTOFF1","CLIP_NEGATIVE_BINS","WAKE_FILTER_FILE","WFF_FREQ_COLUMN","WFF_REAL_COLUMN","WFF_IMAG_COLUMN","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["KQUAD"]={"TYPE"->"KQUAD","LENGTH"->"L","K1","TILT","BORE","B","DX","DY","DZ","FSE","HKICK","VKICK","HCALIBRATION","VCALIBRATION","HSTEERING","VSTEERING","N_KICKS","SYNCH_RAD","SYSTEMATIC_MULTIPOLES","RANDOM_MULTIPOLES","STEERING_MULTIPOLES","INTEGRATION_ORDER","SQRT_ORDER","ISR","ISR1PART","EDGE1_EFFECTS","EDGE2_EFFECTS","I0P","I1P","I2P","I3P","LAMBDA2P","I0M","I1M","I2M","I3M","LAMBDA2M","RADIAL","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["QUADRUPOLE"]={"TYPE"->"QUAD","LENGTH"->"L","K1","N_KICKS","TILT","DX","DY","DZ","FSE","HKICK","VKICK","HCALIBRATION","VCALIBRATION","HSTEERING","VSTEERING","ORDER","EDGE1_EFFECTS","EDGE2_EFFECTS","FRINGE_TYPE","FFRINGE","I0P","I1P","I2P","I3P","LAMBDA2P","I0M","I1M","I2M","I3M"};


(* ::Input::Initialization:: *)
ElegantRules["SEXTUPOLE"]={"TYPE"->"SEXT","LENGTH"->"L","K1","L","K2","TILT","DX","DY","DZ","FSE","FFRINGE","ORDER","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["KSEXT"]={"TYPE"->"KSEXT","LENGTH"->"L","K1","L","K2","TILT","BORE","B","DX","DY","DZ","FSE","N_KICKS","SYNCH_RAD","SYSTEMATIC_MULTIPOLES","RANDOM_MULTIPOLES","INTEGRATION_ORDER","SQRT_ORDER","ISR","ISR1PART","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["DRIFT"]={"TYPE"->"DRIFT","LENGTH"->"L","L"};


(* ::Input::Initialization:: *)
ElegantRules["EDRIFT"]={"TYPE"->"EDRIFT","LENGTH"->"L","L"};


(* ::Input::Initialization:: *)
ElegantRules["CSRDRIFT"]={"TYPE"->"CSRDRIFT","LENGTH"->"L","L","ATTENUATION_LENGTH","DZ","N_KICKS","SPREAD","USE_OVERTAKING_LENGTH","OL_MULTIPLIER","USE_SALDIN54","SALDIN54POINTS","CSR","SALDIN54NORM_MODE","SPREAD_MODE","WAVELENGTH_MODE","BUNCHLENGTH_MODE","SALDIN54_OUTPUT","USE_STUPAKOV","STUPAKOV_OUTPUT","STUPAKOV_OUTPUT_INTERVAL","SLICE_ANALYSIS_INTERVAL","LINEARIZE","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["MARKER"]={"TYPE"->"MARK","DX","DY","FITPOINT","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["MONITOR"]={"TYPE"->"MONI","LENGTH"->"L","L","DX","DY","WEIGHT","TILT","XCALIBRATION","YCALIBRATION","ORDER","XREADOUT","YREADOUT","CO_FITPOINT","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["HKICKER"]={"TYPE"->"HKICK","LENGTH"->"L","L","KICK","TILT","B2","CALIBRATION","EDGE_EFFECTS","ORDER","STEERING","SYNCH_RAD","ISR","LERAD","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["VKICKER"]={"TYPE"->"VKICK","LENGTH"->"L","L","KICK","TILT","B2","CALIBRATION","EDGE_EFFECTS","ORDER","STEERING","SYNCH_RAD","ISR","LERAD","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["KICKER"]={"TYPE"->"KICKER","LENGTH"->"L","L","HKICK","VKICK","TILT","B2","HCALIBRATION","VCALIBRATION","EDGE_EFFECTS","ORDER","STEERING","SYNCH_RAD","ISR","LERAD","GROUP"};


(* ::Input::Initialization:: *)
ElegantRules["RFCA"]={"TYPE"->"RFCA","LENGTH"->"L","L","VOLT","PHASE","FREQ","Q","PHASE_REFERENCE","CHANGE_P0","CHANGE_T","FIDUCIAL","END1_FOCUS","END2_FOCUS","BODY_FOCUS_MODEL","N_KICKS","DX","DY","T_REFERENCE","LINEARIZE","LOCK_PHASE","GROUP","FREQUENCY"->"FREQ"};


(* ::Input::Initialization:: *)
ElegantRules["PROFILE"]=ElegantRules["MONITOR"];


(* ::Input::Initialization:: *)
ElegantRules["alter_elements"]={"name", "item", "type", "exclude", "value", "string_value", "differential", "multiplicative", "verbose", "allow_missing_elements", "allow_missing_parameters", "start_occurence", "end_occurence", "s_start", "s_end", "before", "after"};


(* ::Input::Initialization:: *)
ElegantRules["amplification_factors"]={"output", "uncorrected_orbit_function", "corrected_orbit_function", "kick_function", "name", "type", "item", "plane", "change", "number_to_do", "maximum_z"};


(* ::Input::Initialization:: *)
ElegantRules["analyze_map"]={"output", "printout", "delta_x", "delta_xp", "delta_y", "delta_yp", "delta_s", "delta_dp", "accuracy_factor", "center_on_orbit", "verbosity", "canonical_variables", "printout_order", "periodic", "beta_x", "alpha_x", "eta_x", "etap_x", "beta_y", "alpha_y", "eta_y", "etap_y"};


(* ::Input::Initialization:: *)
ElegantRules["aperture_data"]={"input", "periodic", "persistent", "disable"};


(* ::Input::Initialization:: *)
ElegantRules["bunched_beam"]={"bunch", "n_particles_per_bunch", "time_start", "matched_to_cell", "emit_x", "emit_nx", "beta_x", "alpha_x", "eta_x", "etap_x", "emit_y", "emit_ny", "beta_y", "alpha_y", "eta_y", "etap_y", "use_twiss_command_values", "po", "sigma_dp", "sigma_s", "dp_s_coupling", "emit_z", "beta_z", "alpha_z", "momentum_chirp", "one_random_bunch", "symmetrize", "optimized_halton", "limit_invariants", "limit_in_4d", "first_is_fiducial", "save_initial_coordinates", "halton_sequence", "halton_radix", "randomize_order", "enforce_rms_values", "distribution_cutoff", "distribution_type", "centroid"};


(* ::Input::Initialization:: *)
ElegantRules["change_particle"]={"name", "mass_ratio", "charge_ratio"};


(* ::Input::Initialization:: *)
ElegantRules["chromaticity"]={"sextupoles", "dnux_dp", "dnuy_dp", "sextupole_tweek", "correction_fraction", "n_iterations", "tolerance", "strength_log", "change_defined_values", "strength_limit", "use_perturbed_matrix", "exit_on_failure", "verbosity", "dK2_weight"};


(* ::Input::Initialization:: *)
ElegantRules["closed_orbit"]={"output", "output_monitors_only", "start_from_centroid", "start_from_dp_centroid", "closed_orbit_accuracy", "closed_orbit_iterations", "iteration_fraction", "fixed_length", "start_from_recirc", "verbosity", "tracking_turns"};


(* ::Input::Initialization:: *)
ElegantRules["correct"]={"mode", "method", "trajectory_output", "corrector_output", "statistics", "verbose", "fixed_length", "fixed_length_matrix", "n_xy_cycles", "minimum_cycles", "n_iterations", "prezero_correctors", "track_before_and_after", "start_from_centroid", "use_actual_beam", "closed_orbit_accuracy", "closed_orbit_iterations", "closed_orbit_iteration_fraction", "closed_orbit_tracking_turns", "use_perturbed_matrix", "disable", "use_response_from_computed_orbits", "corrector_tweek", "corrector_limit", "correction_fraction", "correction_accuracy", "do_correction", "remove_smallest_SVs", "keep_largest_SVs", "minimum_SV_ratio", "auto_limit_SVs", "removed_pegged", "threading_divisor", "threading_correctors", "bpm_noise", "bpm_noise_cutoff", "bpm_noise_distribution"};


(* ::Input::Initialization:: *)
ElegantRules["correction_matrix_output"]={"KnL_units", "BnL_units", "output_at_each_step", "output_before_tune_correction", "fixed_length", "coupled", "use_response_from_computed_orbits", "response", "inverse"};


(* ::Input::Initialization:: *)
ElegantRules["correct_tunes"]={"quadrupoles", "tune_x", "tune_y", "n_iterations", "correction_fraction", "tolerance", "step_up_interval", "max_correction_fraction", "delta_correction_fraction", "strength_log", "change_defined_values", "use_perturbed_matrix", "dK1_weight"};


(* ::Input::Initialization:: *)
ElegantRules["coupled_twiss_output"]={"filename", "output_at_each_step", "emittances_from_twiss_command", "emit_x", "emittance_ratio", "sigma_dp", "calculate_3d_coupling", "verbosity", "concat_order"};


(* ::Input::Initialization:: *)
ElegantRules["divide_elements"]={"name", "type", "exclude", "divisions", "maximum_length", "clear"};


(* ::Input::Initialization:: *)
ElegantRules["error_element"]={"name", "element_type", "item", "type", "amplitude", "cutoff", "bind", "bind_number", "post_correction", "fractional", "additive", "allow_missing_elements", "after", "before"};


(* ::Input::Initialization:: *)
ElegantRules["error_control"]={"clear_error_settings", "summarize_error_settings", "no_errors_for_first_step", "error_log", "error_factor"};


(* ::Input::Initialization:: *)
ElegantRules["find_aperture"]={"output", "search_output", "boundary", "mode", "xmin", "xmax", "ymin", "ymax", "nx", "ny", "n_splits", "split_fraction", "desired_resolution", "assume_nonincreasing", "verbosity", "offset_by_orbit", "n_lines", "optimization_mode"};


(* ::Input::Initialization:: *)
ElegantRules["floor_coordinates"]={"filename", "X0", "Z0", "theta0", "include_vertices", "vertices_only", "magnet_centers", "store_vertices"};


(* ::Input::Initialization:: *)
ElegantRules["frequency_map"]={"output", "xmin", "xmax", "ymin", "ymax", "delta_min", "delta_max", "nx", "ny", "ndelta", "verbosity", "include_changes", "quadratic_spacing", "full_grid_output"};


(* ::Input::Initialization:: *)
ElegantRules["global_settings"]={"inhibit_fsync", "echo_namelists", "SR_gaussian_limit", "log_file", "error_log_file", "mpi_randomization_mode", "exact_normalized_emittance"};


(* ::Input::Initialization:: *)
ElegantRules["insert_elements"]={"name", "type", "exclude", "s_start", "s_end", "skip", "disable", "add_at_end", "add_at_start", "element_def", "total_occurrences", "occurrence"};


(* ::Input::Initialization:: *)
ElegantRules["insert_sceffects"]={"name", "type", "exclude", "disable", "clear", "element_prefix", "skip", "vertical", "horizontal", "nonlinear", "uniform_distribution", "verbosity"};


(* ::Input::Initialization:: *)
ElegantRules["linear_chromatic_tracking_setup"]={"nux", "betax", "alphax", "etax", "etapx", "nuy", "betay", "alphay", "etay", "etapy", "alphac"};


(* ::Input::Initialization:: *)
ElegantRules["link_control"]={"clear_links", "summarize_links", "verbosity"};


(* ::Input::Initialization:: *)
ElegantRules["link_elements"]={"target", "exclude", "item", "source", "source_position", "mode", "equation", "minimium", "maximum", "exclude_self"};


(* ::Input::Initialization:: *)
ElegantRules["load_parameters"]={"filename", "filename_list", "include_name_pattern", "exclude_name_pattern", "include_item_pattern", "exclude_item_pattern", "include_type_pattern", "exclude_type_pattern", "edit_name_command", "change_defined_values", "clear_settings", "allow_missing_elements", "allow_missing_parameters", "allow_missing_files", "force_occurence_data", "verbose", "skip_pages", "use_first"};


(* ::Input::Initialization:: *)
ElegantRules["matrix_output"]={"printout", "printout_order", "full_matrix_only", "SDDS_output", "SDDS_output_order", "individual_matrices", "SDDS_output_match", "output_at_each_step", "start_from", "start_from_occurrence"};


(* ::Input::Initialization:: *)
ElegantRules["modulate_elements"]={"name", "item", "type", "expression", "filename", "time_column", "amplitude_column", "refresh_matrix", "differential", "multiplicative", "start_occurence", "end_occurence", "s_start", "s_end", "before", "after", "verbose", "verbose_threshold", "record", "flush_record"};


(* ::Input::Initialization:: *)
ElegantRules["moments_output"]={"filename", "output_at_each_step", "output_before_tune_correction", "final_values_only", "verbosity", "matched", "equilibrium", "radiation", "n_slices", "slice_etilted", "emit_x", "beta_x", "alpha_x", "eta_x", "etap_x", "emit_y", "beta_y", "alpha_y", "eta_y", "etap_y", "emit_z", "beta_z", "alpha_z"};


(* ::Input::Initialization:: *)
ElegantRules["momentum_aperture"]={"output", "x_initial", "y_initial", "delta_negative_start", "delta_positive_start", "delta_negative_limit", "delta_positive_limit", "delta_step_size", "steps_back", "splits", "split_step_divisor", "skip_elements", "process_elements", "s_start", "s_end", "include_name_pattern", "include_type_pattern", "fiducialize", "verbosity", "soft_failure", "output_mode", "forbid_resonance_crossing"};


(* ::Input::Initialization:: *)
ElegantRules["optimize"]={"summarize_setup"};


(* ::Input::Initialization:: *)
ElegantRules["optimization_constraint"]={"quantity", "lower", "upper"};


(* ::Input::Initialization:: *)
ElegantRules["optimization_covariable"]={"name", "item", "equation", "disable"};


(* ::Input::Initialization:: *)
ElegantRules["optimization_setup"]={"equation", "mode", "method", "tolerance", "target", "center_on_orbit", "center_momentum_also", "soft_failure", "n_passes", "n_evaluations", "n_restarts", "matrix_order", "log_file", "term_log_file", "output_sparsing_factor", "balance_terms", "restart_worst_term_factor", "restart_worst_terms", "verbose", "balance_terms", "simplex_divisor", "simplex_pass_range_factor", "include_simplex_1d_scans", "start_from_simplex_vertex1", "restart_random_numbers", "interrupt_file"};


(* ::Input::Initialization:: *)
ElegantRules["parallel_optimization_setup"]={"method", "random_factor", "n_iterations", "max_no_change", "population_size", "population_log", "print_all_individuals", "output_sparsing_factor", "crossover"};


(* ::Input::Initialization:: *)
ElegantRules["optimization_term"]={"term", "weight", "field_string", "field_initial_value", "field_final_value", "field_interval", "input_file", "input_column", "verbose"};


(* ::Input::Initialization:: *)
ElegantRules["optimization_variable"]={"name", "item", "lower_limit", "upper_limit", "step_size", "disable", "force_inside"};


(* ::Input::Initialization:: *)
ElegantRules["print_dictionary"]={"filename", "SDDS_form"};


(* ::Input::Initialization:: *)
ElegantRules["ramp_elements"]={"name", "item", "type", "start_pass", "end_pass", "start_value", "end_value", "differential", "multiplicative", "start_occurence", "end_occurence", "exponent", "s_start", "s_end", "before", "after", "verbose", "record"};


(* ::Input::Initialization:: *)
ElegantRules["rf_setup"]={"filename", "name", "start_occurence", "end_occurence", "s_start", "s_end", "set_for_each_step", "near_frequency", "harmonic", "bucket_half_height", "over_voltage", "total_voltage"};


(* ::Input::Initialization:: *)
ElegantRules["replace_elements"]={"name", "type", "exclude", "skip", "disable", "element_def", "total_occurrences", "occurrence"};


(* ::Input::Initialization:: *)
ElegantRules["rpn_expression"]={"expression"};


(* ::Input::Initialization:: *)
ElegantRules["rpn_load"]={"tag", "filename", "match_column", "match_column_value", "matching_row_number", "match_parameter", "match_parameter_value", "use_row", "use_page", "load_parameters"};


(* ::Input::Initialization:: *)
ElegantRules["run_control"]={"n_steps", "bunch_frequency", "n_indices", "n_passes", "n_passes_fiducial", "reset_rf_for_each_step", "first_is_fiducial", "restrict_fiducialization"};


(* ::Input::Initialization:: *)
ElegantRules["run_setup"]={"lattice", "use_beamline", "rootname", "output", "centroid", "sigma", "final", "acceptance", "losses", "magnets", "semaphore_file", "parameters", "combine_bunch_statistics", "wrap_around", "final_pass", "default_order", "concat_order", "print_statistics", "show_element_timing", "monitor_memory_usage", "random_number_seed", "correction_iterations", "p_central", "p_central_mev", "always_change_p0", "expand_for", "tracking_updates", "echo_lattice", "search_path", "element_divisions", "load_balancing_on"};


(* ::Input::Initialization:: *)
ElegantRules["sasefel"]={"output", "model", "beta", "undulator_K", "undulator_period", "slice_fraction", "n_slices"};


(* ::Input::Initialization:: *)
ElegantRules["save_lattice"]={"filename", "output_seq"};


(* ::Input::Initialization:: *)
ElegantRules["sdds_beam"]={"input", "input_list", "input_type", "n_particles_per_ring", "selection_parameter", "selection_string", "one_random_bunch", "reuse_bunch", "prebunched", "track_pages_separately", "use_bunched_mode", "sample_interval", "n_tables_to_skip", "center_transversely", "center_arrival_time", "sample_fraction", "p_lower", "p_upper", "save_initial_coordinates", "reverse_t_sign", "n_duplicates", "duplicate_stagger"};


(* ::Input::Initialization:: *)
ElegantRules["semaphores"]={};


(* ::Input::Initialization:: *)
ElegantRules["slice_analysis"]={"output", "n_slices", "s_start", "s_end", "final_values_only"};


(* ::Input::Initialization:: *)
ElegantRules["subprocess"]={"command"};


(* ::Input::Initialization:: *)
ElegantRules["steering_element"]={"name", "element_type", "item", "plane", "tweek", "limit"};


(* ::Input::Initialization:: *)
ElegantRules["stop"]={};


(* ::Input::Initialization:: *)
ElegantRules["touschek_scatter"]={"charge", "frequency", "emit_x", "emit_nx", "emit_y", "emit_ny", "sigma_dp", "sigma_s", "Momentum_Aperture_scale", "Momentum_Aperture", "XDist", "YDist", "ZDist", "TranDist", "FullDist", "bunch", "loss", "distribution", "initial", "output", "nbins", "sbin_step", "n_simulated", "ignored_portion", "i_start", "i_end", "do_track", "match_position_only", "overwrite_files", "verbosity", "distribution_cutoff"};


(* ::Input::Initialization:: *)
ElegantRules["transmute_elements"]={"name", "type", "exclude", "new_type", "disable", "clear"};


(* ::Input::Initialization:: *)
ElegantRules["tune_footprint"]={"delta_output", "xy_output", "xmin", "xmax", "ymin", "ymax", "x_for_delta", "y_for_delta", "delta_min", "delta_max", "nx", "ny", "ndelta", "verbosity", "quadratic_spacing", "compute_diffusion", "diffusion_rate_limit", "immediate", "filtered_output", "ignore_half_integer"};


(* ::Input::Initialization:: *)
ElegantRules["twiss_analysis"]={"match_name", "start_name", "end_name", "s_start", "s_end", "tag", "verbosity", "clear"};


(* ::Input::Initialization:: *)
ElegantRules["twiss_output"]={"filename", "matched", "output_at_each_step", "output_before_tune_correction", "final_values_only", "statistics", "radiation_integrals", "concat_order", "higher_order_chromaticity", "higher_order_chromaticity_points", "higher_order_chromaticity_range", "chromatic_tune_spread_half_range", "quick_higher_order_chromaticity", "beta_x", "alpha_x", "eta_x", "etap_x", "beta_y", "alpha_y", "eta_y", "etap_y", "reference_file", "reference_element", "reference_element_occurrence", "reflect_reference_values", "cavities_are_drifts_if_matched", "compute_driving_terms", "leading_order_driving_terms_only", "s_dependent_driving_terms_file", "local_dispersion"};


(* ::Input::Initialization:: *)
ElegantRules["track"]={"center_on_orbit", "center_momentum_also", "offset_by_orbit", "offset_momentum_also", "soft_failure", "use_linear_chromatic_matrix", "longitudinal_ring_only", "stop_tracking_particle_limit"};


(* ::Input::Initialization:: *)
ElegantRules["tune_shift_with_amplitude"]={"turns", "x0", "y0", "x1", "y1", "grid_size", "lines_only", "sparse_grid", "spread_only", "nux_roi_width", "nuy_roi_width", "scale_down_factor", "scale_up_factor", "scale_down_limit", "scale_up_limit", "scaling_iterations", "use_concatenation", "verbose", "order", "tune_output"};


(* ::Input::Initialization:: *)
ElegantRules["vary_element"]={"index_number", "index_limit", "name", "item", "initial", "final", "differential", "multiplicative", "geometric", "enumeration_file", "enumeration_column"};


(* ::Input::Initialization:: *)
addRules[rules_]:=Block[{},
Union[Flatten[Switch[Head[#],
String,{#,ToUpperCase[#],ToLowerCase[#]},
Symbol,{#,ToString[#],ToUpperCase[ToString[#]],ToLowerCase[ToString[#]],Symbol@ToUpperCase[ToString[#]],Symbol@ToLowerCase[ToString[#]]},
Rule,Block[{a=#[[1]],b=#[[2]]},
Map[Rule[#,b]&,{a,ToString[a],ToUpperCase[ToString[a]],ToLowerCase[ToString[a]],Symbol@ToUpperCase[ToString[a]],Symbol@ToLowerCase[ToString[a]]}]
]
]&/@rules]]
]


(* ::Input::Initialization:: *)
ASTRARules["NEWRUN"]={"Head","RUN","LOOP","NLoop","Distribution","ion_mass","N_red","Xoff","Yoff","xp","yp","Zoff","Toff","Xrms","Yrms","XYrms","Zrms","Trms","Tau","cor_px","cor_py","Qbunch","SRT_Q_Schottky","Q_Schottky","debunch","Track_All","Track_On_Axis","Auto_Phase","Phase_Scan","check_ref_part","L_rm_back","Z_min","Z_Cathode","H_max","H_min","Max_step","Lmonitor","Lprompt"};


(* ::Input::Initialization:: *)
ASTRARules["OUTPUT"]={"ZSTART","ZSTOP","ZEMIT","ZPHASE","SCREEN","SCR_XROT","SCR_YROT","STEP_WIDTH","STEP_MAX","LPROJECT_EMIT","LOCAL_EMIT","LMAGNETIZED","LSUB_ROT","LSUB_LARMOR","LSUB_COUP","ROT_ANG","LSUB_COR","REFS","EMITS","C_EMITS","c99_EMITS","TR_EMITS","SUB_EMITS","CROSS_START","CROSS_END","PHASES","T_PHASES","HIGH_RES","BINARY","TRACKS","TCHECKS","SIGMAS","CATHODES","LANDFS","LARMORS"};


(* ::Input::Initialization:: *)
ASTRARules["SCAN"]={"LOOP","LSCAN","LEXTEND","SCAN_PARA","S_MIN","S_MAX","S_NUMB","O_MIN","O_MAX","O_MATCH","MATCH_VALUE","O_DEPTH","L_MIN","L_MAX","S_ZMIN","S_ZMAX","S_DZ","FOM"};


(* ::Input::Initialization:: *)
ASTRARules["MODULES"]={"LOOP","LMODULE","MODULE","MOD_XOFF","MOD_YOFF","MOD_ZOFF","MOD_XROT","MOD_YROT","MOD_ZROT","MOD_ZPOS","MOD_EFIELD","MOD_PHASE","MOD_BFIELD"};


(* ::Input::Initialization:: *)
ASTRARules["ERROR"]={"LOOP","LERROR","ERRORS","LOG_ERROR","LEXTEND","SUPPRESS_OUTPUT","FOM","ERR_CUTOFF","ERR_QBUNCH","ERR_XOFF","ERR_YOFF","ERR_TOFF","ERR_XRMS","ERR_YRMS","ERR_XYRMS","ERR_ZRMS","ERR_TRMS","ERR_A_XOFF","ERR_A_YOFF","ERR_A_XROT","ERR_A_YROT","ERR_A_ZROT","ERR_C_XOFF","ERR_C_YOFF","ERR_C_XROT","ERR_C_YROT","ERR_C_ZROT","ERR_PHI","ERR_MAXE","ERR_S_XOFF","ERR_S_YOFF","ERR_S_XROT","ERR_S_YROT","ERR_MAXB","ERR_Q_XOFF","ERR_Q_YOFF","ERR_Q_XROT","ERR_Q_YROT","ERR_Q_ZROT","ERR_Q_GRAD","ERR_D_XOFF","ERR_D_YOFF","ERR_D_XROT","ERR_D_YROT","ERR_D_ZROT","ERR_D_STRENGTH","ERR_D_RADIUS","ERR_MOD_XOFF","ERR_MOD_YOFF","ERR_MOD_XROT","ERR_MOD_YROT","ERR_MOD_ZROT","ERR_MOD_EFIELD","ERR_MOD_PHASE","ERR_MOD_BFIELD"};


(* ::Input::Initialization:: *)
ASTRARules["CHARGE"]={"LOOP","LSPCH","LSPCH3D","L2D_3D","LMIRROR","L_CURVED_CATHODE","CATHODE_CONTOUR","R_ZERO","NRAD","CELL_VAR","NLONG_IN","N_MIN","MIN_GRID","MERGE_1","MERGE_2","MERGE_3","MERGE_4","MERGE_5","MERGE_6","MERGE_7","MERGE_8","MERGE_9","MERGE_10","Z_TRANS","MIN_GIRD_TRANS","NXF","NX0","NYF","NY0","NZF","NZ0","SMOOTH_X","SMOOTH_Y","SMOOTH_Z","MAX_SCALE","MAX_COUNT","EXP_CONTROL"};


(* ::Input::Initialization:: *)
ASTRARules["APERTURE"]={"LOOP","LAPERT","FILE_APERTURE","AP_Z1","AP_Z2","AP_R","AP_GR","A_POS","A_XOFF","A_YOFF","A_XROT","A_YROT","A_ZROT","SE_D0","SE_EPM","SE_FS","SE_TAU","SE_ESC","SE_FF1","SE_FF2","MAX_SECONDARY","LCLEAN_STACK"};


(* ::Input::Initialization:: *)
ASTRARules["WAKE"]={"LOOP","LWAKE","WK_TYPE","WK_FILENAME","WK_TESTFILE","WK_SCREEN","WK_SCALING","WK_X","WK_Y","WK_Z","WK_EX","WK_EY","WK_EZ","WK_HX","WK_HY","WK_HZ","WK_EQUI_GRID","WK_N_BIN","WK_IP_METHOD","WK_SMOOTH","WK_SIGMA_MIN","WK_SUB"};


(* ::Input::Initialization:: *)
ASTRARules["CAVITY"]={"LOOP","LEFIELD","FILE_EFIELD","C_NOSCALE","C_SMOOTH","COM_GRID","C_HIGHER_ORDER","NUE","K_WAVE","MAX_E","EX_STAT","EY_STAT","BX_STAT","BY_STAT","BZ_STAT","FLATNESS","PHI","C_POS","C_NUMB","T_DEPENDENCE","T_NULL","C_TAU","E_STORED","C_XOFF","C_YOFF","C_XROT","C_YROT","C_ZROT","C_ZKICKMIN","C_ZKICKMAX","C_XKICK","C_YKICK","FILE_A0","P_Z1","P_R1","P_Z2","P_R2","P_N","E_A0","E_Z0","E_SIG","E_SIGZ","E_ZR","E_EPS","E_LAM","ZETA"};


(* ::Input::Initialization:: *)
ASTRARules["SOLENOID"]={"LOOP","LBFIELD","FILE_BFIELD","S_NOSCALE","S_SMOOTH","S_HIGHER_ORDER","MAXB","S_POS","S_XOFF","S_YOFF","S_XROT","S_YROT"};


(* ::Input::Initialization:: *)
ASTRARules["QUADRUPOLE"]={"LOOP","LQUAD","Q_TYPE","Q_GRAD","Q_K","Q_NOSCALE","Q_LENGTH","Q_SMOOTH","Q_BORE","Q_DIST","Q_MULT_A","Q_MULT_B","Q_POS","Q_XOFF","Q_YOFF","Q_XROT","Q_YROT","Q_ZROT"};


(* ::Input::Initialization:: *)
ASTRARules["DIPOLE"]={"LOOP","LDIPOLE","D_TYPE","D1","D2","D3","D4","D_GAP","D_STRENGTH","D_RADIUS","D_XOFF","D_YOFF","D_ZOFF","D_XROT","D_YROT","D_ZROT"};


(* ::Input::Initialization:: *)
ASTRARules["LASER"]={"LOOP","LLASER","L_TYPE","L_Z1","L_Z2","L_H","L_F","L_ZSTART","L_TSTART","L_XOFF","L_YOFF","L_XROT","L_YROT","L_ZROT","L_E0","L_POW","L_A0","L_EPEAK","L_TAU","L_PHI","L_LAM","L_SIG0","L_W0","L_DELTA","L_WINDOW","L_ALPHA"};


(* ::Input::Initialization:: *)
ASTRARules["INPUT"]={"FNAME","Add","N_add","Ipart","Species","ion_mass","Probe","Passive","Noise_reduc","Cathode","R_Cathode","High_res","Binary","Q_Total","Type","Rad","Tau","Red_zpos","Ref_clock","Ref_Ekin","Dist_z","sig_z","C_sig_z","Lz","rz","sig_clock","C_sig_clock","Lt","rt","Dist_pz","sig_Ekin","C_sig_Ekin","LE","rE","emit_z","cor_Ekin","E_photon","phi_eff","Dist_x","sig_x","C_sig_x","Lx","rx","x_off","Disp_x","Dist_px","Nemit_x","sig_px","C_sig_px","Lpx","rpx","cor_px","Dist_y","sig_y","C_sig_y","Ly","ry","y_off","Disp_y","Dist_py","Nemit_y","sig_py","C_sig_py","Lpy","rpy","cor_py"};


(* ::Input::Initialization:: *)
formatString[in_]:=Block[{},
Switch[Head[in],
String,in,
Real,ToString[numberRight[in]],
Integer,ToString[in],
Rational,ToString[CForm[in]],
List,MapIndexed[If[#2[[1]]>1,",",""]<>ToString[CForm[#]]&,in],
_,ToString[numberRight[in]]
]
]


(* ::Input::Initialization:: *)
Clear[MADWriteElements];
MADWriteElements[elementLine[list__]]:=MADWriteElements[Flatten[elementLine[list]]]
MADWriteElements[elementLine[list__elementDefinition]]:=Block[{},
Block[{element},
element=#;
("NAME"/.element)<>If[("REVERSED"/.element)===True,"Reversed",""]<>":"<>("TYPE"/.Cases[MADRules[Evaluate["TYPE"/.element]],Rule["TYPE",a_]:>Rule["TYPE",a]]/.element)<>StringJoin@@(Switch[Head[#],
Symbol,If[(#/.element/.{#->Null})=!=Null,","<>ToString[#]<>"="<>formatString[Evaluate[(#/.element)]],""],
String,If[(#/.element/.{#->Null})=!=Null,","<>ToString[#]<>"="<>formatString[Evaluate[(#/.element)]],""],
Rule,If[(#[[1]]/.element/.{#[[1]]->Null})=!=Null,","<>ToString[#[[2]]]<>"="<>formatString[Evaluate[(#[[1]]/.element)]],""]
]&/@DeleteCases[MADRules[Evaluate["TYPE"/.element]],Rule["TYPE",a_]])<>";\n"
]&/@List@@Union[Flatten[elementLine[list]]]
]


(* ::Input::Initialization:: *)
Clear[generateLineDefinition];
generateLineDefinition[line:elementLine[list__],file_]:=Block[{},
Map[generateLineDefinition[#,file]&,Union[Select[{list},Head[#]===elementLine&]]];
If[!MemberQ[generatedLines,StringReplace[line["NAME"],"-"->""]],
AppendTo[generatedLines,StringReplace[line["NAME"],"-"->""]];
(*Print[StringReplace[line["NAME"],"-"\[Rule]""]<>": Line = ("<>StringJoin@@
MapIndexed[If[#2[[1]]>1,",",""]<>ToString[#]&,Names[elementLine[list]]]<>")\n"];*)
WriteString[file,wrapString[StringReplace[line["NAME"],"-"->""]<>": Line = ("<>StringJoin@@
MapIndexed[If[#2[[1]]>1,",",""]<>ToString[#]&,Names[line,True]]<>")\n"]]
]
]


(* ::Input::Initialization:: *)
Clear[MADWrite];
SetAttributes[MADWrite,HoldFirst];
MADWrite[lattice_Symbol]/;Head[Evaluate[lattice]]===elementLine:=Block[{},
{MADWriteElements[Evaluate[lattice]],
{ToString[HoldForm[lattice]]<>": Line=("<>generateLineDefinition[Evaluate[lattice]]<>")"}
}
];
MADWrite[lattice_]/;Head[Evaluate[lattice]]===elementLine:=Block[{},
{MADWriteElements[Evaluate[lattice]],
{"lattice: Line=("<>generateLineDefinition[Evaluate[lattice]]<>")"}
}
];


(* ::Input::Initialization:: *)
Clear[elegantWriteElements];
elegantWriteElements[elementLine[list__]]:=elegantWriteElements/@Union[Cases[{list},elementDefinition[__Rule],\[Infinity]]]
elegantWriteElements[elementDefinition[list__Rule]]:=Block[{element},
element=capitalRuleNames[elementDefinition[list]];
("NAME"/.element)<>":"<>("TYPE"/.Cases[ElegantRules[ToUpperCase[Evaluate["TYPE"/.element]]],Rule["TYPE",a_]:>Rule["TYPE",a]]/.element)<>StringJoin@@(
Switch[
Head[#],
Symbol,If[(#/.element/.{#->Null})=!=Null,","<>ToString[#]<>"="<>formatString[Evaluate[(#/.element)]],""],
String,If[(#/.element/.{#->Null})=!=Null,","<>ToString[#]<>"="<>formatString[Evaluate[(#/.element)]],""],
Rule,If[(#[[1]]/.element/.{#[[1]]->Null})=!=Null,","<>ToString[#[[2]]]<>"="<>formatString[Evaluate[(#[[1]]/.element)]],""]
]&/@DeleteCases[ElegantRules[ToUpperCase[Evaluate["TYPE"/.element]]],Rule["TYPE",a_]])<>";\n"
]


(* ::Input::Initialization:: *)
Clear[ElegantWriteElementStrings];
SetAttributes[ElegantWriteElementStrings,HoldFirst];
ElegantWriteElementStrings[lattice_Symbol]/;Head[Evaluate[lattice]]==elementLine:=Block[{},
elegantWriteElements[lattice]
];
ElegantWriteElementStrings[lattice_elementLine]:=Block[{},
elegantWriteElements[lattice]
]


(* ::Input::Initialization:: *)
Clear[elegantWriteCommand];
elegantWriteCommand[list__commandDefinition]:=Quiet@Block[{option,name},
option=capitalRuleNames[#];
"&"<>("command"/.option)<>"\n"<>StringJoin@@(
(If[(param=#/.option/.{#->Null})=!=Null,
name=#/.{"po"->"Po"};
Switch[
Head[param],
List,
MapIndexed[Block[{no=#2[[1]]-1},
"\t"<>ToString[name]<>"["<>ToString[no]<>"]="<>formatString[#]<>"\n"]&,param],
HoldForm,"\t"<>ToString[name]<>"="<>formatString[param]<>"\n",
Symbol,"\t"<>ToString[name]<>"="<>formatString[param]<>"\n",
String,"\t"<>ToString[name]<>"="<>formatString[param]<>"\n",
Integer,"\t"<>ToString[name]<>"="<>formatString[ToString[param]]<>"\n",
Real,"\t"<>ToString[name]<>"="<>formatString[ToString[param]]<>"\n",
Rational,"\t"<>ToString[name]<>"="<>formatString[ToString[N[param]]]<>"\n",
Rule,"\t"<>ToString[#[[2]]]<>"="<>formatString[Evaluate[(#[[1]]/.option)]]<>"\n",
_,"\t"<>ToString[name]<>"="<>formatString[ToString[param]]<>"\n"
],""])&/@ElegantRules[ToLowerCase[Evaluate["command"/.option]]])<>"&end\n\n"
]&/@Union[{list},SameTest->(("command"/.capitalRuleNames[#1])==("command"/.capitalRuleNames[#2])&)]


(* ::Input::Initialization:: *)
Clear[elegantWriteCommandStrings];
SetAttributes[elegantWriteCommandStrings,HoldFirst];
elegantWriteCommandStrings[commands_]/;Head[Evaluate[commands]]==List:=Block[{},
Map[elegantWriteCommand[#]&,commands]
]


(* ::Input::Initialization:: *)
Clear[ElegantWriteLattice];
(*SetAttributes[ElegantWriteLattice,HoldFirst];*)
ElegantWriteLattice[lattice_String,filename_]:=ElegantWriteLattice[ToExpression[lattice],filename];
ElegantWriteLattice[lattice_,filename_]:=Block[{file},
Quiet[Close[filename]];
generatedLines={"NAME"};
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,ElegantWriteElementStrings[lattice]];
generateLineDefinition[lattice,file];
Close[file]
];


(* ::Input::Initialization:: *)
Clear[ElegantWriteCommands];
SetAttributes[ElegantWriteCommands,HoldFirst];
ElegantWriteCommands[commands_List,filename_]:=Block[{file},
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,elegantWriteCommandStrings[Select[commands,Length[Cases[capitalRuleNames[#],Rule["command",a_]:>a]]>0&]]];
Close[file]
];
ElegantWriteCommands[commands_commandDefinition,filename_]:=Block[{file},
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,elegantWriteCommandStrings[Select[{commands},Length[Cases[capitalRuleNames[#],Rule["command",a_]:>a]]>0&]]];
Close[file]
];


(* ::Input::Initialization:: *)
Clear[ASTRAWriteCommand];
ASTRAWriteCommand[list__commandDefinition]:=Quiet@Block[{option,name},
option=capitalRuleNames[#];
"&"<>("command"/.option)<>"\n"<>StringJoin@@(
(If[(param=#/.option/.{#->Null})=!=Null,
name=#/.{"po"->"Po"};
Switch[
Head[param],
List,
MapIndexed[Block[{no=#2[[1]]-1},
"\t"<>ToString[name]<>"["<>ToString[no]<>"]="<>formatString[#]<>"\n"]&,param],
HoldForm,"\t"<>ToString[name]<>"="<>formatString[param]<>"\n",
Symbol,"\t"<>ToString[name]<>"="<>formatString[param]<>"\n",
String,"\t"<>ToString[name]<>"="<>formatString[param]<>"\n",
Integer,"\t"<>ToString[name]<>"="<>formatString[ToString[param]]<>"\n",
Real,"\t"<>ToString[name]<>"="<>formatString[ToString[param]]<>"\n",
Rational,"\t"<>ToString[name]<>"="<>formatString[ToString[N[param]]]<>"\n",
Rule,"\t"<>ToString[#[[2]]]<>"="<>formatString[Evaluate[(#[[1]]/.option)]]<>"\n",
_,"\t"<>ToString[name]<>"="<>formatString[ToString[param]]<>"\n"
],""])&/@ElegantRules[ToLowerCase[Evaluate["command"/.option]]])<>"&end\n\n"
]&/@Union[{list},SameTest->(("command"/.capitalRuleNames[#1])==("command"/.capitalRuleNames[#2])&)]


(* ::Input::Initialization:: *)
Clear[ASTRAWriteCommandStrings];
SetAttributes[ASTRAWriteCommandStrings,HoldFirst];
ASTRAWriteCommandStrings[commands_]/;Head[Evaluate[commands]]==List:=Block[{},
Map[ASTRAWriteCommand[#]&,commands]
]


(* ::Input::Initialization:: *)
Clear[ASTRAWriteCommands];
SetAttributes[ASTRAWriteCommands,HoldFirst];
ASTRAWriteCommands[commands_List,filename_]:=Block[{file},
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,ASTRAWriteCommandStrings[Select[commands,Length[Cases[capitalRuleNames[#],Rule["command",a_]:>a]]>0&]]];
Close[file]
];
ASTRAWriteCommands[commands_commandDefinition,filename_]:=Block[{file},
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,ASTRAWriteCommandStrings[Select[{commands},Length[Cases[capitalRuleNames[#],Rule["command",a_]:>a]]>0&]]];
Close[file]
];


$elegantPath="";


$sddsPath="";


$elegantFilename="elegant";


ElegantRun[filename_]:=Block[{},
RunProcess[{$elegantPath<>If[$elegantPath=!="","\\",""]<>$elegantFilename,filename}]
]


sddsCommand[command_String, filename_String,opts___Rule]:=Block[{createOutput},
createOutput=Global`CreateOutput/.{opts}/.{Global`CreateOutput->False};
If[createOutput==True,
ReadList["!"<>$sddsPath<>If[$sddsPath=!="","\\",""]<>command<>" "<>filename<>" "<>filename<>"."<>command,Record];
sddsBinaryInterpret[filename<>".analysis",opts],
sddsBinaryInterpret[OpenRead["!"<>command<>" -pipe=output "<>filename,BinaryFormat->True],opts]
]
]


sddsAnalyzeBeam[filename_,opts___Rule]:=Block[{createOutput},
createOutput=Global`CreateOutput/.{opts}/.{Global`CreateOutput->False};
If[createOutput==True,
ReadList["!"<>$elegantPath<>If[$elegantPath=!="","\\",""]<>"sddsanalyzebeam "<>filename<>" "<>filename<>".analysis",Record];
sddsBinaryInterpret[filename<>".analysis",opts],
sddsBinaryInterpret[OpenRead["!"<>$elegantPath<>If[$elegantPath=!="","\\",""]<>"sddsanalyzebeam -pipe=output "<>filename,BinaryFormat->True],opts]
]
]


(* ::Input::Initialization:: *)
SetAttributes[ElegantTwiss,HoldFirst];
ElegantTwiss[lattice_,commands___commandDefinition,opts___Rule]:=Block[{filename},
filename="temp";
runsetup=commandDefinition[opts,"LATTICE"->FileBaseName[filename]<>".lte","command"->"run_setup","use_beamline"->Evaluate[lattice["NAME"]],"p_central_mev"->1000];
runcontrol=commandDefinition[opts,"n_steps"->1,"n_passes"->1,"Command"->"run_control"];
twissoutput=commandDefinition[opts,"filename"->"%s.twi","matched"->1,"Command"->"twiss_output"];
matrixoutput=commandDefinition[opts,"SDDS_output"->"%s.matrix","SDDS_output_order"->2,"individual_matrices"->0,"Command"->"matrix_output"];
flooroutput=commandDefinition[opts,"filename"->"%s.flr","Command"->"floor_coordinates"];
ElegantWriteCommands[{runsetup,runcontrol,twissoutput,matrixoutput,flooroutput,commands},filename<>".ele"];
ElegantWriteLattice[lattice,filename<>".lte"];
ElegantRun[filename<>".ele"];
sddsBinaryInterpret[filename<>".twi"]
]


(* ::Input::Initialization:: *)
elementClass["CSBEND"]="dipole"
elementClass["CSRCSBEND"]="dipole"
elementClass["KSBEND"]="dipole"
elementClass["NIBEND"]="dipole"
elementClass["KQUAD"]="quadrupole"
elementClass["QUAD"]="quadrupole"
elementClass["KSEXT"]="sextupole"
elementClass["SEXT"]="sextupole"
elementClass["CSRDRIFT"]="drift"
elementClass["DRIF"]="drift"
elementClass["EDRIFT"]="drift"
elementClass["LSCDRIFT"]="drift"
elementClass["DRIFT"]="drift"
elementClass["KOCT"]="octupole"
elementClass["OCTU"]="octupole"
elementClass["RFCA"]="rfc"
elementClass["RFCW"]="rfc"
elementClass["MODRF"]="rfc"
elementClass["RFTMEZ0"]="rfc"
elementClass["LCAV"]="rfc"
elementClass["MAPSOLENOID"]="solenoid"
elementClass["SOLE"]="solenoid"
elementClass["WIGGLER"]="wiggler"
elementClass["CWIGGLER"]="wiggler"
elementClass["GFWIGGLER"]="wiggler"
elementClass["EHKICK"]="kicker"
elementClass["EKICKER"]="kicker"
elementClass["EVKICK"]="kicker"
elementClass["HKICK"]="kicker"
elementClass["KICKER"]="kicker"
elementClass["UKICKMAP"]="kicker"
elementClass["VKICK"]="kicker"
elementClass["MONI"]="bpm"
elementClass["HMON"]="bpm"
elementClass["VMON"]="bpm"
elementClass["MONITOR"]="bpm"
elementClass["ECOL"]="collimator"
elementClass["RCOL"]="collimator"
elementClass["MARK"]="marker"
elementClass["WATCH"]="marker"
elementClass["MAXAMP"]="marker"
elementClass["FMULT"]="multipole"
elementClass["MULT"]="multipole"
elementClass[_]="marker"


(* ::Input::Initialization:: *)
Clear[findElementClass];
findElementClass[a_elementDefinition]:=elementClass[a["TYPE"]]
findElementClass[a_]:="marker"


(* ::Input::Initialization:: *)
Options[ElementDraw]={Labels->False,Thickness->0.001,Monitors->True,Lengths->False,Filled->False,WidthScale->1.4,Symms->True,Bends->True,Offset->0,ShowPicture->True,Fontsize->12,Imagesize->800,DrawLabel->"",CheckClosed->False,Frame->True,ElementDrawText->False};


(* ::Input::Initialization:: *)
Clear[ElementDrawElement];


(* ::Input::Initialization:: *)
Clear[elementDrawRotation];
elementDrawRotation[{x_,y_},\[Theta]_]:={x Cos[\[Theta]]-y Sin[\[Theta]],x Sin[\[Theta]]+y Cos[\[Theta]]};


(* ::Input::Initialization:: *)
TextOscillate[]:=Switch[TEXTOSCILLATE,1,TEXTOSCILLATE=-1,-1,TEXTOSCILLATE=1,_,1]


(* ::Input::Initialization:: *)
TextDirection[]:=Switch[TEXTOSCILLATE,-1,1,_,-1]


(* ::Input::Initialization:: *)
ElementDrawElement["drift",position_,length_,bend_,rotation_,label_,opts___]:=Block[{wdr,widthscale,text,driftlabels,driftlengths},
driftlabels=Global`DriftLabels/.{opts}/.{Global`DriftLabels->False};
driftlengths=Global`DriftLengths/.{opts}/.{Global`DriftLengths->False};
text=ElementDrawText/. {opts}/. Options[ElementDraw];
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wdr=0.16widthscale;
Join[{Line[{position,position+elementDrawRotation[length*{1,0},rotation]}]},
If[text,
If[driftlabels===True,
If[driftlengths===True,label=label<>"\n"<>ToString[numberRight[length]]<>"m"];
{Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{0.5wdr Sin[-rotation], 0.5 wdr Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}]},
If[driftlengths===True,{Text[ToString[numberRight[length]]<>"m",position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1wdr Sin[-rotation], 1 wdr Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}]},{}]]
,{}]]];


(* ::Input::Initialization:: *)
wd:=0.1*widthscale;


(* ::Input::Initialization:: *)
ElementDrawElement["dipole",position_,length_,bend_,rotation_,label_,opts___]:=Block[{text,bends,thick,colour,widthscale},
text=ElementDrawText/. {opts}/. Options[ElementDraw];
bends=Bends/. {opts}/. Options[ElementDraw];
thick=Thickness/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wd=0.1*widthscale;
If[bends&&Abs[bend]>0.001&&length>0,
{colour,Thickness[thick],

Circle[position+elementDrawRotation[{0,length/bend},rotation],length/Abs[bend]-wd,
If[bend>=0,{(3\[Pi])/2+rotation,(3\[Pi])/2+bend+rotation},{(-3\[Pi])/2+rotation+bend,(-3\[Pi])/2+rotation}]],

Circle[position+elementDrawRotation[{0,length/bend},rotation],length/Abs[bend]+wd  ,
If[bend>=0,{(3\[Pi])/2+rotation,(3\[Pi])/2+bend+rotation},{(-3\[Pi])/2+rotation+bend,-((3\[Pi])/2)+rotation}]],


Line[{position+elementDrawRotation[{0,wd},rotation],position-elementDrawRotation[{0,wd},rotation]}],


Line[{position+elementDrawRotation[{(length/bend-wd )Sin[bend],length/bend (1-Cos[bend])+wd Cos[bend]},rotation],position+elementDrawRotation[{(length/bend+wd)(Sin[bend]),length/bend (1-Cos[bend])-wd Cos[bend]},rotation]}],If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.3wd Sin[-rotation-bend/2],1.3wd Cos[-rotation-bend/2]},{TextDirection[],0},{Sin[-rotation-bend/2],Cos[-rotation-bend/2]}],{}]},
{White,colour,Thickness[thick],EdgeForm[Thickness[Medium]],
Polygon[{position+elementDrawRotation[{0,wd},rotation],position+elementDrawRotation[{length,wd},rotation],position+elementDrawRotation[{length,-wd},rotation],position+elementDrawRotation[{0,-wd},rotation]}],Black,If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.3wd Sin[-rotation-0],1.3wd Cos[-rotation-0]},{TextDirection[],0},{Sin[-rotation-0],Cos[-rotation-0]}],{}]}]
]


(* ::Input::Initialization:: *)
ElementDrawElement["quadrupole",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wq=0.12*widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],RGBColor[1,0,0]}],
Polygon[{position,position+elementDrawRotation[{0,1.4wq},ar rotation],position+elementDrawRotation[{length,1.4wq},ar rotation],position+elementDrawRotation[{length,-1.4wq},ar rotation],position+elementDrawRotation[-{0,1.4wq},ar rotation],position}],
Polygon[{position,position+elementDrawRotation[{0,wq},ar rotation],position+elementDrawRotation[{length,wq},ar rotation],position+elementDrawRotation[{length,-wq},ar rotation],position+elementDrawRotation[-{0,wq},ar rotation],position}],If[text,{Red,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.5wq Sin[-rotation], 1.5 wq Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}]},{}]}
];


(* ::Input::Initialization:: *)
ElementDrawElement["sextupole",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale,wq},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
ws=0.08*widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],RGBColor[0,0,1]}],
Polygon[{position,position+elementDrawRotation[{0,1.4ws},rotation],position+elementDrawRotation[{length,1.4ws},rotation],position+elementDrawRotation[{length,-1.4ws},rotation],position+elementDrawRotation[-{0,1.4ws},rotation],position}],
Polygon[{position,position+elementDrawRotation[{0,ws},rotation],position+elementDrawRotation[{length,ws},rotation],position+elementDrawRotation[{length,-ws},rotation],position+elementDrawRotation[-{0,ws},rotation],position}],If[text,{Red,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.5wq Sin[-rotation], 1.5 wq Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}]},{}]}
];


(* ::Input::Initialization:: *)
ElementDrawElement["symmline",position_,length_,bend_,rotation_,label_,opts___]:=Block[{text,wm,thick},
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wm=0.35*widthscale;
{Thickness[thick],Dashing[{0.01,0.01}],Line[{position+elementDrawRotation[{0,wm},rotation],position+elementDrawRotation[{0,-wm},rotation]}],If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{wm Sin[-rotation],wm Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]}
];


(* ::Input::Initialization:: *)
ElementDrawElement["marker",position_,length_,bend_,rotation_,label_,opts___]:=Block[{text,widthscale,wm,thick},
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wm=0.15*widthscale;
{Thick,Dashed,Blue,Line[{position+elementDrawRotation[{0,wm},rotation],position+elementDrawRotation[{0,-wm},rotation]}],If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{wm Sin[-rotation],wm Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]}
];


(* ::Input::Initialization:: *)
ElementDrawElement["kicker",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.07widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],RGBColor[.4,.4,.4]}],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.8wkick Sin[-rotation],1.8wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


(* ::Input::Initialization:: *)
ElementDrawElement["bpm",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.03widthscale;
{colour,Thickness[thick],Thick,RGBColor[.8,.3,.8],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{2.3wkick Sin[-rotation],2.3wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


(* ::Input::Initialization:: *)
ElementDrawElement["wiggler",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.1widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],Brown}],FaceForm[Brown],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position},VertexTextureCoordinates->{{0,0},{1,0},{1/2,1}}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{2.3wkick Sin[-rotation],2.3wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


(* ::Input::Initialization:: *)
ElementDrawElement["solenoid",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.12widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],Pink}],FaceForm[Pink],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position},VertexTextureCoordinates->{{0,0},{1,0},{1/2,1}}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{2.3wkick Sin[-rotation],2.3wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


(* ::Input::Initialization:: *)
ElementDrawElement["rfc",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.03widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],Green}],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position},VertexTextureCoordinates->{{0,0},{1,0},{1/2,1}}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{2.3wkick Sin[-rotation],2.3wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


(* ::Input::Initialization:: *)
ElementDrawElement["collimator",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.12widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],Black}],FaceForm[Black],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position},VertexTextureCoordinates->{{0,0},{1,0},{1/2,1}}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{2.3wkick Sin[-rotation],2.3wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


(* ::Input::Initialization:: *)
Clear[ElementDraw];


(* ::Input::Initialization:: *)
ElementDraw[data_,opts___]:=Block[{text,thick,bpms,lengths,filled,widthscale,symms,bends,closed,offset,optShow,elementList,lattice,elementDrawRot, roty,sinc2,xform,localXYZ,x,graph,sinc,cosc,sym, tilt,findrotations,findrotationsv,anglesum=0,sum1,x1,prepositions2,vbends},
text=Global`Labels/. {opts}/. {Global`Labels->False};thick=Thickness/. {opts}/. Options[ElementDraw];bpms=Monitors/. {opts}/. Options[ElementDraw];lengths=Lengths/. {opts}/. Options[ElementDraw];filled=Filled/. {opts}/. Options[ElementDraw];If[filled,shape="Polygon",shape="Line"];widthscale=WidthScale/. {opts}/. Options[ElementDraw];symms=Symms/. {opts}/. Options[ElementDraw];bends=Bends/. {opts}/. Options[ElementDraw];closed=CheckClosed/. {opts}/. Options[ElementDraw];offset=Offset/. {opts}/. Options[ElementDraw];
vbends=Global`VerticalBends/.{opts}/.{Global`VerticalBends->False};optShow=Join[{Sequence@@FilterRules[Flatten[{opts}],Options[Graphics]]},{Sequence@@FilterRules[Flatten[{opts}],Options[Show]]}];elementList=Flatten[data];
(*If[Not[bpms],elementList=Select[elementList,#1\[LeftDoubleBracket]2\[RightDoubleBracket]=!="BPM"&]];*)

tilt[element_]:=Switch[findElementClass[element],
"dipole",element["TILT"] ,
_,0];

lattice=({findElementClass[#],#1["LENGTH"],N[#["BENDANGLE"]],"",tilt[#1],#}&)/@elementList;

If[bends===True,findrotations=(
Switch[#[[1]],
"dipole",anglesum+=Cos[#[[5]]]#1[[3]],
_,anglesum]&/@Drop[Prepend[lattice,{0,0,0,"",0}],-1]),findrotations=Table[0.,{Length[lattice]}]];

findrotationsv=(sum1=0;(sum1+=Sin[#[[5]]]#1[[3]]&)/@Drop[Prepend[lattice,{0,0,0,"",0}],-1]);

Coslimit[\[Theta]_,length_]:=Coslimit[\[Theta],length]=Limit[length/\[Theta]1 (Cos[\[Theta]1]-1),\[Theta]1->\[Theta]];
Sinlimit[\[Theta]_,length_]:=Sinlimit[\[Theta],length]=Limit[length/\[Theta]1 Sin[\[Theta]1],\[Theta]1->\[Theta]];
xform[{\[Theta]_,tilt_,length_},{x_,r_}]:=Block[{dx,n,rt,rp},
dx=r.({
 {Cos[tilt], -Sin[tilt], 0},
 {Sin[tilt], Cos[tilt], 0},
 {0, 0, 1}
}).({
 {Coslimit[\[Theta],length]},
 {0},
 {Sinlimit[\[Theta],length]}
});
rt=Transpose[r];
n=rt[[2]]Cos[tilt]-rt[[1]]Sin[tilt];
rp=Outer[Times,rt.n,n](1-Cos[\[Theta]])+rt Cos[\[Theta]]+{Cross[rt[[1]],n],Cross[rt[[2]],n],Cross[rt[[3]],n]}Sin[\[Theta]];
{x+dx,Transpose[rp]}
];
Which[ListQ[offset],
x={({
 {offset[[2]]},
 {0},
 {offset[[1]]}
})},
NumberQ[offset],
x={({
 {offset},
 {0},
 {0}
})},
True,
x={({
 {0},
 {0},
 {0}
})}
];
localXYZ=IdentityMatrix[3];
Block[{},
{x1,localXYZ}=xform[{If[bends,-#[[3]],0],-#[[5]],#[[2]]},{x[[-1]],localXYZ}];
AppendTo[x,x1]]&/@lattice;
prepositions2=Most[x[[All,{3,1},1]]];
graph=Graphics[ElementDrawElement[#1[[1,1]],#1[[2]],#1[[1,2]] ,If[bends,Cos[#[[1,5]]]#1[[1,3]],0],#1[[3]],"",Element->#[[1,-1]],opts]&/@Transpose[{lattice,prepositions2,findrotations}]];

Show[graph,optShow,Sequence@@FilterRules[Flatten[{Options[ElementDraw]}],Options[Show]],Lighting->Automatic]]


(* ::Input::Initialization:: *)
ElementPositions[data_,opts___]:=Block[{rot,roty,sinc,cosc,sinc2,sym,test,autolabels,thick,bpms,lengths,filled,widthscale,symms,bends,closed,offset,bpmcircle,textoscillate,fancyelements,anglesum,findrotations,findrotationsv,cc,RM,prepositions,prepositions2,v,rm,sum1,startangle,layout,fancy,optShow,b,a,c,lattice,tilt,elementList},
anglesum=startangle=Global`AngleOffset/.{opts}/.{Global`AngleOffset->0};
offset=Global`Offset/.{opts}/.{Global`Offset->True};
bends=Global`Bends/.{opts}/.{Global`Bends->True};
elementList=Flatten[data];

tilt[element_]:=Switch[findElementClass[element],
"dipole",element["TILT"] ,
_,0];

lattice=({findElementClass[#],#1["LENGTH"],N[#["BENDANGLE"]],"",tilt[#1],#}&)/@elementList;

If[bends===True,findrotations=(
Switch[#[[1]],
"dipole",anglesum+=Cos[#[[5]]]#1[[3]],
_,anglesum]&/@Drop[Prepend[lattice,{0,0,0,"",0}],-1]),findrotations=Table[0.,{Length[lattice]}]];

findrotationsv=(sum1=0;(sum1+=Sin[#[[5]]]#1[[3]]&)/@Drop[Prepend[lattice,{0,0,0,"",0}],-1]);

Coslimit[\[Theta]_,length_]:=Coslimit[\[Theta],length]=Limit[length/\[Theta]1 (Cos[\[Theta]1]-1),\[Theta]1->\[Theta]];
Sinlimit[\[Theta]_,length_]:=Sinlimit[\[Theta],length]=Limit[length/\[Theta]1 Sin[\[Theta]1],\[Theta]1->\[Theta]];
xform[{\[Theta]_,tilt_,length_},{x_,r_}]:=Block[{dx,n,rt,rp},
dx=r.({
 {Cos[tilt], -Sin[tilt], 0},
 {Sin[tilt], Cos[tilt], 0},
 {0, 0, 1}
}).({
 {Coslimit[\[Theta],length]},
 {0},
 {Sinlimit[\[Theta],length]}
});
rt=Transpose[r];
n=rt[[2]]Cos[tilt]-rt[[1]]Sin[tilt];
rp=Outer[Times,rt.n,n](1-Cos[\[Theta]])+rt Cos[\[Theta]]+{Cross[rt[[1]],n],Cross[rt[[2]],n],Cross[rt[[3]],n]}Sin[\[Theta]];
{x+dx,Transpose[rp]}
];
Print[offset];
Which[ListQ[offset],
x={Transpose[{offset}]},
NumberQ[offset],
x={({
 {0},
 {0},
 {offset}
})},
True,
x={({
 {0},
 {0},
 {0}
})}
];
localXYZ=IdentityMatrix[3];
Block[{},
{x1,localXYZ}=xform[{If[bends,-#[[3]],0],-#[[5]],#[[2]]},{x[[-1]],localXYZ}];
AppendTo[x,x1]]&/@lattice;
prepositions2=x[[All,{1,2,3},1]];

MapThread[List,{Most[prepositions2],Rest[prepositions2],lattice,findrotations}]
]


(* ::Input::Initialization:: *)
ElementFootPrint[lattice_]:={(Max[#[[1]]]-Min[#[[1]]]),(Max[#[[2]]]-Min[#[[2]]])}&[Transpose[ElementPositions[lattice][[All,1,{1,2}]]]]


(* ::Input::Initialization:: *)
ElementPositions2[data_,opts___]:=Block[{anglesum,bends,findrotations,cc,RM,v,rm,startangle,prepositions,prepositions2,offset,angle,lattice,elementList},
anglesum=startangle=Global`AngleOffset/.{opts}/.{Global`AngleOffset->0};
bends=Bends/.{opts}/.Options[MADDraw];
offset=Offset/.{opts}/.Options[MADDraw];

sinc[\[Theta]_]:=If[Abs[\[Theta]]>0,Sin[\[Theta]]/\[Theta],1];
cosc[\[Theta]_]:=If[Abs[\[Theta]]>0,(1-Cos[\[Theta]])/\[Theta],0];

elementList=Flatten[data];

tilt[element_]:=Switch[findElementClass[element],
"dipole",element["TILT"] ,
_,0];

lattice=({findElementClass[#],#1["LENGTH"],N[#["BENDANGLE"]],"",tilt[#1],#}&)/@elementList;

(*Print[lattice];*)

If[bends===True,findrotations=(
Switch[#[[1]],
"dipole",anglesum+=#1[[3]],
"quadrupole",anglesum+=0,
_,0]&/@Drop[Prepend[lattice,{0,0,0,"",0}],-1]),findrotations=Table[0.,{Length[lattice]}]];

cc={0,0,0};RM=IdentityMatrix[3];
prepositions=(
v=RotationMatrix[startangle,{0,0,1}].{#[[2]]*If[bends===True,sinc[#[[3]]],1],-#[[2]]*If[bends===True,cosc[#[[3]]],0],0};
rm=Switch[#[[1]],
"dipole",If[bends===True,RotationMatrix[Sign[#[[3]]]#[[5]],{1,1,1}].RotationMatrix[#[[3]],{0,0,1}],IdentityMatrix[3]],
_,IdentityMatrix[3]];
RM=RM.rm;
cc+=RM.v)&/@lattice;
prepositions2=prepositions[[All,{1,2}]];

Switch[Length[offset],
0,prepositions=(ReplacePart[#1,#1[[2]]+offset,2]&)/@prepositions2;,
2,prepositions=(ReplacePart[ReplacePart[#1,#1[[2]]+offset[[2]],2],#1[[1]]+offset[[1]],1]&)/@prepositions2,
_,prepositions=prepositions2;];
MapThread[Chop@Flatten[{##}]&,{prepositions,findrotations,lattice}]
]


(* ::Input::Initialization:: *)
ElementCoordinates[lattice_,opts___]:=Block[{},
Select[{#[[2,5]],Partition[#,2,1][[All,All,{1,2,3}]][[1]]}&/@Partition[Prepend[ElementPositions2[lattice,opts],{0,0,0}],2,1],Length[#]>0&]
]


(* ::Input::Initialization:: *)
Clear[elementSPositions]


(* ::Input::Initialization:: *)
elementSPositions[elementLine[list__]]:=Rest[FoldList[Plus,0,Map[#["LENGTH"]&,Flatten[elementLine[list]]]]]


(* ::Input::Initialization:: *)
Options[elementInfo]={Headings->{"Name","Type","Length","K1","Angle","Label","Position"}}


(* ::Input::Initialization:: *)
Clear[elementInfo];
elementInfo[lattice_elementLine,opts___Rule]:=Block[{headings=Headings/.{opts}/.Options[elementInfo]},
TableForm[Transpose[Map[Block[{heading=#},
Switch[ToUpperCase[#],
"POSITION",
elementSPositions[lattice],
"LENGTH",
Map[#["LENGTH"]&,Flatten[lattice]],
_,
Map[#[ToUpperCase[heading]]&,Flatten[lattice]]]]&,headings]],TableHeadings->{Automatic,headings}]]


(* ::Input::Initialization:: *)
allowedElegantCharacters:=(WordCharacter|DigitCharacter|"~"|"@"|"$"|"%"|"^"|"&"|"-"|"_"|"+"|"="|"{"|"}"|"["|"]"|"|"|"\\"|"/"|"?"|"<"|">"|"."|"\"")


(* ::Input::Initialization:: *)
joinSplitLines[records_]:=StringReplace[StringJoin[#],"&"->""]&/@Split[records,StringTake[StringTrim[#1],-1]=="&"&]


(* ::Input::Initialization:: *)
realNumberQ=StringMatchQ[#,StringExpression[(DigitCharacter|"+"|"-"|".")..]]&


(* ::Input::Initialization:: *)
exponentNumberQ=StringMatchQ[ToUpperCase[#],StringExpression[(DigitCharacter|"+"|"-"|"."|"E")..]]&


(* ::Input::Initialization:: *)
convertElementRules[string_String]:=string/.{"ANGLE"->"BENDANGLE","L"->"LENGTH"}


(* ::Input::Initialization:: *)
interpretElegantValues[string_String]:=
Which[
realNumberQ[string],
Internal`StringToDouble[string],
exponentNumberQ[string],
Internal`StringToDouble[string],
True,
string]


(* ::Input::Initialization:: *)
interpretElegantRules[string_String]:=Block[{},
allrules=StringSplit[string,{",",";","\n"}];
Sequence@@Flatten[StringCases[StringTrim[#],name:(WordCharacter|"_")..~~WhitespaceCharacter...~~"="~~WhitespaceCharacter...~~value:__:>Rule[convertElementRules[ToUpperCase@name],interpretElegantValues[value]]]&/@allrules]
]


(* ::Input::Initialization:: *)
interpretElegantLines[string_String,prefix_:""]:=Block[{},
allelements=StringSplit[string,{","}];
out=ToExpression[convertNames[Evaluate[prefix<>StringTrim[#]]]&/@allelements];
out
]


(* ::Input::Initialization:: *)
elementInterpretLTE[filename_,opts___Rule]:=Block[{records,verbose,prefix},
verbose=Global`elementVerbose/.{opts}/.{Global`elementVerbose->False};
prefix=Global`elementPrefix/.{opts}/.{Global`elementPrefix->""};
records=joinSplitLines[ReadList[filename,Record,RecordSeparators->"\n"]];
elements=
StringCases[#,elementName:allowedElegantCharacters..~~WhitespaceCharacter...~~":"~~WhitespaceCharacter...~~elementType:(LetterCharacter)..~~((","~~rest:___))...:>element["NAME"->Evaluate[convertNames[prefix<>elementName]],"TYPE"->elementType,interpretElegantRules[rest]],IgnoreCase->True]&/@records;
lines=StringCases[#,elementName:allowedElegantCharacters..~~WhitespaceCharacter...~~":"~~WhitespaceCharacter...~~"Line"~~WhitespaceCharacter...~~"="~~WhitespaceCharacter...~~"("~~WhitespaceCharacter...~~rest:__~~")"~~WhitespaceCharacter...:>(line[Evaluate[convertNames[Evaluate[prefix<>elementName]]],Evaluate[interpretElegantLines[rest,prefix]]]),IgnoreCase->True]&/@records;
If[verbose,
Print["New Elements:",Map[#["NAME"]&,Flatten[elements]]];
Print["New Lines:",Flatten[lines]];
]
]



