(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["MLC`MLC`",{"Madtomma`MADInput`MADInput`","Madtomma`Mfs`Mfs`","Madtomma`Mfs`MAD8Survey`","Notation`","Units`","PhysicalConstants`"}]


(* ::Input::Initialization:: *)
MLCExtraList::usage="";


(* ::Input::Initialization:: *)
MLCStripUnusedExtraFields::usage="";


(* ::Input::Initialization:: *)
MLCElementList::usage="";


(* ::Input::Initialization:: *)
MLCGetElementLengths::usage="";


(* ::Input::Initialization:: *)
MLCLinearThickWigglerMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearDriftMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearSextupoleMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearKickerMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearBPMMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearMarkerMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearThickQuadrupoleMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearThinQuadrupoleMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearWedgeBendMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearSolenoidMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearBeamRotationMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearPoleFaceRotationMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearSectorBendMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearRFCCavityMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearCavityMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearRSCavityMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearTRCavityMatrix::usage="";


(* ::Input::Initialization:: *)
MLCLinearMatrix::usage="";


(* ::Input::Initialization:: *)
MLCRMatrices::usage="";


(* ::Input::Initialization:: *)
MLCOneTurnRMatrix::usage="";


(* ::Input::Initialization:: *)
MLCStability::usage="";


(* ::Input::Initialization:: *)
MLCFindPeriodicPhase::usage="";


(* ::Input::Initialization:: *)
MLCFindPeriodicTwiss::usage="";


(* ::Input::Initialization:: *)
MLCFindPeriodicDispersion::usage="";


(* ::Input::Initialization:: *)
MLCTwissVectorToMatrix::usage="";


(* ::Input::Initialization:: *)
MLCTwissMatrixToVector::usage="";


(* ::Input::Initialization:: *)
MLCGenerateSinglePlaneRMatrices::usage="";


(* ::Input::Initialization:: *)
MLCPropagateTwissMatrix::usage="";


(* ::Input::Initialization:: *)
ReverseDot::usage="";


(* ::Input::Initialization:: *)
MLCCumulativeRMatrices::usage="";


(* ::Input::Initialization:: *)
MLCReverseCumulativeRMatrices::usage="";


(* ::Input::Initialization:: *)
MLCPropagateTwissPhaseVector::usage="";


(* ::Input::Initialization:: *)
MLCTwissOperator::usage="";


(* ::Input::Initialization:: *)
MLCPropagateTwiss::usage="";


(* ::Input::Initialization:: *)
MLCPropagateDispersion::usage="";


(* ::Input::Initialization:: *)
MLCGenerateTwissTable::usage="MLCGenerateTwissTable[Lattice,{\[Beta]x,\[Alpha]x,\[Gamma]x,\[Beta]y,\[Alpha]y,\[Gamma]y},{mux,muy},{\[Eta]x,\[Eta]x',\[Eta]y,\[Eta]y',0,1}]";


(* ::Input::Initialization:: *)
MLCGeneratePeriodicTwissTable::usage="MLCGeneratePeriodicTwissTable[Lattice]";


(* ::Input::Initialization:: *)
MLCGeneratePeriodicTwissTableNoOut::usage="";


(* ::Input::Initialization:: *)
MLCPropagateRay::usage="";


(* ::Input::Initialization:: *)
MLCTwissOperator::usage="";


(* ::Input::Initialization:: *)
MLCPropagateTwiss::usage="";


(* ::Input::Initialization:: *)
DotOperator::usage="";


(* ::Input::Initialization:: *)
MLCRetardNonParaxialRay::usage="";


(* ::Input::Initialization:: *)
MLCPropagateAndRetardOperator::usage="";


(* ::Input::Initialization:: *)
MLCPropagateNonParaxialRay::usage="";


(* ::Input::Initialization:: *)
MLCBetaGamma::usage="";


(* ::Input::Initialization:: *)
MLCGenerateBeamDistribution6D::usage="";


(* ::Input::Initialization:: *)
MLCPlot::usage="";


(* ::Input::Initialization:: *)
MLCPlotPeriodicOptics::usage="";


(* ::Input::Initialization:: *)
MLCMatrixInspect::usage="";


(* ::Input::Initialization:: *)
integralSRI1::usage="";


(* ::Input::Initialization:: *)
MLCSRI1::usage="";


(* ::Input::Initialization:: *)
SR2Element::usage="";


(* ::Input::Initialization:: *)
MLCSRI2::usage="";


(* ::Input::Initialization:: *)
SR3Element::usage="";


(* ::Input::Initialization:: *)
MLCSRI3::usage="";


(* ::Input::Initialization:: *)
integralSRI4::usage="";


(* ::Input::Initialization:: *)
MLCSRI4::usage="";


(* ::Input::Initialization:: *)
integralSRI5H::usage="";


(* ::Input::Initialization:: *)
MLCSRI5H::usage="";


(* ::Input::Initialization:: *)
MLCSRI5::usage="";


(* ::Input::Initialization:: *)
MLC\[Alpha]c::usage="";


(* ::Input::Initialization:: *)
MLC\[Epsilon]::usage="";


(* ::Input::Initialization:: *)
MLCSRI::usage="";


(* ::Input::Initialization:: *)
MLCU0::usage="";


(* ::Input::Initialization:: *)
MLCJx::usage="";


(* ::Input::Initialization:: *)
MLCJ\[Epsilon]::usage="";


(* ::Input::Initialization:: *)
MLCES::usage="";


(* ::Input::Initialization:: *)
MLC\[Tau]x::usage="";


(* ::Input::Initialization:: *)
MLC\[Tau]y::usage="";


(* ::Input::Initialization:: *)
MLC\[Tau]\[Epsilon]::usage="";


(* ::Input::Initialization:: *)
MLC\[Epsilon]x::usage="";


(* ::Input::Initialization:: *)
MLC\[Epsilon]y::usage="";


(* ::Input::Initialization:: *)
MLC\[Sigma]x::usage="";


(* ::Input::Initialization:: *)
MLC\[Sigma]y::usage="";


(* ::Input::Initialization:: *)
MLC\[Sigma]primex::usage="";


(* ::Input::Initialization:: *)
MLC\[Sigma]primey::usage="";


(* ::Input::Initialization:: *)
MLCChromaticity::usage="";


(* ::Input::Initialization:: *)
MLCGenerateR56::usage="";


(* ::Input::Initialization:: *)
MLCGenerateR51::usage="";


(* ::Input::Initialization:: *)
MLCGenerateR52::usage="";


(* ::Input::Initialization:: *)
MADReadRMatrices::usage="";


(* ::Input::Initialization:: *)
MADReadTMatrices::usage="";


(* ::Input::Initialization:: *)
MADGenerateRMatrices::usage="";


(* ::Input::Initialization:: *)
MLCTransportCompose::usage="";


(* ::Input::Initialization:: *)
MLCOneTurnRTMatrices::usage="";


(* ::Input::Initialization:: *)
MLCCumulativeRTMatrices::usage="";


(* ::Input::Initialization:: *)
MLCTransport::usage="";


(* ::Input::Initialization:: *)
MLCTransportCompose::usage="";


(* ::Input::Initialization:: *)
MLCOneTurnRTMatrices::usage="";


(* ::Input::Initialization:: *)
MLCCumulativeRTMatrices::usage="";


(* ::Input::Initialization:: *)
MLCTransport::usage="";


(* ::Input::Initialization:: *)
MLCElems::usage="";
MLCS::usage="";
MLCBETX::usage="";
MLCALFX::usage="";
MLCGAMX::usage="";
MLCBETY::usage="";
MLCALFY::usage="";
MLCGAMY::usage="";
MLCMUX::usage="";
MLCMUY::usage="";
MLCDX::usage="";
MLCDPX::usage="";
MLCDY::usage="";
MLCDPY::usage="";


(* ::Input::Initialization:: *)
MLCSetEnergy::usage="";


(* ::Input::Initialization:: *)
MLCGetEnergy::usage="";


(* ::Input::Initialization:: *)
MLCEnergy::usage="Global Energy within MLC";


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Input::Initialization:: *)
TruncatedGaussianSample[mean_,sigma_,n_]:=(
While[Abs[(a=RandomReal[NormalDistribution[mean,sigma]])-mean]>(n*sigma)];a)


(* ::Input::Initialization:: *)
TruncatedGaussianSample[mean_,0,n_]:=(
mean)


(* ::Input::Initialization:: *)
TruncatedGaussianSample[mean_,0.,n_]:=(
mean)


(* ::Input::Initialization:: *)
GaussianEnsemble[nparticles_,nmean_,nsigma_,ntruncation_]:=Table[TruncatedGaussianSample[nmean,nsigma,ntruncation],{nparticles}];


(* ::Input::Initialization:: *)
UniformEnsemble[nparticles_,nmin_,nmax_]:=Table[Random[UniformDistribution[nmin,nmax]],{nparticles}];


(* ::Input::Initialization:: *)
MLCExtraList[lattice_]:=ToExpression[(#<>"Extra")&/@(Transpose[MADFlatten[lattice]][[1]])]


(* ::Input::Initialization:: *)
MLCStripUnusedExtraFields[extralist_]:=Drop[#,2]&/@extralist


(* ::Input::Initialization:: *)
MLCElementList[lattice_]:=Join[#[[1]],#[[2]]]&/@Transpose[{MADFlatten[lattice],MLCStripUnusedExtraFields[MLCExtraList[lattice]]}]


(* ::Input::Initialization:: *)
MLCGetElementLengths[lattice_]:=(MADFlatten[lattice]//Transpose)[[3]]


(* ::Input::Initialization:: *)
MLCEnergy=0 Giga ElectronVolt;


(* ::Input::Initialization:: *)
MLCEnergy::ChangeEnergy="Energy Set from `1` to `2`"


(* ::Input::Initialization:: *)
MLCSetEnergy[energy_]:=Module[{},If[Energy>0,Message[MLCEnergy::ChangeEnergy,MLCEnergy,energy]];MLCEnergy=energy]


(* ::Input::Initialization:: *)
MLCGetEnergy[]:=MLCEnergy


(* ::Input::Initialization:: *)
MLCLinearDriftMatrix[elem_,\[Gamma]_:Infinity]:=Module[{L,\[Beta]},L=elem[[3]];\[Beta]=Sqrt[1-1/\[Gamma]^2];
\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", "L", "0", "0", "0", "0"},
{"0", "1", "0", "0", "0", "0"},
{"0", "0", "1", "L", "0", "0"},
{"0", "0", "0", "1", "0", "0"},
{"0", "0", "0", "0", "1", 
FractionBox["L", 
RowBox[{
SuperscriptBox["\[Beta]", "2"], 
SuperscriptBox["\[Gamma]", "2"]}]]},
{"0", "0", "0", "0", "0", "1"}
}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\)]


(* ::Input::Initialization:: *)
MLCLinearSextupoleMatrix[elem_,\[Gamma]_:Infinity]:=MLCLinearDriftMatrix[elem,\[Gamma]]


(* ::Input::Initialization:: *)
MLCLinearKickerMatrix[elem_,\[Gamma]_:Infinity]:=MLCLinearDriftMatrix[elem,\[Gamma]]


(* ::Input::Initialization:: *)
MLCLinearBPMMatrix[elem_,\[Gamma]_:Infinity]:=MLCLinearDriftMatrix[elem,\[Gamma]]


(* ::Input::Initialization:: *)
MLCLinearMarkerMatrix[elem_,\[Gamma]_:Infinity]:=IdentityMatrix[6]


(* ::Input::Initialization:: *)
MLCLinearMultipoleMatrix[elem_,\[Gamma]_:Infinity]:=If[Abs[elem[[13]]]>0,Module[{k,f},k=Abs[elem[[13]]] ;f=-1/k ;
{{1,0,0,0,0,0},{Sign[elem[[13]]] 1/f,1,0,0,0,0},{0,0,1,0,0,0},{0,0,-Sign[elem[[13]]]/f,1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}}],IdentityMatrix[6]]


(* ::Input::Initialization:: *)
MLCLinearThickWigglerMatrix[elem_,\[Gamma]_:Infinity]:=Module[{L,k,\[Beta]},L=elem[[3]];k=Sqrt[elem[[4]]];\[Beta]=Sqrt[1-1/\[Gamma]^2];
Which[elem[[4]]=!=0,k=Sqrt[elem[[4]]];
{
 {1, L, 0, 0, 0, 0},
 {0, 1, 0, 0, 0, 0},
 {0, 0, Cosh[k L], Sinh[k L]/k, 0, 0},
 {0, 0, k Sinh[k L], Cosh[k L], 0, 0},
 {0, 0, 0, 0, 1, L/(\[Beta]^2 \[Gamma]^2)},
 {0, 0, 0, 0, 0, 1}
},elem[[4]]===0,\!\(\*
TagBox[
RowBox[{"MLCLinearDriftMatrix", "[", 
RowBox[{"elem", ",", "\[Gamma]"}], "]"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\)]]


(* ::Input::Initialization:: *)
MLCLinearThickQuadrupoleMatrix[elem_,\[Gamma]_:Infinity]:=Module[{L,k,\[Beta]},L=elem[[3]];k=Sqrt[elem[[4]]];\[Beta]=Sqrt[1-1/\[Gamma]^2];
Which[Positive[elem[[4]]],
k=Sqrt[elem[[4]]];
{{Cos[k L], Sin[k L]/k, 0, 0, 0, 0}, {-k Sin[k L], Cos[k L], 0, 0, 0, 0}, {0, 0, Cosh[k L], Sinh[k L]/k, 0, 0}, {0, 0, k Sinh[k L], Cosh[k L], 0, 0}, {0, 0, 0, 0, 1, L/(\[Beta]^2 \[Gamma]^2)}, {0, 0, 0, 0, 0, 1}},
Negative[elem[[4]]],
k=Sqrt[-elem[[4]]];
{ {Cosh[k L], Sinh[k L]/k, 0, 0, 0, 0}, {k Sinh[k L], Cosh[k L], 0, 0, 0, 0}, {0, 0, Cos[k L], Sin[k L]/k, 0, 0}, {0, 0, -k Sin[k L], Cos[k L], 0, 0}, {0, 0, 0, 0, 1, L/(\[Beta]^2 \[Gamma]^2)}, {0, 0, 0, 0, 0, 1}},
True,MLCLinearDriftMatrix[elem,\[Gamma]]]]


(* ::Input::Initialization:: *)
MLCLinearThinQuadrupoleMatrix[elem_]:=Module[{L,k},L=elem[[3]];k=Sqrt[Abs[elem[[4]]]];{{1,0,0,0,0,0},{If[Positive[elem[[4]]],-k Sin[k L],k Sinh[k L]],1,0,0,0,0},{0,0,1,0,0,0},{0,0,If[k>0,k Sinh[k L],-k Sin[k L]],1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}}]


(* ::Input::Initialization:: *)
MLCLinearWedgeBendMatrix[elem_,\[Gamma]_:Infinity]:=Module[{L,kx,ky,\[Rho], h, n,\[Beta]},L=elem[[3]];\[Rho]=L/elem[[6]];n=-elem[[4]] \[Rho]^2;h=1/\[Rho];kx=h Sqrt[1-n];ky=h Sqrt[n];\[Beta]=Sqrt[1-1/\[Gamma]^2];
\!\(\*
TagBox[
RowBox[{"{", 
RowBox[{
RowBox[{"{", 
RowBox[{
RowBox[{"Cos", "[", 
RowBox[{"kx", " ", "L"}], "]"}], ",", 
RowBox[{"If", "[", 
RowBox[{
RowBox[{"kx", "==", "0"}], ",", "L", ",", 
FractionBox[
RowBox[{"Sin", "[", 
RowBox[{"kx", " ", "L"}], "]"}], "kx"]}], "]"}], ",", "0", ",", "0", ",", "0", ",", 
RowBox[{"If", "[", 
RowBox[{
RowBox[{"kx", "==", "0"}], ",", 
FractionBox[
RowBox[{"h", " ", 
SuperscriptBox["L", "2"]}], 
RowBox[{"2", " ", "\[Beta]"}]], ",", 
FractionBox[
RowBox[{"h", " ", 
RowBox[{"(", 
RowBox[{"1", "-", 
RowBox[{"Cos", "[", 
RowBox[{"kx", " ", "L"}], "]"}]}], ")"}]}], 
RowBox[{"\[Beta]", " ", 
SuperscriptBox["kx", "2"]}]]}], "]"}]}], "}"}], ",", 
RowBox[{"{", 
RowBox[{
RowBox[{
RowBox[{"-", "kx"}], " ", 
RowBox[{"Sin", "[", 
RowBox[{"kx", " ", "L"}], "]"}]}], ",", 
RowBox[{"Cos", "[", 
RowBox[{"kx", " ", "L"}], "]"}], ",", "0", ",", "0", ",", "0", ",", 
RowBox[{"If", "[", 
RowBox[{
RowBox[{"kx", "==", "0"}], ",", 
FractionBox[
RowBox[{"h", " ", "L"}], "\[Beta]"], ",", 
FractionBox[
RowBox[{"h", " ", 
RowBox[{"Sin", "[", 
RowBox[{"kx", " ", "L"}], "]"}]}], 
RowBox[{"\[Beta]", " ", "kx"}]]}], "]"}]}], "}"}], ",", 
RowBox[{"{", 
RowBox[{"0", ",", "0", ",", 
RowBox[{"Cos", "[", 
RowBox[{"ky", " ", "L"}], "]"}], ",", 
RowBox[{"If", "[", 
RowBox[{
RowBox[{"ky", "==", "0"}], ",", "L", ",", 
FractionBox[
RowBox[{"Sin", "[", 
RowBox[{"ky", " ", "L"}], "]"}], "ky"]}], "]"}], ",", "0", ",", "0"}], "}"}], ",", 
RowBox[{"{", 
RowBox[{"0", ",", "0", ",", 
RowBox[{
RowBox[{"-", "ky"}], " ", 
RowBox[{"Sin", "[", 
RowBox[{"ky", " ", "L"}], "]"}]}], ",", 
RowBox[{"Cos", "[", 
RowBox[{"ky", " ", "L"}], "]"}], ",", "0", ",", "0"}], "}"}], ",", 
RowBox[{"{", 
RowBox[{
RowBox[{"If", "[", 
RowBox[{
RowBox[{"kx", "==", "0"}], ",", 
RowBox[{"-", 
FractionBox[
RowBox[{"h", " ", "L"}], "\[Beta]"]}], ",", 
RowBox[{"-", 
FractionBox[
RowBox[{"h", " ", 
RowBox[{"Sin", "[", 
RowBox[{"kx", " ", "L"}], "]"}]}], 
RowBox[{"\[Beta]", " ", "kx"}]]}]}], "]"}], ",", 
RowBox[{"If", "[", 
RowBox[{
RowBox[{"kx", "==", "0"}], ",", 
RowBox[{"-", 
FractionBox[
RowBox[{"h", " ", 
SuperscriptBox["L", "2"]}], 
RowBox[{"2", " ", "\[Beta]"}]]}], ",", 
RowBox[{"-", 
FractionBox[
RowBox[{"h", " ", 
RowBox[{"(", 
RowBox[{"1", "-", 
RowBox[{"Cos", "[", 
RowBox[{"kx", " ", "L"}], "]"}]}], ")"}]}], 
RowBox[{"\[Beta]", " ", 
SuperscriptBox["kx", "2"]}]]}]}], "]"}], ",", "0", ",", "0", ",", "1", ",", 
RowBox[{"If", "[", 
RowBox[{
RowBox[{"kx", "==", "0"}], ",", 
RowBox[{
FractionBox["L", 
RowBox[{
SuperscriptBox["\[Beta]", "2"], " ", 
SuperscriptBox["\[Gamma]", "2"]}]], "-", 
FractionBox[
RowBox[{
SuperscriptBox["h", "2"], " ", 
SuperscriptBox["L", "3"]}], 
RowBox[{"6", " ", 
SuperscriptBox["\[Beta]", "2"]}]]}], ",", 
RowBox[{
FractionBox["L", 
RowBox[{
SuperscriptBox["\[Beta]", "2"], " ", 
SuperscriptBox["\[Gamma]", "2"]}]], "-", 
FractionBox[
RowBox[{
SuperscriptBox["h", "2"], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"kx", " ", "L"}], "-", 
RowBox[{"Sin", "[", 
RowBox[{"kx", " ", "L"}], "]"}]}], ")"}]}], 
RowBox[{
SuperscriptBox["\[Beta]", "2"], " ", 
SuperscriptBox["kx", "3"]}]]}]}], "]"}]}], "}"}], ",", 
RowBox[{"{", 
RowBox[{"0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1"}], "}"}]}], "}"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\)]


(* ::Input::Initialization:: *)
MLCLinearSolenoidMatrix[elem_]:=Module[{L,K,Cval,Sval},L=elem[[1]];K=elem[[2]];Cval=Cos [K L];Sval=Sin[K L];
{{Cval,Sval/K,0,0,0,0},{-K Sval,Cval,0,0,0,0},{0,0,Cval,Sval/K,0,0},{0,0,-K Sval,Cval,0,0},{0,0,0,0,1,0},{0,0,0,0,1,1}}]


(* ::Input::Initialization:: *)
MLCLinearBeamRotationMatrix[\[Alpha]_]:={{Cos[\[Alpha]],0,Sin[\[Alpha]],0,0,0},{0,Cos[\[Alpha]],0,Sin[\[Alpha]],0,0},{-Sin[\[Alpha]],0,Cos[\[Alpha]],0,0,0},{0,-Sin[\[Alpha]],0,Cos[\[Alpha]],0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}}


(* ::Input::Initialization:: *)
MLCLinearPoleFaceRotationMatrix[\[Beta]_,\[Rho]_,k_,gap_]:=Module[{\[CurlyPhi],h},h=1/\[Rho];\[CurlyPhi]=k h gap (1+Sin[\[Beta]]^2)/Cos[\[Beta]];{{1,0,0,0,0,0},{h Tan[\[Beta]],1,0,0,0,0},{0,0,1,0,0,0},{0,0,-h Tan[\[Beta]-\[CurlyPhi]],1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}}]


(* ::Input::Initialization:: *)
MLCLinearSectorBendMatrix[elem_,\[Gamma]_:Infinity]:=Module[{beta1,beta2,L,\[Rho],k,gap,\[Beta]},L=elem[[3]];k=elem[[4]];beta1=elem[[10]];beta2=elem[[11]];\[Beta]=Sqrt[1-1/\[Gamma]^2];
If[Abs[elem[[6]]]>0,\[Rho]=L/elem[[6]];Chop[MLCLinearPoleFaceRotationMatrix[beta2,\[Rho],k,0.0].MLCLinearWedgeBendMatrix[elem,\[Gamma]].MLCLinearPoleFaceRotationMatrix[beta1,\[Rho],k,0.0]],MLCLinearDriftMatrix[elem,\[Gamma]]]]


(* ::Input::Initialization:: *)
MLCLinearRectBendMatrix[elem_,\[Gamma]_:Infinity]:=Module[{beta1,beta2,L,\[Rho],k,gap,\[Beta]},L=elem[[3]];k=elem[[4]];beta1=elem[[10]]+elem[[6]]/2.809;beta2=elem[[11]]+elem[[6]]/2.809;\[Beta]=Sqrt[1-1/\[Gamma]^2];
If[Abs[elem[[6]]]>0,\[Rho]=L/elem[[6]];Chop[MLCLinearPoleFaceRotationMatrix[beta2,\[Rho],k,0.0].MLCLinearWedgeBendMatrix[elem,\[Gamma]].MLCLinearPoleFaceRotationMatrix[beta1,\[Rho],k,0.0]],MLCLinearDriftMatrix[elem,\[Gamma]]]]


(* ::Input::Initialization:: *)
MLCLinearRFCCavityMatrix[elem_]:=Module[{L,dE,\[Phi],\[Lambda],E0},Print["1"];L=elem[[3]];dE=elem[[10]];\[Phi]=elem[[11]];\[Lambda]=elem[[12]];E0=elem[[14]];
\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", 
RowBox[{"If", "[", 
RowBox[{
RowBox[{"dE", "==", "0"}], ",", "L", ",", 
RowBox[{"L", 
FractionBox["E0", 
RowBox[{"dE", "  ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]], 
RowBox[{"Log", "[", 
RowBox[{"1", "+", 
FractionBox[
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}], "E0"]}], "]"}]}]}], "]"}], "0", "0", "0", "0"},
{"0", 
FractionBox["E0", 
RowBox[{"E0", "+", 
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]}]], "0", "0", "0", "0"},
{"0", "0", "1", 
RowBox[{"If", "[", 
RowBox[{
RowBox[{"dE", "==", "0"}], ",", "L", ",", 
RowBox[{"L", 
FractionBox["E0", 
RowBox[{"dE", "  ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]], 
RowBox[{"Log", "[", 
RowBox[{"1", "+", 
FractionBox[
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}], "E0"]}], "]"}]}]}], "]"}], "0", "0"},
{"0", "0", "0", 
FractionBox["E0", 
RowBox[{"E0", "+", 
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]}]], "0", "0"},
{"0", "0", "0", "0", "1", "0"},
{"0", "0", "0", "0", 
RowBox[{
FractionBox[
RowBox[{"dE", " ", 
RowBox[{"Sin", "[", "\[Phi]", "]"}]}], 
RowBox[{"E0", "+", 
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]}]], 
FractionBox[
RowBox[{"2", "\[Pi]"}], "\[Lambda]"]}], 
FractionBox["E0", 
RowBox[{"E0", "+", 
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]}]]}
}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\)]


(* ::Code::Initialization:: *)
MLCLinearCavityMatrix[elem_]:=Module[{L,dE,\[Phi],\[Lambda],E0},Print["2"];L=elem[[3]];dE=elem[[10]];\[Phi]=elem[[11]];\[Lambda]=(2.99792458 10^2)/elem[[12]];E0=elem[[20]];
\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", 
RowBox[{"If", "[", 
RowBox[{
RowBox[{"dE", "==", "0"}], ",", "L", ",", 
RowBox[{"L", 
FractionBox["E0", 
RowBox[{"dE", "  ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]], 
RowBox[{"Log", "[", 
RowBox[{"1", "+", 
FractionBox[
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}], "E0"]}], "]"}]}]}], "]"}], "0", "0", "0", "0"},
{"0", 
FractionBox["E0", 
RowBox[{"E0", "+", 
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]}]], "0", "0", "0", "0"},
{"0", "0", "1", 
RowBox[{"If", "[", 
RowBox[{
RowBox[{"dE", "==", "0"}], ",", "L", ",", 
RowBox[{"L", 
FractionBox["E0", 
RowBox[{"dE", "  ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]], 
RowBox[{"Log", "[", 
RowBox[{"1", "+", 
FractionBox[
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}], "E0"]}], "]"}]}]}], "]"}], "0", "0"},
{"0", "0", "0", 
FractionBox["E0", 
RowBox[{"E0", "+", 
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]}]], "0", "0"},
{"0", "0", "0", "0", "1", "0"},
{"0", "0", "0", "0", 
RowBox[{
FractionBox[
RowBox[{"dE", " ", 
RowBox[{"Sin", "[", "\[Phi]", "]"}]}], 
RowBox[{"E0", "+", 
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]}]], 
FractionBox[
RowBox[{"2", "\[Pi]"}], "\[Lambda]"]}], 
FractionBox["E0", 
RowBox[{"E0", "+", 
RowBox[{"dE", " ", 
RowBox[{"Cos", "[", "\[Phi]", "]"}]}]}]]}
}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\)]


(* ::Input::Initialization:: *)
MLCLinearRSCavityMatrix[elem_]:=Module[{L,dE,\[Phi],\[Lambda],E0,\[Alpha],\[Gamma]p,\[Gamma]f,\[Gamma]i,\[Eta]},L=elem[[3]];dE=elem[[3]]elem[[10]]/1;\[Phi]=elem[[11]];\[Lambda]=(2.99792458 10^2)/elem[[12]];
E0=If[elem[[21]]>0,elem[[21]],MLCEnergy];MLCSetEnergy[E0+dE Cos[\[Phi]]];
\[Gamma]p=(dE Cos[\[Phi]]);\[Gamma]i=E0;\[Gamma]f=E0+dE Cos[\[Phi]];
\[Alpha]=Sqrt[\[Eta][\[Phi]]/8]/Cos[\[Phi]] Log[\[Gamma]f/\[Gamma]i];\[Eta][\[Phi]]=1;
If[dE==0,MLCLinearDriftMatrix[elem],
({
 {Cos[\[Alpha]]-(2/\[Eta][\[Phi]])^(1/2) Cos[\[Phi]]Sin[\[Alpha]],(Sqrt[8]/\[Eta][\[Phi]])^(1/2) \[Gamma]i/\[Gamma]p Cos[\[Phi]]Sin[\[Alpha]], 0, 0, 0, 0},
 {-\[Gamma]p/\[Gamma]i(Cos[\[Phi]]/Sqrt[2\[Eta][\[Phi]]]+(\[Eta][\[Phi]]/8)^(1/2) 1/Cos[\[Phi]])Sin[\[Alpha]], \[Gamma]i/\[Gamma]f (Cos[\[Alpha]]+Sqrt[2/\[Eta][\[Phi]]]Cos[\[Phi]]Sin[\[Alpha]]), 0, 0, 0, 0},
 {0, 0, Cos[\[Alpha]]-(2/\[Eta][\[Phi]])^(1/2) Cos[\[Phi]]Sin[\[Alpha]], (Sqrt[8]/\[Eta][\[Phi]])^(1/2) \[Gamma]i/\[Gamma]p Cos[\[Phi]]Sin[\[Alpha]], 0, 0},
 {0, 0, -\[Gamma]p/\[Gamma]i(Cos[\[Phi]]/Sqrt[2\[Eta][\[Phi]]]+(\[Eta][\[Phi]]/8)^(1/2) 1/Cos[\[Phi]])Sin[\[Alpha]], \[Gamma]i/\[Gamma]f (Cos[\[Alpha]]+Sqrt[2/\[Eta][\[Phi]]]Cos[\[Phi]]Sin[\[Alpha]]), 0, 0},
 {0, 0, 0, 0, 1, 0},
 {0, 0, 0, 0, (dE Sin[\[Phi]])/(E0+dE Cos[\[Phi]]) (2\[Pi])/\[Lambda], E0/(E0+dE Cos[\[Phi]])}
})]]


(* ::Input::Initialization:: *)
MLCLinearMADCavityMatrix[elem_]:=Module[{ENER,ENERGY,EL=elem[[3]],DELTAE=elem[[10]],PHI0=elem[[11]],FREQ=elem[[12]],ELOSS=elem[[13]],VOLTERR=elem[[14]],ALAGERR=elem[[15]],VRF,OMEGA,CLIGHT=2.99792458 10^8,PHIRF,DELTAS=0,DENERGY,AMASS=0.000511,PC,GAMMA,BETA,ETAS,GAMMAS,BETAS,FACT,RE,RW},
ENER=ENERGY=If[elem[[21]]>0,elem[[21]],MLCEnergy];
VRF=10^-3*DELTAE;
VOLTERR=10^-3*VOLTERR;
ELOSS=10^-3*ELOSS;
OMEGA=2\[Pi]*(10^6*FREQ)/CLIGHT;
PHIRF=2\[Pi]*PHI0;
ALAGERR=2\[Pi]*ALAGERR;
DENERGY=VRF*Cos[PHIRF];
MLCSetEnergy[DENERGY+ENERGY];
PC=Sqrt[(Abs@(ENERGY^2-AMASS^2))];
GAMMA=ENERGY/AMASS;
BETA=PC/ENERGY;
ETAS=BETA*GAMMA*(1+DELTAS);
GAMMAS=Sqrt[(1+ETAS^2)];
BETAS=ETAS/GAMMAS;

RE=IdentityMatrix[6];
RE[[6,5]]=OMEGA*VRF*Sin[PHIRF]/(ENER+DENERGY)/(1+DELTAS);
RE[[2,2]]=ENER/(ENER+DENERGY);
RE[[4,4]]=ENER/(ENER+DENERGY);
RE[[6,6]]=ENER/(ENER+DENERGY);
If[Abs@(DENERGY/ENER)<0 ,FACT=1-1/2*DENERGY/ENER,FACT=ENER/DENERGY*Log[1+DENERGY/ENER]];
RE[[1,2]]=EL*FACT;
RE[[3,4]]=EL*FACT;
RE[[5,6]]=EL/(BETAS*GAMMAS)^2;
RW=IdentityMatrix[6];
RW[[2,1]]=-DENERGY/EL/2/ENERGY;
RW[[4,3]]=RW[[2,1]];
RE=RE.RW;
RW[[2,1]]=+DENERGY/EL/2/(ENERGY+DENERGY);
RW[[4,3]]=RW[[2,1]];
RE=RW.RE;
(*
TE=Table[Table[0,{i,1,6},{j,1,6}],{6}];
TE[[6,5,5]]=-OMEGA^2*VRF*Cos[PHIRF]/2/(ENER+DENERGY)/(1+DELTAS);
TE[[1,2,6]]=-EL/(2*BETA);
TE[[1,6,2]]=TE[[1,2,6]];
TE[[3,4,6]]=TE[[1,2,6]];
TE[[3,6,4]]=TE[[3,4,6]];
TE[[5,2,2]]=TE[[1,2,6]];
TE[[5,4,4]]=TE[[5,2,2]];
TE[[5,6,6]]=TE[[1,2,6]]*3/(BETAS*GAMMAS)^2;*)
RE
]


(* ::Input::Initialization:: *)
Notation[\!\(\*
TagBox[
SubscriptBox["m", "SI"],
"NotationTemplateTag",
BaseStyle->"NotationTemplateStyle"]\) \[DoubleLongLeftRightArrow] \!\(\*
TagBox["msi",
"NotationTemplateTag",
BaseStyle->"NotationTemplateStyle"]\)];Notation[\!\(\*
TagBox[
SubscriptBox["c", "SI"],
"NotationTemplateTag",
BaseStyle->"NotationTemplateStyle"]\) \[DoubleLongLeftRightArrow] \!\(\*
TagBox["csi",
"NotationTemplateTag",
BaseStyle->"NotationTemplateStyle"]\)]


(* ::Input::Initialization:: *)
Subscript[m, SI]=N[ElectronMass]/Kilogram


(* ::Input::Initialization:: *)
Subscript[c, SI]=N[SpeedOfLight]/(Meter/Second)


(* ::Input::Initialization:: *)
MLCLinearTRCavityMatrix[elem_]:=Module[{L,dE,\[Phi],\[Lambda],E0,\[Alpha]1,\[Alpha]2,Q,QL,I\[Eta],\[Delta]\[Gamma],\[Gamma]prime,\[Eta]i,\[Eta]f,\[Eta]iprime,\[Eta]fprime,vi,vf,\[Beta]i,\[Beta]f,\[Gamma]i,\[Gamma]f,R11,R12,R21,R22,R55,R56,R65,R66},L=elem[[3]];dE=elem[[10]];\[Phi]=elem[[11]];\[Lambda]=(2.99792458 10^2)/elem[[12]];E0=elem[[20]];
Emev=Convert[N[ElectronMass SpeedOfLight^2/(ElectronVolt Mega)],1];
Q=(dE Sin[\[Phi]])/L \[Pi]/\[Lambda] 1/Emev;
QL=2Q;
\[Gamma]i=E0/Emev;\[Gamma]f=(E0+dE Cos[\[Phi]])/Emev;
\[Delta]\[Gamma]=\[Gamma]f-\[Gamma]i;\[Gamma]prime=\[Delta]\[Gamma]/L;
\[Beta]i=Sqrt[1-1/\[Gamma]i^2];\[Beta]f=Sqrt[1-1/\[Gamma]f^2];
\[Eta]i=\[Beta]i \[Gamma]i;\[Eta]f=\[Beta]f \[Gamma]f;
\[Eta]iprime=\[Gamma]i/\[Eta]i \[Gamma]prime;\[Eta]fprime=\[Gamma]f/\[Gamma]f \[Gamma]prime;
I\[Eta]=1/(\[Eta]i^(3/2) \[Gamma]f) (\[Delta]\[Gamma]-3/4 \[Gamma]i/\[Eta]i^2 \[Delta]\[Gamma]^2-\[Delta]\[Gamma]^3/(4\[Eta]i^2)+7/8 (\[Gamma]i^2 \[Delta]\[Gamma]^3)/\[Eta]i^4);\[Alpha]1=Sqrt[Q]I\[Eta];\[Alpha]2=Sqrt[QL]I\[Eta];
R11=(\[Eta]f/\[Eta]i)^(1/4) Cosh[\[Alpha]1]-1/4 \[Eta]iprime/\[Eta]i \[Eta]i^(2/3)/Sqrt[Q] (\[Eta]f/\[Eta]i)^(1/4) Sinh[\[Alpha]1];
R12=\[Eta]i^(2/3)/Sqrt[Q] (\[Eta]f/\[Eta]i)^(1/4) Sinh[\[Alpha]1];
R21=1/4 (\[Eta]fprime/(\[Eta]f^(3/4) \[Eta]i^(1/4))-(\[Eta]iprime \[Eta]i^(1/4))/\[Eta]f^(5/4))Cosh[\[Alpha]1]+((\[Eta]f/\[Eta]i)^(1/4) Sqrt[Q]/\[Eta]f^(3/2)-1/16 (\[Eta]fprime \[Eta]iprime \[Eta]i^(1/4))/(\[Eta]f^(3/4) Sqrt[Q]))Sinh[\[Alpha]1];
R22=1/4 \[Eta]i^(3/2)/Sqrt[Q] \[Eta]fprime/(\[Eta]f^(3/4) \[Eta]i^(1/4)) Sinh[\[Alpha]1]+(\[Eta]i/\[Eta]f)^(5/4) Cosh[\[Alpha]1];
R55=\[Beta]f/\[Beta]i (\[Eta]i/\[Eta]f)^(3/4) (Cosh[\[Alpha]2]+3/4 (\[Eta]fprime \[Eta]f^(1/2))/Sqrt[QL] Sinh[\[Alpha]2]);
R56=-(\[Beta]f \[Lambda])/(2\[Pi])L/(dE Sin[\[Phi]]) (3/4 ((\[Eta]i/\[Eta]f)^(1/4) \[Eta]fprime-(\[Eta]i/\[Eta]f)^(3/4) \[Eta]iprime)\[Beta]i Cos[\[Alpha]2]-(9/16 (\[Eta]iprime \[Eta]fprime)/(\[Eta]f^(1/4) \[Eta]i^(1/4)) \[Eta]i/Sqrt[QL]+(\[Eta]i/\[Eta]f)^(1/4) Sqrt[QL]/\[Eta]f^(1/2))\[Beta]i Sin[\[Alpha]2]);
R65=\[Eta]i^(3/4)/(\[Eta]f^(1/4) \[Beta]i \[Beta]f) Sqrt[QL]Sin[\[Alpha]2];
R66=(\[Eta]i/\[Eta]f)^(1/4) \[Beta]i/\[Beta]f (Cos[\[Alpha]2]-3/4 (\[Eta]i^(1/2) \[Eta]iprime)/Sqrt[QL] Sin[\[Alpha]2]);

If[dE==0,MLCLinearDriftMatrix[elem],
\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"R11", "R12", "0", "0", "0", "0"},
{"R21", "R22", "0", "0", "0", "0"},
{"0", "0", "R11", "R12", "0", "0"},
{"0", "0", "R21", "R22", "0", "0"},
{"0", "0", "0", "0", "R55", "R56"},
{"0", "0", "0", "0", "R65", "R66"}
}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\)]]


(* ::Input::Initialization:: *)
MLCLinearMatrix[elem_,\[Gamma]_:Infinity]:=Switch[elem[[2]],
"Drift",MLCLinearDriftMatrix[elem,\[Gamma]],
"Quadrupole",MLCLinearThickQuadrupoleMatrix[elem,\[Gamma]],
"Sextupole",MLCLinearSextupoleMatrix[elem,\[Gamma]],
"Octupole",MLCLinearDriftMatrix[elem,\[Gamma]],
"SectorBend",MLCLinearSectorBendMatrix[elem,\[Gamma]],
"RectBend",MLCLinearRectBendMatrix[elem,\[Gamma]],
"Marker",MLCLinearMarkerMatrix[elem,\[Gamma]],
"MULTIPOLE",MLCLinearMultipoleMatrix[elem,\[Gamma]],
"BPM",MLCLinearBPMMatrix[elem,\[Gamma]],
"Monitor",MLCLinearBPMMatrix[elem,\[Gamma]],
"IMonitor",MLCLinearBPMMatrix[elem,\[Gamma]],
"Profile",MLCLinearBPMMatrix[elem,\[Gamma]],
"Wire",MLCLinearBPMMatrix[elem,\[Gamma]],
"Kicker",MLCLinearKickerMatrix[elem,\[Gamma]],
"HKicker",MLCLinearKickerMatrix[elem,\[Gamma]],
"VKicker",MLCLinearKickerMatrix[elem,\[Gamma]],
"RFC",MLCLinearRFCCavityMatrix[elem],
"LCAV",MLCLinearRSCavityMatrix[elem],
"WIGGLER",MLCLinearThickWigglerMatrix[elem],
_,MLCLinearDriftMatrix[elem,\[Gamma]]]


(* ::Input::Initialization:: *)
MLCRMatrices[lattice_, \[Gamma]_:Infinity] := (MLCLinearMatrix[#1, \[Gamma]] & ) /@ MLCElementList[lattice]


(* ::Input::Initialization:: *)
MLCOneTurnRMatrix[rmatrices_]:=Dot@@Reverse[rmatrices]


(* ::Input::Initialization:: *)
MLCStability[oneturnmatrix_]:={If[Abs[oneturnmatrix[[1,1]]+oneturnmatrix[[2,2]]]<2,True,False],If[Abs[oneturnmatrix[[3,3]]+oneturnmatrix[[4,4]]]<2,True,False]}


(* ::Input::Initialization:: *)
MLCFindPeriodicPhase[M_]:={ArcCos[(M[[1,1]]+M[[2,2]])/2],ArcCos[(M[[3,3]]+M[[4,4]])/2]}


(* ::Input::Initialization:: *)
MLCFindPeriodicTwiss[M_]:=Module[{\[Beta]x,\[Alpha]x,\[Gamma]x,\[Beta]y,\[Alpha]y,\[Gamma]y,\[Mu]x,\[Mu]y},{\[Mu]x,\[Mu]y}=MLCFindPeriodicPhase[M];\[Beta]x=M[[1,2]]/Sin[\[Mu]x];\[Alpha]x=(M[[1,1]]-M[[2,2]])/(2 Sin[\[Mu]x]);\[Gamma]x=(1+\[Alpha]x^2)/\[Beta]x;\[Beta]y=M[[3,4]]/Sin[\[Mu]y];\[Alpha]y=(M[[3,3]]-M[[4,4]])/(2 Sin[\[Mu]y]);\[Gamma]y=(1+\[Alpha]y^2)/\[Beta]y;{{Abs[\[Beta]x],Sign[M[[1,2]]]\[Alpha]x,Sign[\[Beta]x]\[Gamma]x},{Abs[\[Beta]y],Sign[M[[3,4]]]\[Alpha]y,Sign[\[Beta]y]\[Gamma]y}}]


(* ::Input::Initialization:: *)
MLCFindPeriodicDispersion[M_]:={((1-M[[2,2]])M[[1,6]]+M[[1,2]] M[[2,6]])/((1-M[[1,1]])(1-M[[2,2]])-M[[2,1]]M[[1,2]]),((1- M[[1,1]])M[[2,6]]+M[[2,1]]M[[1,6]])/((1-M[[1,1]])(1-M[[2,2]])-M[[2,1]]M[[1,2]]),((1-M[[4,4]])M[[3,6]]+M[[3,4]] M[[4,6]])/((1-M[[3,3]])(1-M[[4,4]])-M[[4,3]]M[[3,4]]),((1- M[[3,3]])M[[4,6]]+M[[4,3]]M[[3,6]])/((1-M[[3,3]])(1-M[[4,4]])-M[[4,3]]M[[3,4]]),0,1}


(* ::Input::Initialization:: *)
MLCTwissVectorToMatrix[V_]:={{V[[1]],-V[[2]]},{-V[[2]],V[[3]]}}


(* ::Input::Initialization:: *)
MLCTwissMatrixToVector[T_]:={T[[1,1]],-T[[1,2]],T[[2,2]]}


(* ::Input::Initialization:: *)
MLCGenerateSinglePlaneRMatrices[M_]:={{{M[[1,1]],M[[1,2]]},{M[[2,1]],M[[2,2]]}},{{M[[3,3]],M[[3,4]]},{M[[4,3]],M[[4,4]]}}}


(* ::Input::Initialization:: *)
MLCPropagateTwissMatrix[T_,R_]:=R.T.Transpose[R]


(* ::Input::Initialization:: *)
ReverseDot[a_,b_]:=Dot[b,a]


(* ::Input::Initialization:: *)
MLCCumulativeRMatrices[rmatrices_]:=FoldList[ReverseDot,IdentityMatrix[6],rmatrices]


(* ::Input::Initialization:: *)
MLCTransportCompose[{RA_,TA_},{RB_,TB_}]:={RB.RA,RB.TA+Transpose[Expand[Transpose[RA].Transpose[TB].RA]]}


(* ::Input::Initialization:: *)
MLCOneTurnRTMatrices[rmatrices_,tmatrices_]:=Fold[MLCTransportCompose,First[#],Rest[#]]&[Transpose[{rmatrices,tmatrices}]]


(* ::Input::Initialization:: *)
MLCCumulativeRTMatrices[rmatrices_,tmatrices_]:=FoldList[MLCTransportCompose,First[#],Rest[#]]&[Transpose[{rmatrices,tmatrices}]]


(* ::Input::Initialization:: *)
MLCTransport[x_,{R_,T_}]:=Table[Sum[R[[j,k]]x[[k]],{k,1,6}]+Sum[Sum[T[[j,k,l]]x[[k]]x[[l]],{l,1,6}],{k,1,6}],{j,1,6}]


(* ::Input::Initialization:: *)
MLCReverseCumulativeRMatrices[rmatrices_]:=Reverse[FoldList[Dot,IdentityMatrix[6],Reverse[rmatrices]]]


(* ::Input::Initialization:: *)
MLCPropagateTwissPhaseVector[{\[Beta]x_,\[Alpha]x_,\[Gamma]x_,\[Beta]y_,\[Alpha]y_,\[Gamma]y_,mux_,muy_},M_]:=Module[{rx,ry,twissxout,twissyout,muxout,muyout},
{rx,ry}=MLCGenerateSinglePlaneRMatrices[M];
twissxout=MLCTwissMatrixToVector[MLCPropagateTwissMatrix[MLCTwissVectorToMatrix[{\[Beta]x,\[Alpha]x,\[Gamma]x}],rx]];
twissyout=MLCTwissMatrixToVector[MLCPropagateTwissMatrix[MLCTwissVectorToMatrix[{\[Beta]y,\[Alpha]y,\[Gamma]y}],ry]];
muxout=If[Negative[\[Beta]x rx[[1,1]]-\[Alpha]x rx[[1,2]]],\[Pi],0]+ArcTan[rx[[1,2]]/(\[Beta]x rx[[1,1]]-\[Alpha]x rx[[1,2]])]+mux;
muyout=If[Negative[\[Beta]y ry[[1,1]]-\[Alpha]y ry[[1,2]]],\[Pi],0]+ArcTan[ry[[1,2]]/(\[Beta]y ry[[1,1]]-\[Alpha]y ry[[1,2]])]+muy;
(*muxout=ArcSin[rx[[1,2]]/Sqrt[\[Beta]x twissxout[[1]]]]+mux;
muyout=ArcSin[ry[[1,2]]/Sqrt[\[Beta]y twissyout[[1]]]]+muy;*)
Flatten[{twissxout,twissyout,muxout,muyout}]]


(* ::Input::Initialization:: *)
MLCTwissOperator[M_]:=MLCPropagateTwissPhaseVector[#,M]&


(* ::Input::Initialization:: *)
MLCPropagateTwiss[v_,rmatrices_]:=Rest[ComposeList[MLCTwissOperator[#]&/@rmatrices,v]]


(* ::Input::Initialization:: *)
MLCPropagateDispersion[dispersionvector_,rmatrices_]:=Rest[Dot[#,dispersionvector]&/@MLCCumulativeRMatrices[rmatrices]]


(* ::Input::Initialization:: *)
MLCGenerateTwissTable[lattice_,twissvector_,phasevector_,dispersionvector_,opts___]:=
If[Global`AssignVariables/.{opts}/.{Global`AssignVariables->True},Join[{MLCElems=MLCElementList[{lattice}][[All,1]],MLCS=MADGetLengths[{lattice}],MLCBETX=#[[1]],MLCALFX=#[[2]],MLCGAMX=#[[3]],MLCBETY=#[[4]],MLCALFY=#[[5]],MLCGAMY=#[[6]],MLCMUX=#[[7]],MLCMUY=#[[8]]}&[Transpose[Partition[Flatten[MLCPropagateTwiss[Flatten[{twissvector,phasevector}],MLCRMatrices[{lattice}]]],8]]],{MLCDX=#[[1]],MLCDPX=#[[2]],MLCDY=#[[4]],MLCDPY=#[[5]]}&[Transpose[MLCPropagateDispersion[dispersionvector,MLCRMatrices[{lattice}]]]]],
Join[{MLCElementList[{lattice}][[All,1]],MADGetLengths[{lattice}],#[[1]],#[[2]],#[[3]],#[[4]],#[[5]],#[[6]],#[[7]],#[[8]]}&[Transpose[Partition[Flatten[MLCPropagateTwiss[Flatten[{twissvector,phasevector}],MLCRMatrices[{lattice}]]],8]]],{#[[1]],#[[2]],#[[4]],#[[5]]}&[Transpose[MLCPropagateDispersion[dispersionvector,MLCRMatrices[{lattice}]]]]]
]


(* ::Input::Initialization:: *)
MLCGeneratePeriodicTwissTable[lattice_]:=Join[{MLCElems=MLCElementList[{lattice}][[All,1]],MLCS=MADGetLengths[{lattice}],MLCBETX=#[[1]],MLCALFX=#[[2]],MLCGAMX=#[[3]],MLCBETY=#[[4]],MLCALFY=#[[5]],MLCGAMY=#[[6]],MLCMUX=#[[7]],MLCMUY=#[[8]]}&[Transpose[Partition[Flatten[MLCPropagateTwiss[Flatten[{MLCFindPeriodicTwiss[MLCOneTurnRMatrix[MLCRMatrices[{lattice}]]],{0.0,0.0}}],MLCRMatrices[{lattice}]]],8]]],{MLCDX=#[[1]],MLCDPX=#[[2]],MLCDY=#[[4]],MLCDPY=#[[5]]}&[Transpose[MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[{lattice}]]],MLCRMatrices[{lattice}]]]]]


(* ::Input::Initialization:: *)
MLCGeneratePeriodicTwissTableNoOut[lattice_]:=Join[{MLCElems=MLCElementList[{lattice}][[All,1]],MADGetLengths[{lattice}],#[[1]],#[[2]],#[[3]],#[[4]],#[[5]],#[[6]],#[[7]],#[[8]]}&[Transpose[Partition[Flatten[MLCPropagateTwiss[Flatten[{MLCFindPeriodicTwiss[MLCOneTurnRMatrix[MLCRMatrices[{lattice}]]],{0.0,0.0}}],MLCRMatrices[{lattice}]]],8]]],{#[[1]],#[[2]],#[[4]],#[[5]]}&[Transpose[MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[{lattice}]]],MLCRMatrices[{lattice}]]]]]


(* ::Input::Initialization:: *)
MLCPropagateRay[v_,rmatrices_]:=Rest[Dot[#,v]&/@MLCCumulativeRMatrices[rmatrices]]


(* ::Input::Initialization:: *)
MLCTwissOperator[M_]:=MLCPropagateTwissPhaseVector[#,M]&


(* ::Input::Initialization:: *)
MLCPropagateTwiss[v_,rmatrices_]:=Rest[ComposeList[MLCTwissOperator[#]&/@rmatrices,v]]


(* ::Input::Initialization:: *)
DotOperator[M_]:=Dot[M,#]&


(* ::Input::Initialization:: *)
MLCRetardNonParaxialRay[v_,L_]:=ReplacePart[v,v[[5]]-L  (v[[2]]^2+v[[4]]^2)/2,5] (*need to think whether this is -L or +L*)


(* ::Input::Initialization:: *)
MLCPropagateAndRetardOperator[arg_]:=MLCRetardNonParaxialRay[Dot[arg[[1]],#],arg[[2]]]& (*this command operates R=arg[[1]] and L=arg[[2]] on a ray v*)


(* ::Input::Initialization:: *)
MLCPropagateNonParaxialRay[v_,rmatrices_,elemlengths_]:=Rest[ComposeList[MLCPropagateAndRetardOperator[#]&/@Transpose[{rmatrices,elemlengths}],v]]


(* ::Input::Initialization:: *)
MLCBetaGamma[beta_,alpha_]={beta,alpha,(1+alpha^2)/beta}


(* ::Input::Initialization:: *)
\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", "0", "0", "0", "0", "Dx"},
{"0", "1", "0", "0", "0", "Dpx"},
{"0", "0", "1", "0", "0", "Dy"},
{"0", "0", "0", "1", "0", "Dpy"},
{"0", "0", "0", "0", "1", "0"},
{"0", "0", "0", "0", "0", "1"}
},
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\).\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{
SqrtBox["\[Beta]x"], "0", "0", "0", "0", "0"},
{"0", 
SqrtBox[
FractionBox["1", "\[Beta]x"]], "0", "0", "0", "0"},
{"0", "0", 
SqrtBox["\[Beta]y"], "0", "0", "0"},
{"0", "0", "0", 
SqrtBox[
FractionBox["1", "\[Beta]y"]], "0", "0"},
{"0", "0", "0", "0", "1", "0"},
{"0", "0", "0", "0", "0", "1"}
},
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\).\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", "0", "0", "0", "0", "0"},
{
RowBox[{"-", "\[Alpha]x"}], "1", "0", "0", "0", "0"},
{"0", "0", "1", "0", "0", "0"},
{"0", "0", 
RowBox[{"-", "\[Alpha]y"}], "1", "0", "0"},
{"0", "0", "0", "0", "1", "0"},
{"0", "0", "0", "0", "0", "1"}
},
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\).e


(* ::Input::Initialization:: *)
MLCGenerateBeamDistribution6D[{emittancex_,emittancey_},{espread_,blength_},{\[Beta]x_,\[Alpha]x_,\[Beta]y_,\[Alpha]y_},{Dx_,Dpx_,Dy_,Dpy_},nparticles_,nsigma_]:=(\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{
SqrtBox["\[Beta]x"], "0", "0", "0", "0", "Dx"},
{
RowBox[{
RowBox[{"-", "\[Alpha]x"}], " ", 
SqrtBox[
FractionBox["1", "\[Beta]x"]]}], 
SqrtBox[
FractionBox["1", "\[Beta]x"]], "0", "0", "0", "Dpx"},
{"0", "0", 
SqrtBox["\[Beta]y"], "0", "0", "Dy"},
{"0", "0", 
RowBox[{
RowBox[{"-", "\[Alpha]y"}], " ", 
SqrtBox[
FractionBox["1", "\[Beta]y"]]}], 
SqrtBox[
FractionBox["1", "\[Beta]y"]], "0", "Dpy"},
{"0", "0", "0", "0", "1", "0"},
{"0", "0", "0", "0", "0", "1"}
},
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\).#)&/@Table[{TruncatedGaussianSample[0,Sqrt[emittancex],nsigma],TruncatedGaussianSample[0,Sqrt[emittancex],nsigma],TruncatedGaussianSample[0,Sqrt[emittancex],nsigma],TruncatedGaussianSample[0,Sqrt[emittancey],nsigma],TruncatedGaussianSample[0,Sqrt[espread],nsigma],TruncatedGaussianSample[0,Sqrt[blength],nsigma]},{nparticles}];


(* ::Input::Initialization:: *)
MLCPlot[data_,opts___]:=ListPlot


(* ::Input::Initialization:: *)
MLCPlotPeriodicOptics[lattice_,opts___]:=Block[{nslices,elemlist},nslices=Slices/.{opts}/.{Slices->1};elemlist=MADSplitElements[lattice,nslices];MLCGeneratePeriodicTwissTable[elemlist];Show[MADDraw[lattice,Labels->False,Lengths->False,WidthScale->Ceiling[0.2` Max[{MLCBETX,MLCBETY,10 MLCDX}]],Thick->0.002`,Imagesize->600,Fontsize->10,Bends->False,Offset->5.5` Ceiling[0.2` Max[{MLCBETX,MLCBETY,10 MLCDX}]],DisplayFunction->Identity],mfsPlot[{{MLCS,MLCBETX},{MLCS,MLCBETY},{MLCS,10 MLCDX}},DisplayFunction->Identity,opts],Graphics[{Red,Text["\!\(\*SubscriptBox[\(\[Beta]\), \(x\)]\)",{MLCS[[First[Flatten[Position[MLCS,_?(#1>Last[MLCS] 0.1`&)]]]]],MLCBETX[[First[Flatten[Position[MLCS,_?(#1>Last[MLCS] 0.1`&)]]]]]+Max[MLCBETX] 0.1`}],Blue,Text["\!\(\*SubscriptBox[\(\[Beta]\), \(y\)]\)",{MLCS[[First[Flatten[Position[MLCS,_?(#1>Last[MLCS] 0.2`&)]]]]],MLCBETY[[First[Flatten[Position[MLCS,_?(#1>Last[MLCS] 0.2`&)]]]]]+Max[MLCBETY] 0.1`}],Black,Text["\!\(\*SubscriptBox[\(\[Eta]\), \(x\)]\)",{MLCS[[First[Flatten[Position[MLCS,_?(#1>Last[MLCS] 0.3`&)]]]]],10 MLCDX[[First[Flatten[Position[MLCS,_?(#1>Last[MLCS] 0.3`&)]]]]]+Max[MLCDX]}]}],ImageSize->{600,400},PlotRange->{{First[MLCS],Last[MLCS]},{5 Floor[0.2` Min[{MLCBETX,MLCBETY,10 MLCDX}]],6 Ceiling[0.2` Max[{MLCBETX,MLCBETY,10 MLCDX}]]}},Frame->True,DisplayFunction->$DisplayFunction,BaseStyle->{FontFamily->"Times",FontSize->18},FrameLabel->{"s [m]","Optical Functions [m]"}]]


(* ::Input::Initialization:: *)
MLCMatrixInspect[M_]:=BarChart3D[M,ViewPoint->{-2.360,-2.220,0.975},XSpacing->1/2,YSpacing->1/2]


(* ::Input::Initialization:: *)
integralSRI1[kx_,s_,h_,dx_,dpx_,\[Beta]2_,\[Rho]_]:=NIntegrate[(If[kx==0,(h l^2)/2,(h (1-Cos[kx l]))/kx^2]+dpx If[kx==0,l,Sin[kx l]/kx]+dx (Cos[kx l]+h If[kx==0,l,Sin[kx l]/kx] Tan[\[Beta]2]))/\[Rho],{l,0,s},Compiled->True]


(* ::Input::Initialization:: *)
MLCSRI1[latt_]:=Module[{kx,ky,\[Rho], h, n,L},
pos=(Position[MADFlatten[latt],"SectorBend"][[All,1]]-1);mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
Plus@@((L=#[[1,3]];\[Rho]=L/#[[1,6]];n=-#[[1,4]] \[Rho]^2;h=1/\[Rho];kx=h Sqrt[1-n];ky=h Sqrt[n];integralSRI1[kx,L,h,#[[2,1]],#[[2,2]],#[[1,11]],\[Rho]])&/@MapThread[List,{Select[MLCElementList[latt],#[[2]]==="SectorBend"&],(Extract[mat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
SR2Element[elem_]:=NIntegrate[(elem[[6]]/elem[[3]])^2,{l,0,elem[[3]]}]


(* ::Input::Initialization:: *)
MLCSRI2[latt_]:=Plus@@(SR2Element[#]&/@(Select[MADFlatten[latt],#[[2]]==="SectorBend"&]))


(* ::Input::Initialization:: *)
SR3Element[elem_]:=NIntegrate[Abs[(elem[[6]]/elem[[3]])^3],{l,0,elem[[3]]}]


(* ::Input::Initialization:: *)
MLCSRI3[latt_]:=Plus@@(SR3Element[#]&/@(Select[MADFlatten[latt],#[[2]]==="SectorBend"&]))


(* ::Input::Initialization:: *)
integralSRI4[kx_,s_,h_,dx_,dpx_,\[Beta]2_,n_,\[Rho]_]:=NIntegrate[(1-2n)(If[kx==0,(h l^2)/2,(h (1-Cos[kx l]))/kx^2]+dpx If[kx==0,l,Sin[kx l]/kx]+dx (Cos[kx l]+h If[kx==0,l,Sin[kx l]/kx] Tan[\[Beta]2]))/\[Rho]^3,{l,0,s},Compiled->True]


(* ::Input::Initialization:: *)
MLCSRI4[latt_]:=Module[{kx,ky,\[Rho], h, n,L},
pos=(Position[MADFlatten[latt],"SectorBend"][[All,1]]-1);mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
Plus@@((L=#[[1,3]];\[Rho]=L/#[[1,6]];n=-#[[1,4]] \[Rho]^2;h=1/\[Rho];kx=h Sqrt[1-n];ky=h Sqrt[n];integralSRI4[kx,L,h,#[[2,1]],#[[2,2]],#[[1,10]],n,\[Rho]])&/@MapThread[List,{Select[MLCElementList[latt],#[[2]]==="SectorBend"&],(Extract[mat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
integralSRI5H[\[Alpha]_,\[Beta]_,\[Gamma]_,kx_,s_,h_,dx_,dpx_,\[Rho]_]:=NIntegrate[((dx Cos[kx l]+If[kx==0,(h l^2)/2,(h (1-Cos[kx l]))/kx^2]+dpx If[kx==0,l,Sin[kx l]/kx])^2+((\[Beta] Cos[kx l]^2-2 \[Alpha] Cos[kx l] If[kx==0,l,Sin[kx l]/kx]+\[Gamma] If[kx==0,l,Sin[kx l]/kx]^2) (dpx Cos[kx l]+If[kx==0,h l,(h Sin[kx l])/kx]-dx kx Sin[kx l])+(dx Cos[kx l]+If[kx==0,(h l^2)/2,(h (1-Cos[kx l]))/kx^2]+dpx If[kx==0,l,Sin[kx l]/kx]) (-If[kx==0,l,Sin[kx l]/kx] (\[Gamma] Cos[kx l]+kx \[Alpha] Sin[kx l])+Cos[kx l] (\[Alpha] Cos[kx l]+kx \[Beta] Sin[kx l])))^2)/(\[Beta] Cos[kx l]^2-2 \[Alpha] Cos[kx l] If[kx==0,l,Sin[kx l]/kx]+\[Gamma] If[kx==0,l,Sin[kx l]/kx]^2)/Abs[\[Rho]]^3,{l,0,s},Compiled->True]


(* ::Input::Initialization:: *)
MLCSRI5H[{elem_,input1_,input2_}]:=Module[{kx,ky,\[Rho], h, n,L},
Plus@@((L=#[[1,3]];\[Rho]=L/#[[1,6]];n=-#[[1,4]] \[Rho]^2;h=1/\[Rho];kx=h Sqrt[1-n];ky=h Sqrt[n];If[kx=!=0,integralSRI5H[#[[3,2]],#[[3,1]],#[[3,3]],kx,L,h,#[[2,1]],#[[2,2]],\[Rho]],integralSRI5H2[#[[3,2]],#[[3,1]],#[[3,3]],kx,L,h,#[[2,1]],#[[2,2]],\[Rho]]])&/@{{elem,input1,input2}})]


(* ::Input::Initialization:: *)
MLCSRI5[latt_]:=Block[{H,\[Beta],\[Beta]prime,\[Eta],\[Eta]prime,pos,mat,tpos,tmat,\[Rho]},
tmat=Transpose[MLCGeneratePeriodicTwissTable[MADFlatten[latt]][[{3,4,5}]]];
pos=(Position[MADFlatten[latt],"SectorBend"][[All,1]]-1);mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
Plus@@((MLCSRI5H[#])&/@MapThread[List,{Select[MADFlatten[latt],#[[2]]==="SectorBend"&],(Extract[mat,#]&/@pos),(Extract[tmat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
MLC\[Alpha]c[latt_]:=MLCSRI1[latt]/MADLength[latt]


(* ::Input::Initialization:: *)
MLC\[Epsilon][latt_,energy_]:=1.4673594530853189*^-12 energy^2*If[ValueQ[MLCI5],MLCI5,MLCSRI5[latt]]/(If[ValueQ[MLCI2],MLCI2,MLCSRI2[latt]]-If[ValueQ[MLCI4],MLCI4,MLCSRI4[latt]])


(* ::Input::Initialization:: *)
MLCSRI[latt_]:={MLCI1=MLCSRI1[latt] Meter,MLCI2=MLCSRI2[latt]/Meter,MLCI3=MLCSRI3[latt]/Meter^2,MLCI4=MLCSRI4[latt]/Meter,MLCI5=MLCSRI5[latt]/Meter}


(* ::Input::Initialization:: *)
MLC\[Epsilon][latt_,energy_]:=Convert[(55 PlanckConstant (energy ElectronVolt Mega)^2)/(2 \[Pi] (ElectronMass*SpeedOfLight^2)^2 32Sqrt[3]ElectronMass SpeedOfLight)*If[ValueQ[MLCI5],MLCI5,MLCSRI5[latt]]/((If[ValueQ[MLCI2],MLCI2,MLCSRI2[latt]])-(If[ValueQ[MLCI4],MLCI4,MLCSRI4[latt]])),Nano Meter]


(* ::Input::Initialization:: *)
MLCU0[latt_,energy_]:=Convert[(2 ClassicalElectronRadius (energy*Mega ElectronVolt)^4 (If[ValueQ[MLCI2],MLCI2,MLCSRI2[latt]]))/(3 (ElectronMass SpeedOfLight^2)^3),ElectronVolt Kilo]


(* ::Input::Initialization:: *)
MLCJx[latt_]:=1-(If[ValueQ[MLCI4],MLCI4,MLCSRI4[latt]])/(If[ValueQ[MLCI2],MLCI2,MLCSRI2[latt]])


(* ::Input::Initialization:: *)
MLCJ\[Epsilon][latt_]:=2+(If[ValueQ[MLCI4],MLCI4,MLCSRI4[latt]])/(If[ValueQ[MLCI2],MLCI2,MLCSRI2[latt]])


(* ::Input::Initialization:: *)
MLCES[latt_,energy_]:=Convert[(55 PlanckConstant (energy ElectronVolt Mega)^2)/(2 \[Pi] (ElectronMass*SpeedOfLight^2)^2 32Sqrt[3]ElectronMass SpeedOfLight)*If[ValueQ[MLCI3],MLCI3,MLCSRI3[latt]]/(2 (If[ValueQ[MLCI2],MLCI2,MLCSRI2[latt]])+(If[ValueQ[MLCI4],MLCI4,MLCSRI4[latt]])),Joules]


(* ::Input::Initialization:: *)
MLC\[Tau]x[latt_,energy_]:=Convert[(3 ElectronMass^3 SpeedOfLight^5 MADLength[latt] Meter (Plus@@Select[MADFlatten[DIAMOND],#[[2]]==="SectorBend"&][[All,3]]/(2 \[Pi])) Meter)/(2 \[Pi] ClassicalElectronRadius MLCJx[latt] (energy Mega ElectronVolt)^3),Milli Second]


(* ::Input::Initialization:: *)
MLC\[Tau]y[latt_,energy_]:=Convert[(3 ElectronMass^3 SpeedOfLight^5 MADLength[latt] Meter (Plus@@Select[MADFlatten[DIAMOND],#[[2]]==="SectorBend"&][[All,3]]/(2 \[Pi])) Meter)/(2 \[Pi] ClassicalElectronRadius 1 (energy Mega ElectronVolt)^3),Milli Second]


(* ::Input::Initialization:: *)
MLC\[Tau]\[Epsilon][latt_,energy_]:=Convert[(3 ElectronMass^3 SpeedOfLight^5 MADLength[latt] Meter (Plus@@Select[MADFlatten[DIAMOND],#[[2]]==="SectorBend"&][[All,3]]/(2 \[Pi])) Meter)/(2 \[Pi] ClassicalElectronRadius MLCJ\[Epsilon][latt] (energy Mega ElectronVolt)^3),Milli Second]


(* ::Input::Initialization:: *)
 MLC\[Epsilon]x[latt_,energy_,\[Kappa]_:0.01]:=  MLC\[Epsilon][latt,energy] /(1+\[Kappa])


(* ::Input::Initialization:: *)
 MLC\[Epsilon]y[latt_,energy_,\[Kappa]_:0.01]:=(\[Kappa] MLC\[Epsilon][latt,energy] )/(1+\[Kappa])


(* ::Input::Initialization:: *)
MLC\[Sigma]x[latt_,energy_]:=Block[{\[Epsilon]x,es},\[Epsilon]x=(MLC\[Epsilon]x[latt,energy] 10^-9/(Meter Nano));es=MLCES[latt,energy];(Sqrt[\[Epsilon]x #[[1]]+es^2 #[[2]]^2]&/@MapThread[List,{MLCGeneratePeriodicTwissTable[latt][[3]],MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]][[All,1]]}])]


(* ::Input::Initialization:: *)
MLC\[Sigma]y[latt_,energy_]:=Block[{\[Epsilon]y},\[Epsilon]y=(MLC\[Epsilon]y[latt,energy] 10^-9/(Meter Nano));(Sqrt[\[Epsilon]y #]&/@MLCGeneratePeriodicTwissTable[latt][[6]])]


(* ::Input::Initialization:: *)
MLC\[Sigma]primex[latt_,energy_]:=Block[{\[Epsilon]x,es},\[Epsilon]x=(MLC\[Epsilon]x[latt,energy] 10^-9/(Meter Nano));es=MLCES[latt,energy];(Sqrt[\[Epsilon]x #[[1]]+es^2 #[[2]]^2]&/@MapThread[List,{MLCGeneratePeriodicTwissTable[latt][[5]],MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]][[All,2]]}])]


(* ::Input::Initialization:: *)
MLC\[Sigma]primey[latt_,energy_]:=Block[{\[Epsilon]y},\[Epsilon]y=(MLC\[Epsilon]y[latt,energy] 10^-9/(Meter Nano));(Sqrt[\[Epsilon]y #]&/@MLCGeneratePeriodicTwissTable[latt][[8]])]


(* ::Input::Initialization:: *)
QuadDisp[latt_]:=Block[{k,L,pos,mat,\[Rho],n,kx,ky,\[CurlyPhi],h},
pos=(Position[MADFlatten[latt],"Quadrupole"][[All,1]]-1)//.{0->-1};mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
If[#[[1,4]]<0,
(L=#[[1,3]];k=Sqrt[-#[[1,4]]];QuadDispTableNeg[k,L,#[[2,1]],#[[2,2]]]),(L=#[[1,3]];k=Sqrt[#[[1,4]]];QuadDispTablePos[k,L,#[[2,1]],#[[2,2]]])]&/@MapThread[List,{Select[MLCElementList[latt],#[[2]]==="Quadrupole"&],(Extract[mat,#]&/@pos)}]]


(* ::Input::Initialization:: *)
QuadDispPrime[latt_]:=Block[{k,L,pos,mat,\[Rho],n,kx,ky,\[CurlyPhi],h},
pos=(Position[MADFlatten[latt],"Quadrupole"][[All,1]]-1)//.{0->-1};mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
If[#[[1,4]]<0,
(L=#[[1,3]];k=Sqrt[-#[[1,4]]];QuadDispPrimeTableNeg[k,L,#[[2,1]],#[[2,2]]]),(L=#[[1,3]];k=Sqrt[#[[1,4]]];QuadDispPrimeTablePos[k,L,#[[2,1]],#[[2,2]]])]&/@MapThread[List,{Select[MLCElementList[latt],#[[2]]==="Quadrupole"&],(Extract[mat,#]&/@pos)}]]


(* ::Input::Initialization:: *)
QuadGamma[latt_]:=Block[{k,L,tmat,pos,mat,\[Rho],n,kx,ky,\[CurlyPhi],h},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{3,4,5}]]];
pos=(Position[MADFlatten[latt],"Quadrupole"][[All,1]]-1)//.{0->-1};
If[#[[1,4]]<0,
(L=#[[1,3]];k=Sqrt[-#[[1,4]]];QuadGammaTableNeg[#[[2,2]],#[[2,1]],#[[2,3]],k,L]),(L=#[[1,3]];k=Sqrt[#[[1,4]]];QuadGammaTablePos[#[[2,2]],#[[2,1]],#[[2,3]],k,L])]&/@MapThread[List,{Select[MADFlatten[latt],#[[2]]==="Quadrupole"&],(Extract[tmat,#]&/@pos)}]]


(* ::Input::Initialization:: *)
QuadBeta[latt_]:=Block[{k,L,tmat,pos,mat,\[Rho],n,kx,ky,\[CurlyPhi],h},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{3,4,5}]]];
pos=(Position[MADFlatten[latt],"Quadrupole"][[All,1]]-1)//.{0->-1};
If[#[[1,4]]<0,
(L=#[[1,3]];k=Sqrt[-#[[1,4]]];QuadBetaTableNeg[#[[2,2]],#[[2,1]],#[[2,3]],k,L]),(L=#[[1,3]];k=Sqrt[#[[1,4]]];QuadBetaTablePos[#[[2,2]],#[[2,1]],#[[2,3]],k,L])]&/@MapThread[List,{Select[MADFlatten[latt],#[[2]]==="Quadrupole"&],(Extract[tmat,#]&/@pos)}]]


(* ::Input::Initialization:: *)
DriftDisp[latt_]:=Block[{L,pos,mat,\[Rho],n,kx,ky,\[CurlyPhi],h,k},
pos=(Position[MADFlatten[latt],"Drift"][[All,1]]-1)//.{0->-1};
mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
(L=#[[1,3]];DriftDispTable[L,#[[2,1]],#[[2,2]]])&/@MapThread[List,{Select[MLCElementList[latt],#[[2]]==="Drift"&],(Extract[mat,#]&/@pos)}]]


(* ::Input::Initialization:: *)
DriftDispPrime[latt_]:=Block[{L,pos,mat,\[Rho],n,kx,ky,\[CurlyPhi],h,k},
pos=(Position[MADFlatten[latt],"Drift"][[All,1]]-1)//.{0->-1};
mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
(L=#[[1,3]];DriftDispPrimeTable[L,#[[2,1]],#[[2,2]]])&/@MapThread[List,{Select[MLCElementList[latt],#[[2]]==="Drift"&],(Extract[mat,#]&/@pos)}]]


(* ::Input::Initialization:: *)
DriftBeta[latt_]:=Block[{H,\[Beta],\[Beta]prime,\[Eta],\[Eta]prime,pos,mat,tpos,tmat,\[Rho],n,kx,ky,\[CurlyPhi],h,k},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{3,4,5}]]];
pos=(Position[MADFlatten[latt],"Drift"][[All,1]]-1)//.{0->-1};
((L=#[[1,3]];DriftBetaTable[#[[2,2]],#[[2,1]],#[[2,3]],L])&/@MapThread[List,{Select[MADFlatten[latt],#[[2]]==="Drift"&],(Extract[tmat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
DriftGamma[latt_]:=Block[{H,\[Beta],\[Beta]prime,\[Eta],\[Eta]prime,pos,mat,tpos,tmat,\[Rho],L,n,kx,ky,\[CurlyPhi],h,k},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{3,4,5}]]];
pos=(Position[MADFlatten[latt],"Drift"][[All,1]]-1)//.{0->-1};
((L=#[[1,3]];DriftGammaTable[#[[2,2]],#[[2,1]],#[[2,3]],L])&/@MapThread[List,{Select[MADFlatten[latt],#[[2]]==="Drift"&],(Extract[tmat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
DipoleDisp[latt_]:=Module[{kx,ky,\[Rho], h, n,L,\[CurlyPhi],k},
pos=(Position[MADFlatten[latt],"SectorBend"][[All,1]]-1);mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
((L=#[[1,3]];\[Rho]=L/#[[1,6]];n=-#[[1,4]] \[Rho]^2;h=1/\[Rho];kx=h Sqrt[1-n];ky=h Sqrt[n];DipoleDispTable[kx,L,h,#[[2,1]],#[[2,2]],#[[1,11]],\[Rho]])&/@MapThread[List,{Select[MLCElementList[latt],#[[2]]==="SectorBend"&],(Extract[mat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
DipoleDispPrime[latt_]:=Module[{kx,ky,\[Rho], h, n,L,\[CurlyPhi],k},
pos=(Position[MADFlatten[latt],"SectorBend"][[All,1]]-1);mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
((L=#[[1,3]];\[Rho]=L/#[[1,6]];n=-#[[1,4]] \[Rho]^2;h=1/\[Rho];kx=h Sqrt[1-n];ky=h Sqrt[n];DipoleDispPrimeTable[kx,L,h,#[[2,1]],#[[2,2]],#[[1,10]],#[[1,11]],\[Rho]])&/@MapThread[List,{Select[MLCElementList[latt],#[[2]]==="SectorBend"&],(Extract[mat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
DipoleBeta[latt_]:=Block[{H,\[Beta],\[Beta]prime,\[Eta],\[Eta]prime,pos,mat,tpos,tmat,L,\[Rho],n,kx,ky,\[CurlyPhi],h,k},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{3,4,5}]]];
pos=(Position[MADFlatten[latt],"SectorBend"][[All,1]]-1);mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
((L=#[[1,3]];\[Rho]=L/#[[1,6]];n=-#[[1,4]] \[Rho]^2;h=1/\[Rho];kx=h Sqrt[1-n];ky=h Sqrt[n];DipoleBetaTable[#[[3,2]],#[[3,1]],#[[3,3]],kx,#[[1,11]],L])&/@MapThread[List,{MLCElementList[Select[MADFlatten[latt],#[[2]]==="SectorBend"&]],(Extract[mat,#]&/@pos),(Extract[tmat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
DipoleGamma[latt_]:=Block[{H,\[Beta],\[Beta]prime,\[Eta],\[Eta]prime,pos,mat,tpos,tmat,L,\[Rho],n,kx,ky,\[CurlyPhi],h,k},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{3,4,5}]]];
pos=(Position[MADFlatten[latt],"SectorBend"][[All,1]]-1);mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
((L=#[[1,3]];\[Rho]=L/#[[1,6]];n=-#[[1,4]] \[Rho]^2;h=1/\[Rho];kx=h Sqrt[1-n];ky=h Sqrt[n];DipoleGammaTable[#[[3,2]],#[[3,1]],#[[3,3]],kx,#[[1,10]],#[[1,11]],L])&/@MapThread[List,{MLCElementList[Select[MADFlatten[latt],#[[2]]==="SectorBend"&]],(Extract[mat,#]&/@pos),(Extract[tmat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
QuadBetaY[latt_]:=Block[{k,L,tmat,pos,mat,\[Rho],n,kx,ky,\[CurlyPhi],h},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{6,7,8}]]];
pos=(Position[MADFlatten[latt],"Quadrupole"][[All,1]]-1)//.{0->-1};
If[#[[1,4]]<0,
(L=#[[1,3]];k=Sqrt[-#[[1,4]]];QuadBetaYTableNeg[#[[2,2]],#[[2,1]],#[[2,3]],k,L]),(L=#[[1,3]];k=Sqrt[#[[1,4]]];QuadBetaYTablePos[#[[2,2]],#[[2,1]],#[[2,3]],k,L])]&/@MapThread[List,{Select[MADFlatten[latt],#[[2]]==="Quadrupole"&],(Extract[tmat,#]&/@pos)}]]


(* ::Input::Initialization:: *)
DriftBetaY[latt_]:=Block[{H,\[Beta],\[Beta]prime,\[Eta],\[Eta]prime,pos,mat,tpos,tmat,L,\[Rho],n,kx,ky,\[CurlyPhi],h,k},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{6,7,8}]]];
pos=(Position[MADFlatten[latt],"Drift"][[All,1]]-1)//.{0->-1};
((L=#[[1,3]];DriftBetaYTable[#[[2,2]],#[[2,1]],#[[2,3]],L])&/@MapThread[List,{Select[MADFlatten[latt],#[[2]]==="Drift"&],(Extract[tmat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
DipoleBetaY[latt_]:=Block[{H,\[Beta],\[Beta]prime,\[Eta],\[Eta]prime,pos,mat,tpos,tmat,L,\[Rho],n,kx,ky,\[CurlyPhi],h,k},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{6,7,8}]]];
pos=(Position[MADFlatten[latt],"SectorBend"][[All,1]]-1);mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
((L=#[[1,3]];\[Rho]=L/#[[1,6]];n=-#[[1,4]] \[Rho]^2;h=1/\[Rho];kx=h Sqrt[1-n];ky=h Sqrt[n];\[CurlyPhi]=k h 0(1+Sin[\[Beta]]^2)/Cos[\[Beta]];DipoleBetaYTable[#[[3,2]],#[[3,1]],#[[3,3]],ky,#[[1,11]],#[[1,11]],\[CurlyPhi],h,L])&/@MapThread[List,{MLCElementList[Select[MADFlatten[latt],#[[2]]==="SectorBend"&]],(Extract[mat,#]&/@pos),(Extract[tmat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
DipoleGammaY[latt_]:=Block[{H,\[Beta],\[Beta]prime,\[Eta],\[Eta]prime,pos,mat,tpos,tmat,L,\[Rho],n,kx,ky,\[CurlyPhi],h,k},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{6,7,8}]]];
pos=(Position[MADFlatten[latt],"SectorBend"][[All,1]]-1);mat=(#*{1,1,0,0,0,1})&/@MLCPropagateDispersion[MLCFindPeriodicDispersion[MLCOneTurnRMatrix[MLCRMatrices[latt]]],MLCRMatrices[latt]];
((L=#[[1,3]];\[Rho]=L/#[[1,6]];n=-#[[1,4]] \[Rho]^2;h=1/\[Rho];kx=h Sqrt[1-n];ky=h Sqrt[n];\[CurlyPhi]=k h 0(1+Sin[\[Beta]]^2)/Cos[\[Beta]];DipoleGammaYTable[#[[3,2]],#[[3,1]],#[[3,3]],ky,#[[1,11]],#[[1,11]],h,L])&/@MapThread[List,{MLCElementList[Select[MADFlatten[latt],#[[2]]==="SectorBend"&]],(Extract[mat,#]&/@pos),(Extract[tmat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
QuadGammaY[latt_]:=Block[{k,L,tmat,pos,mat,\[Rho],n,kx,ky,\[CurlyPhi],h},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{6,7,8}]]];
pos=(Position[MADFlatten[latt],"Quadrupole"][[All,1]]-1)//.{0->-1};
If[#[[1,4]]<0,
(L=#[[1,3]];k=Sqrt[-#[[1,4]]];QuadGammaYTableNeg[#[[2,2]],#[[2,1]],#[[2,3]],k,L]),(L=#[[1,3]];k=Sqrt[#[[1,4]]];QuadGammaYTablePos[#[[2,2]],#[[2,1]],#[[2,3]],k,L])]&/@MapThread[List,{Select[MADFlatten[latt],#[[2]]==="Quadrupole"&],(Extract[tmat,#]&/@pos)}]]


(* ::Input::Initialization:: *)
DriftGammaY[latt_]:=Block[{H,\[Beta],\[Beta]prime,\[Eta],\[Eta]prime,pos,mat,tpos,tmat,L,\[Rho],n,kx,ky,\[CurlyPhi],h,k},
tmat=Transpose[MLCGeneratePeriodicTwissTableNoOut[MADFlatten[latt]][[{6,7,8}]]];
pos=(Position[MADFlatten[latt],"Drift"][[All,1]]-1)//.{0->-1};
((L=#[[1,3]];DriftGammaYTable[#[[2,2]],#[[2,1]],#[[2,3]],L])&/@MapThread[List,{Select[MADFlatten[latt],#[[2]]==="Drift"&],(Extract[tmat,#]&/@pos)}])]


(* ::Input::Initialization:: *)
QuadDispTableNeg[k_,s_,dx_,dpx_]:=NIntegrate[dx Cosh[k L]+(dpx Sinh[k L])/k ,{L,0,s}]


(* ::Input::Initialization:: *)
QuadDispPrimeTableNeg[k_,s_,dx_,dpx_]:=NIntegrate[dpx Cosh[k L]+dx k Sinh[k L] ,{L,0,s}]


(* ::Input::Initialization:: *)
QuadDispTablePos[k_,s_,dx_,dpx_]:=NIntegrate[dx Cos[k L]+(dpx Sin[k L])/k ,{L,0,s}]


(* ::Input::Initialization:: *)
QuadDispPrimeTablePos[k_,s_,dx_,dpx_]:=NIntegrate[dpx Cos[k L]-dx k Sin[k L] ,{L,0,s}]


(* ::Input::Initialization:: *)
QuadBetaTablePos[\[Alpha]_,\[Beta]_,\[Gamma]_,k_,s_]:=NIntegrate[Cos[k L] (\[Beta] Cos[k L]-(\[Alpha] Sin[k L])/k)+(Sin[k L] (-\[Alpha] Cos[k L]+(\[Gamma] Sin[k L])/k))/k,{L,0,s}]


(* ::Input::Initialization:: *)
QuadBetaTableNeg[\[Alpha]_,\[Beta]_,\[Gamma]_,k_,s_]:=NIntegrate[Cosh[k L] (\[Beta] Cosh[k L]-(\[Alpha] Sinh[k L])/k)+(Sinh[k L] (-\[Alpha] Cosh[k L]+(\[Gamma] Sinh[k L])/k))/k,{L,0,s}]


(* ::Input::Initialization:: *)
QuadGammaTablePos[\[Alpha]_,\[Beta]_,\[Gamma]_,k_,s_]:=NIntegrate[Cos[k L] (\[Gamma] Cos[k L]+k \[Alpha] Sin[k L])-k Sin[k L] (-\[Alpha] Cos[k L]-k \[Beta] Sin[k L]),{L,0,s}]


(* ::Input::Initialization:: *)
QuadGammaTableNeg[\[Alpha]_,\[Beta]_,\[Gamma]_,k_,s_]:=NIntegrate[Cosh[k L] (\[Gamma] Cosh[k L]-k \[Alpha] Sinh[k L])+k Sinh[k L] (-\[Alpha] Cosh[k L]+k \[Beta] Sinh[k L]),{L,0,s}]


(* ::Input::Initialization:: *)
DriftDispTable[s_,dx_,dpx_]:=NIntegrate[dx+dpx L ,{L,0,s}]


(* ::Input::Initialization:: *)
DriftDispPrimeTable[s_,dx_,dpx_]:=NIntegrate[dpx ,{L,0,s}]


(* ::Input::Initialization:: *)
DriftBetaTable[\[Alpha]_,\[Beta]_,\[Gamma]_,s_]:=NIntegrate[-L \[Alpha]+\[Beta]+L (-\[Alpha]+L \[Gamma]),{L,0,s}]


(* ::Input::Initialization:: *)
DriftGammaTable[\[Alpha]_,\[Beta]_,\[Gamma]_,s_]:=NIntegrate[\[Gamma],{L,0,s}]


(* ::Input::Initialization:: *)
DipoleDispTable[kx_,s_,h_,dx_,dpx_,\[Beta]2_,\[Rho]_]:=NIntegrate[(If[kx==0,(h l^2)/2,(h (1-Cos[kx l]))/kx^2]+dpx If[kx==0,l,Sin[kx l]/kx]+dx (Cos[kx l]+h If[kx==0,l,Sin[kx l]/kx] Tan[\[Beta]2])),{l,0,s}]


(* ::Input::Initialization:: *)
DipoleDispPrimeTable[kx_,s_,h_,dx_,dpx_,\[Beta]1_,\[Beta]2_,\[Rho]_]:=NIntegrate[If[kx==0,h l,(h Sin[kx l])/kx]+h If[kx==0,(h l^2)/2,(h (1-Cos[kx l]))/kx^2] Tan[\[Beta]1]+dpx (Cos[kx l]+h If[kx==0,l,Sin[kx l]/kx] Tan[\[Beta]1])+dx (-kx Sin[kx l]+h Cos[kx l] Tan[\[Beta]1]+h (Cos[kx l]+h If[kx==0,l,Sin[kx l]/kx] Tan[\[Beta]1]) Tan[\[Beta]2]),{l,0,s}]


(* ::Input::Initialization:: *)
DipoleBetaTable[\[Alpha]_,\[Beta]_,\[Gamma]_,kx_,s_]:=NIntegrate[(\[Beta] Cos[kx l]^2-2 \[Alpha] Cos[kx l] If[kx==0,l,Sin[kx l]/kx]+\[Gamma] If[kx==0,l,Sin[kx l]/kx]^2),{l,0,s}]


(* ::Input::Initialization:: *)
DipoleBetaTable[\[Alpha]_,\[Beta]_,\[Gamma]_,kx_,\[Beta]2_,s_]:=NIntegrate[\[Beta] Cos[kx L]^2-2 Cos[kx L] If[kx==0,L,Sin[kx L]/kx] (\[Alpha]-h \[Beta] Tan[\[Beta]2])+If[kx==0,L,Sin[kx L]/kx]^2 (\[Gamma]+h Tan[\[Beta]2] (-2 \[Alpha]+h \[Beta] Tan[\[Beta]2])),{L,0,s}]


(* ::Input::Initialization:: *)
DipoleGammaTable[\[Alpha]_,\[Beta]_,\[Gamma]_,k_,\[Beta]1_,\[Beta]2_,s_]:=NIntegrate[h^2 If[kx==0,L,Sin[kx L]/kx]^2 Tan[\[Beta]1]^2 (\[Gamma]+h Tan[\[Beta]2] (-2 \[Alpha]+h \[Beta] Tan[\[Beta]2]))+kx (kx \[Beta] Sin[kx L]^2+Sin[2 kx L] (\[Alpha]-h \[Beta] (Tan[\[Beta]1]+Tan[\[Beta]2])))+Cos[kx L]^2 (\[Gamma]+h (Tan[\[Beta]1]+Tan[\[Beta]2]) (-2 \[Alpha]+h \[Beta] (Tan[\[Beta]1]+Tan[\[Beta]2])))+2 h If[kx==0,L,Sin[kx L]/kx] Tan[\[Beta]1] (kx Sin[kx L] (\[Alpha]-h \[Beta] Tan[\[Beta]2])+Cos[kx L] (\[Gamma]+h Tan[\[Beta]2] (-2 \[Alpha]+h \[Beta] Tan[\[Beta]2])+h Tan[\[Beta]1] (-\[Alpha]+h \[Beta] Tan[\[Beta]2]))),{L,0,s}]


(* ::Input::Initialization:: *)
QuadBetaYTablePos[\[Alpha]_,\[Beta]_,\[Gamma]_,k_,s_]:=NIntegrate[\[Beta] Cosh[k L]^2+(\[Gamma] Sinh[k L]^2-k \[Alpha] Sinh[2 k L])/k^2,{L,0,s}]


(* ::Input::Initialization:: *)
QuadBetaYTableNeg[\[Alpha]_,\[Beta]_,\[Gamma]_,k_,s_]:=NIntegrate[\[Beta] Cos[k L]^2+(\[Gamma] Sin[k L]^2-k \[Alpha] Sin[2 k L])/k^2,{L,0,s}]


(* ::Input::Initialization:: *)
DriftBetaYTable[\[Alpha]_,\[Beta]_,\[Gamma]_,s_]:=NIntegrate[-2 L \[Alpha]+\[Beta]+L^2 \[Gamma],{L,0,s,s/10}]


(* ::Input::Initialization:: *)
DipoleBetaYTable[\[Alpha]_,\[Beta]_,\[Gamma]_,ky_,\[Beta]1_,\[Beta]2_,\[CurlyPhi]_,h_,s_]:=NIntegrate[\[Beta] Cos[ky L]^2-2 Cos[ky L] If[ky==0,L,Sin[ky L]/ky] (\[Alpha]+h \[Beta] Tan[\[Beta]2-\[CurlyPhi]])+If[ky==0,L,Sin[ky L]/ky]^2 (\[Gamma]+h Tan[\[Beta]2-\[CurlyPhi]] (2 \[Alpha]+h \[Beta] Tan[\[Beta]2-\[CurlyPhi]])),{L,0,s}]


(* ::Input::Initialization:: *)
QuadGammaYTablePos[\[Alpha]_,\[Beta]_,\[Gamma]_,k_,s_]:=NIntegrate[\[Gamma] Cosh[k L]^2+k (k \[Beta] Sinh[k L]^2-\[Alpha] Sinh[2 k L]),{L,0,s}]


(* ::Input::Initialization:: *)
QuadGammaYTableNeg[\[Alpha]_,\[Beta]_,\[Gamma]_,k_,s_]:=NIntegrate[Cos[k L] (\[Gamma] Cos[k L]+k \[Alpha] Sin[k L])-k Sin[k L] (-\[Alpha] Cos[k L]-k \[Beta] Sin[k L]),{L,0,s}]


(* ::Input::Initialization:: *)
DriftGammaYTable[\[Alpha]_,\[Beta]_,\[Gamma]_,s_]:=NIntegrate[\[Gamma],{L,0,s,s/10}]


(* ::Input::Initialization:: *)
DipoleGammaYTable[\[Alpha]_,\[Beta]_,\[Gamma]_,ky_,\[Beta]1_,\[Beta]2_,h_,s_]:=NIntegrate[h^2 If[ky==0,L,Sin[ky L]/ky]^2 Tan[\[Beta]1]^2 (\[Gamma]+h Tan[\[Beta]2] (2 \[Alpha]+h \[Beta] Tan[\[Beta]2]))+ky (ky \[Beta] Sin[ky L]^2+Sin[2 ky L] (\[Alpha]+h \[Beta] (Tan[\[Beta]1]+Tan[\[Beta]2])))+Cos[ky L]^2 (\[Gamma]+h (Tan[\[Beta]1]+Tan[\[Beta]2]) (2 \[Alpha]+h \[Beta] (Tan[\[Beta]1]+Tan[\[Beta]2])))-2 h If[ky==0,L,Sin[ky L]/ky] Tan[\[Beta]1] (ky Sin[ky L] (\[Alpha]+h \[Beta] Tan[\[Beta]2])+Cos[ky L] (\[Gamma]+h Tan[\[Beta]1] (\[Alpha]+h \[Beta] Tan[\[Beta]2])+h Tan[\[Beta]2] (2 \[Alpha]+h \[Beta] Tan[\[Beta]2]))),{L,0,s}]


(* ::Input::Initialization:: *)
QuadK2[latt_]:=Select[MADFlatten[latt],#[[2]]==="Quadrupole"&][[All,4]]


(* ::Input::Initialization:: *)
QuadChromX[latt_]:=Block[{\[Beta]x,\[Gamma],h,K2,\[Eta]x,\[Eta]xprime,L},\[Beta]x=QuadBeta[latt];\[Gamma]=QuadGamma[latt];h=Table[0,{Length[Select[MADFlatten[latt],#[[2]]==="Quadrupole"&]]}];hprime=h;\[Gamma]=QuadGamma[latt];K2=QuadK2[latt];\[Eta]x=QuadDisp[latt];\[Eta]xprime=QuadDispPrime[latt];L=Select[MADFlatten[latt],#[[2]]==="Quadrupole"&][[All,3]];
-(1/(4 \[Pi]) (#[[1]](#[[7]]-2 #[[5]]^2-2 #[[7]] #[[5]] #[[2]]-#[[6]] #[[3]])+#[[1]] #[[5]] #[[2]](#[[5]]^2-#[[7]])+#[[4]] #[[5]] #[[2]]))&/@Transpose[{\[Beta]x,\[Eta]x,\[Eta]xprime,\[Gamma],h,hprime,K2}]
]


(* ::Input::Initialization:: *)
BendChromX[latt_]:=Block[{\[Beta]x,\[Gamma],h,K2,\[Eta]x,\[Eta]xprime,L},\[Beta]x=DipoleBeta[latt];\[Gamma]=DipoleGamma[latt];h=Select[MADFlatten[latt],#[[2]]==="SectorBend"&][[All,6]];hprime=h;K2=Select[MADFlatten[latt],#[[2]]==="SectorBend"&][[All,4]];\[Eta]x=DipoleDisp[latt];\[Eta]xprime=DipoleDispPrime[latt];L=Select[MADFlatten[latt],#[[2]]==="SectorBend"&][[All,3]];
-(1/(4 \[Pi]) (#[[1]](#[[7]]-2 #[[5]]^2-2 #[[7]] #[[5]] #[[2]]-#[[6]] #[[3]])+#[[1]] #[[5]] #[[2]](#[[5]]^2-#[[7]])+#[[4]] #[[5]] #[[2]]))&/@Transpose[{\[Beta]x,\[Eta]x,\[Eta]xprime,\[Gamma],h,hprime,K2}]
]


(* ::Input::Initialization:: *)
TotalChromX[latt_]:=Plus@@Flatten[{QuadChromX[latt],BendChromX[latt]}]


(* ::Input::Initialization:: *)
QuadChromY[latt_]:=Block[{\[Beta]y,\[Gamma],h,K2,\[Eta]x,\[Eta]xprime,L},\[Beta]y=QuadBetaY[latt];\[Gamma]=QuadGammaY[latt];h=Table[0,{Length[Select[MADFlatten[latt],#[[2]]==="Quadrupole"&]]}];hprime=h;K2=QuadK2[latt];\[Eta]x=QuadDisp[latt];\[Eta]xprime=QuadDispPrime[latt];L=Select[MADFlatten[latt],#[[2]]==="Quadrupole"&][[All,3]];
-(1/(4 \[Pi]) (#[[1]](-#[[7]]+#[[7]] #[[5]] #[[2]]+#[[6]] #[[3]])))&/@Transpose[{\[Beta]y,\[Eta]x,\[Eta]xprime,\[Gamma],h,hprime,K2}]
]


(* ::Input::Initialization:: *)
BendChromY[latt_]:=Block[{\[Beta]y,\[Gamma],h,K2,\[Eta]x,\[Eta]xprime,L},\[Beta]y=DipoleBetaY[latt];\[Gamma]=DipoleGammaY[latt];h=Table[0,{Length[Select[MADFlatten[latt],#[[2]]==="SectorBend"&]]}];hprime=h;K2=Select[MADFlatten[latt],#[[2]]==="SectorBend"&][[All,4]];\[Eta]x=DipoleDisp[latt];\[Eta]xprime=DipoleDispPrime[latt];L=Select[MADFlatten[latt],#[[2]]==="SectorBend"&][[All,3]];
-(1/(4 \[Pi]) (#[[1]](-#[[7]]+#[[7]] #[[5]] #[[2]]+#[[6]] #[[3]])))&/@Transpose[{\[Beta]y,\[Eta]x,\[Eta]xprime,\[Gamma],h,hprime,K2}]
]


(* ::Input::Initialization:: *)
TotalChromY[latt_]:=Plus@@Flatten[{QuadChromY[latt],BendChromY[latt]}]


(* ::Input::Initialization:: *)
MLCChromaticity[latt_]:={TotalChromX[MADFlatten[latt]],TotalChromY[MADFlatten[latt]]}


(* ::Input::Initialization:: *)
End[]


(* ::Input::Initialization:: *)
EndPackage[]


(* ::Code::Initialization:: *)
(*Histogram[1000 trackingdata[[All,1,2]],BarStyle->Red,Frame->True,GridLines->None,BaseStyle->{FontFamily->"Courier",FontSize->14},FrameLabel->{"t [fs]","Frequency","Divergence: "<>ToString[10^3 StandardDeviation[trackingdata[[All,1,2]]]]<>" mrad",""}]*)



