(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["MinimumVolumeEllipse`"]


(* ::Input::Initialization:: *)
MinimumVolumeEllipse::usage="MinimumVolumeEllipse[P,tolerance] provides the matrix A for determining the Minimum volume ellipse covering the points P, along with the centre point array c."


(* ::Input::Initialization:: *)
MinimumVolumeEllipseNoConvexHull::usage="MinimumVolumeEllipseNoConvexHull[P,tolerance] provides the matrix A for determining the Minimum volume ellipse covering the points P, along with the centre point array c."


(* ::Input::Initialization:: *)
MinimumVolumeEllipsePlot::usage="MinimumVolumeEllipse[P,tol,plotopts] provides a plot of the Minimum volume ellipse covering the points P."


(* ::Input::Initialization:: *)
MinimumVolumeEllipsePlot::usage="MinimumVolumeEllipse[A,c,plotopts] provides a plot of the Minimum volume ellipse covering the points P."


(* ::Input::Initialization:: *)
MinimumVolumeEllipsePlotDisk::usage="MinimumVolumeEllipse[A,c,plotopts] provides a plot of the Minimum volume ellipse covering the points P."


(* ::Input::Initialization:: *)
MinimumVolumeEllipsePlotDiskList::usage="MinimumVolumeEllipse[A,c,plotopts] provides a plot of the Minimum volume ellipse covering the points P."


(* ::Input::Initialization:: *)
MinimumVolumeEllipseLogPlotDiskList::usage="MinimumVolumeEllipse[A,c,plotopts] provides a plot of the Minimum volume ellipse covering the points P."


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Input::Initialization:: *)
khachiyan[]:=Block[{},
X=Q.DiagonalMatrix[u].Transpose[Q];
M=Diagonal[Transpose[Q].PseudoInverse[X].Q];
maximum=Max[M];
j=Position[M,maximum][[1,1]];
stepsize=(maximum-d-1)/((d+1)(maximum-1));
newu=(1-stepsize)u;
newu[[j]]=newu[[j]]+stepsize;
count=count+1;
err=Norm[newu-u];
u=newu;
err
]


(* ::Input::Initialization:: *)
MinimumVolumeEllipseNoConvexHull[P_,tol_]:=Block[{d,Np,Q,count,err,u,U,A,c},
{d,Np}=Dimensions[P];
Q=ConstantArray[0,{d+1,Np}];
Q[[1;;d]]=P[[1;;d,1;;Np]];
Q[[d+1]]=ConstantArray[1,{Np}];
count=1;
err=1;
u=(1/Np)*ConstantArray[1,{Np}];
While[err > tol,khachiyan[]];
U = DiagonalMatrix[u];
A = (1/d) *PseudoInverse[P.U.Transpose[P] - Transpose[{P.u}].{P.u}];
c=P.u;
{A,c}
]


(* ::Input::Initialization:: *)
MinimumVolumeEllipse[Pin_,tol_]:=Block[{d,Np,Q,count,err,u,U,A,c,P},
P=Transpose[MeshCoordinates[ConvexHullMesh[Transpose[Pin]]]];
{d,Np}=Dimensions[P];
Q=ConstantArray[0,{d+1,Np}];
Q[[1;;d]]=P[[1;;d,1;;Np]];
Q[[d+1]]=ConstantArray[1,{Np}];
count=1;
err=1;
u=(1/Np)*ConstantArray[1,{Np}];
While[err > tol,khachiyan[]];
U = DiagonalMatrix[u];
A = (1/d) *PseudoInverse[P.U.Transpose[P] - Transpose[{P.u}].{P.u}];
c=P.u;
{A,c}
]


(* ::Input::Initialization:: *)
MinimumVolumeEllipsePlot[P_,tol_Real|tol_Integer,opts___Rule]:=Block[{A,uu,qq,vv,a,b,c,theta},
{A,c}=MinimumVolumeEllipse[P,tol];
{uu,qq,vv}=SingularValueDecomposition[A];
{a,b}=1/Sqrt[Diagonal[qq]];
theta=Range[0,2\[Pi]+1/20,1/20];
ListPlot[{Transpose[P],c+#&/@Transpose[vv.{a Cos[theta],b Sin[theta]}]},opts,Joined->{False,True},PlotRange->All]
]


(* ::Input::Initialization:: *)
Clear[addEpilog];


(* ::Input::Initialization:: *)
addEpilog[g_Legended,epi_List,opts___Rule]:=Quiet@With[{styles=Cases[g[[1]],{dir__,__GeometricTransformation|__Point|__Line}:>Directive[dir],-5]},
Show[g,Epilog->Flatten[{styles,epi},{2}],FilterRules[{opts},Options[Show]]]]


(* ::Input::Initialization:: *)
addEpilog[g_Graphics,epi_List,opts___Rule]:=Quiet@With[{styles=Cases[g[[1]],{dir__,__GeometricTransformation|__Point|__Line}:>Directive[dir],-5]},
Show[g,Epilog->Flatten[{styles,epi},{2}],FilterRules[{opts},Options[Show]]]]


(* ::Input::Initialization:: *)
MinimumVolumeEllipsePlotDisk[P_,tol_Real|tol_Integer,opts___Rule]:=Block[{data,A,uu,qq,vv,a,b,c},
{A,c}=MinimumVolumeEllipse[P,tol];
{uu,qq,vv}=SingularValueDecomposition[A];
{a,b}=1/Sqrt[Diagonal[qq]];
addEpilog[ListPlot[{Transpose[P]},FilterRules[{opts},Options[ListPlot]],Joined->{False},PlotRange->All],{{Opacity[0.2],Translate[Rotate[Disk[{0,0},{b,a}],{{1,1},vv.{1,1}}],c]}},opts]
]


(* ::Input::Initialization:: *)
MinimumVolumeEllipsePlotDiskList[Plist_,tol_Real|tol_Integer,opts___Rule]:=Block[{data,A,uu,qq,vv},
data=Block[{P=#,a,b,c},
{A,c}=MinimumVolumeEllipse[P,tol];
{uu,qq,vv}=SingularValueDecomposition[A];
{a,b}=1/Sqrt[Diagonal[qq]];
{Transpose[P],a,b,c,vv.{1,1}}]&/@Plist;
addEpilog[ListPlot[data[[All,1]],FilterRules[{opts},Options[ListPlot]],PlotRange->All],Block[{p,a,b,c,d},{p,a,b,c,d}=#;{Opacity[0.2],Translate[Rotate[Disk[{0,0},{b,a}],{{1,1},d}],c]}]&/@data,opts]
]


(* ::Input::Initialization:: *)
MinimumVolumeEllipseLogPlotDiskList[Plist_,tol_Real|tol_Integer,opts___Rule]:=Block[{data,A,c,uu,qq,vv,a,b,logplot,ticks,range,gr},
data=Block[{P=#},
{A,c}=MinimumVolumeEllipse[Log[P],tol];
{uu,qq,vv}=SingularValueDecomposition[A];
{a,b}=1/Sqrt[Diagonal[qq]];
{Transpose[Log[P]],a,b,c,vv.{1,1},Transpose[P]}]&/@Plist;
Off[NumberForm::iprf];
logplot=ListLogLogPlot[data[[All,-1]],FilterRules[{opts},PlotRange]];
ticks=Quiet[AbsoluteOptions[logplot,Ticks]][[1,2]];
range=Quiet[AbsoluteOptions[logplot,PlotRange][[1]]];
gr=addEpilog[ListPlot[data[[All,1]],Ticks->ticks,range,FrameTicks->Evaluate@{{ticks[[2]],None},{ticks[[1]],None}},FilterRules[{opts},Options[ListPlot]],PlotRange->All],Block[{p,a,b,c,d,p2},{p,a,b,c,d,p2}=#;{Opacity[0.2],Translate[Rotate[Scale[Disk[{0,0},{1,1}],{b,a}],{{1,1},d}],c]}]&/@data,Sequence@@{range,opts}];
gr
]


(* ::Input::Initialization:: *)
End[]


(* ::Input::Initialization:: *)
EndPackage[]
