(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Quiet[BeginPackage["ElementInput`",{"sddsInterpret`","numberRight`"}]]


<<sddsBinaryInterpret`


<<numberRight`


Quiet[<<madtomma`mfs`]


Clear[element,elementDefinition]


element::usage="";


line::usage="";


elementLine::usage=""


ElementDraw::usage="";


ElegantTwiss::usage="";


MADTwiss::usage="";


MADElementNames::usage="";


ElementPositions::usage="";


elementInterpretLTE::usage="elementInterpretLTE[filename]";


elementInfo::usage="elementInfo[lattice]";


Options[ElementDraw]={Labels->False,Thickness->0.001,Monitors->True,Lengths->False,Filled->False,WidthScale->1.4,Symms->True,Bends->True,Offset->0,ShowPicture->True,Fontsize->12,Imagesize->800,DrawLabel->"",CheckClosed->False,Frame->True,MADDrawText->False,ElementDrawText->False,Element->Nothing,BendSign->1};


quad::usage="";


sext::usage="";


sbend::usage="";


rbend::usage="";


drift::usage="";


watch::usage="";


marker::usage="";


bpm::usage="";


kick::usage="";


hkick::usage="";


vkick::usage="";


rfca::usage="";


ElegantWriteLattice::usage="";


ElegantRun::usage="";


commandDefinition::usage="";


ElegantWriteCommands::usage="";


Begin["`Private`"];


allElements={};


SetAttributes[replaceRuleNames,{HoldAll,Listable}];
replaceRuleNames[Rule[x_,y_]]:=Block[{},
Rule[ToUpperCase[ToString[HoldForm[x]]],y]
]


element[list__Rule]/;MemberQ[{list}[[All,1]],"NAME"]:=Block[{name},
name="NAME"/.{list};
allElements=Union[AppendTo[allElements,name]];
Clear[Evaluate[name]];
Evaluate[Symbol@name]=elementDefinition[list]
]


element[magnet_,var__Symbol]:=var/.Evaluate[magnet]


Clear[GetProperty];
GetProperty[elementDefinition[list__],var_]:=Block[{},
ToUpperCase[var]/.{list}
]


Unprotect[SetProperty];


SetProperty[elementDefinition[x__], {y_Rule}] := SetProperty[elementDefinition[x], Rule[ToUpperCase[ToString[y[[1]]]], y[[2]]]]


SetProperty[elementDefinition[x__], rules_List] := Fold[SetProperty[#1, {#2}] &, elementDefinition[x], rules]


SetProperty::"wrongtype" = "There are no elements of type \"`1`\" to modify.";


SetProperty[type_String, {y__Rule}] := Block[{list},
  list = Select[ToExpression[allElements], MemberQ[Map[ToUpperCase,#,{2}], Rule["TYPE",ToUpperCase[type]], 2] &];
  If[Length[list] > 0,
SetProperty[#, y] & /@ list,
Message[SetProperty::"wrongtype", type]
]
]


elementDefinition/:SetProperty[elementDefinition[x__],y__Rule]:=Block[{name},
name="NAME"/.Join[{y},{x}];
element[Sequence@@Map[Rule[#,#/.Join[{y},{x}]]&,Union[Join[{y},{x}][[All,1]]]]]
]


elementDefinition/:SetProperty[elementDefinition[x__],Rule[y_,Null]]:=Block[{name},
name="NAME"/.Join[{Rule[y,Null]},{x}];
element[Sequence@@Map[Rule[#,#/.{x}]&,Complement[{x}[[All,1]],{y}]]]
]


elementDefinition/:Rule[elementDefinition[list__][var_String],val_]:=SetProperty[elementDefinition[list], Rule[ToUpperCase[var],val]]


elementDefinition/:elementDefinition[list__][Rule[var_String,val_]]:=SetProperty[elementDefinition[list], Rule[ToUpperCase[var],val]]


elementDefinition/:elementDefinition[list__][rules__Rule]:=SetProperty[elementDefinition[list],Map[Rule[ToUpperCase[#[[1]]],#[[2]]]&,{rules}]]


elementDefinition/:Rule[elementDefinition[list__][var_String],val_]:=SetProperty[elementDefinition[list], Rule[ToUpperCase[var],val]]


elementDefinition /: Part[elementDefinition[list__], var_] := If[#===ToUpperCase[var],0,#]&[ToUpperCase[var] /. MapAt[ToUpperCase,{list},{All,1}]]


elementDefinition /: elementDefinition[list__][ var_String] := If[#===ToUpperCase[var],0,#]&[ToUpperCase[var] /. MapAt[ToUpperCase,{list},{All,1}]]


elementDefinition /: elementDefinition[list__][ var_String]/;ToUpperCase[var]=="LENGTH" := Block[{val},If[(val="LENGTH" /. {list})==="LENGTH",If[(val="L" /. {list})==="L",0,val],val]]


elementDefinition/:ReplaceAll[var_String|var_Symbol,elementDefinition[list__]]:=ToUpperCase[ToString[var]]/.{list}


commandDefinition/:ReplaceAll[var_String|var_Symbol,commandDefinition[list__]]:=ToUpperCase[ToString[var]]/.{list}


elementDefinition/:ReplaceAll[var_List,elementDefinition[list__]]:=ToUpperCase[ToString[#]]/.{list}&/@var


commandDefinition/:ReplaceAll[var_List,commandDefinition[list__]]:=ToUpperCase[ToString[#]]/.{list}&/@var


elementDefinition/:capitalRuleNames[elementDefinition[list__]]:=Map[Rule[ToUpperCase[#[[1]]],#[[2]]]&,{list}]


commandDefinition/:capitalRuleNames[commandDefinition[list__]]:=Map[Rule[StringReplace[ToLowerCase[#[[1]]],"sdds"->"SDDS"],#[[2]]]&,{list}]


elementLine/:ReplaceAll[var_,elementLine[list_]]/;Length[{list}]>1:=ToUpperCase[ToString[var]]/.{#}&/@list


elementLine/:ReplaceAll[var_,elementLine[list_]]/;Length[{list}]==1:=ToUpperCase[ToString[var]]/.list


MapAt[ToUpperCase,{"a"->1},{All,1}]


commandDefinition /: commandDefinition[list__][ var_String] := If[#===ToUpperCase[var],Print[#];0,#]&[ToUpperCase[var] /. MapAt[ToUpperCase,{list},{All,1}]]


elementLine/:-elementLine[list__]:=elementLine[Sequence@@Cases[{list},Except[Rule["REVERSED",_Boolean]]],"REVERSED"->True]


elementLine/:-elementLine[list__]:=elementLine[Sequence@@Reverse[Cases[{list},Except[Rule["REVERSED",_Boolean]]]],"REVERSED"->True]


elementDefinition/:Times[elementDefinition[list__],multiplier_]:=Sequence@@Table[elementDefinition[list],multiplier]
elementDefinition/:Times[multiplier_,elementDefinition[list__]]:=Sequence@@Table[elementDefinition[list],multiplier]


elementLine/:Times[elementLine[list__],multiplier_]:=Sequence@@Table[elementLine[list],multiplier]
elementLine/:Times[multiplier_,elementLine[list__]]:=Sequence@@Table[elementLine[list],multiplier]


elementLine/:Names[a:elementLine[list__],ignoreReverse_:False]:=Block[{},
reversed="REVERSED"/.a/.{"REVERSED"->False};
If[ignoreReverse&&reversed,Reverse[#],#]&@
Flatten[(-2 Boole["REVERSED"/.#/.{"REVERSED"->False}]+1) ("NAME"/.#/.{"NAME"->{}})&/@Select[{list},(Head[#]===elementDefinition||Head[#]===elementLine&)]]
]


elementLine/:Names[a:elementLine[list__],n_Integer:1]:=Flatten[(-2 Boole["REVERSED"/.#/.{"REVERSED"->False}]+1) ("NAME"/.#/.{"NAME"->{}})&/@Cases[a,(elementLine|elementDefinition)[__],n]]


elementLine/:Names[a:elementLine[list__],\[Infinity]]:=Flatten[(-2 Boole["REVERSED"/.#/.{"REVERSED"->False}]+1) ("NAME"/.#/.{"NAME"->{}})&/@Join[Cases[a,elementDefinition[__],\[Infinity]]]]


elementLine/:Length[elementLine[list__]]:=Block[{},Total@Flatten[(-2Boole["REVERSED"/.#/.{"REVERSED"->False}]+1)("LENGTH"/.#/.{"LENGTH"->{}})&/@Map[Cases[#,_Rule,\[Infinity]]&,Flatten[elementLine[list]]]]]


elementLine/:Lengths[elementLine[list__]]:=Block[{},Flatten[(-2Boole["REVERSED"/.#/.{"REVERSED"->False}]+1)("LENGTH"/.#/.{"LENGTH"->0})&/@Map[Cases[#,_Rule,\[Infinity]]&,Flatten[elementLine[list]]]]]


elementLine/:Length[list__elementLine]:=Block[{},Total@Map[Length,Flatten[{list}]]]


elementLine/:ReplaceAll[var_String|var_Symbol,elementLine[list__]]:=ToUpperCase[ToString[var]]/.Cases[{list},_Rule]


elementLine/:Flatten[a:elementLine[list__]]:=ToExpression[Names[a,\[Infinity]]]


elementLine/:Flatten[a:elementLine[list__],n_Integer]:=ToExpression[Names[a,Integer]]


elementLine/:Flatten[a__elementLine]:=ToExpression[Names[elementLine[a],\[Infinity]]]


elementLine/:Part[elementLine[a__],pos_]:=Flatten[elementLine[a]][[pos]]


elementLine/:Part[elementLine[a__],All,pos_]:=#[[ToUpperCase@pos]]&/@Flatten[elementLine[a]]


Unprotect[Flatten];
Flatten[{a__elementLine}]:=ToExpression[Names[elementLine[a],\[Infinity]]]
Protect[Flatten];


elementLine/:(a:elementLine[list__])[var_]:=If[#===ToUpperCase[var],0,#]&[ToUpperCase[var] /. #]&/@Flatten[a]


elementLine/:(a:elementLine[list__])["NAME"]:=("NAME"/.a/.{"NAME"->{}})


elementLine/:(a:elementLine[list__])[All,str_String]:=(#[str]&/@Flatten[a])


elementLine/:(a:elementLine[list__])[All,Rule[a_,b_]]:=(#[Rule[a,b]]&/@Flatten[a])


elementLine/:(a:elementLine[list__])[All,rules__Rule]:=Block[{rule=#},#[rule]&/@Flatten[a]]&/@{rules}


elementLine/:Select[(a:elementLine[list__]),var_->type_]:=elementLine[Sequence@@(Select[Flatten[a],StringMatchQ[ToLowerCase[#[var]],ToLowerCase[type]]&])]


elementLine/:Join[a__elementLine]:=elementLine[a]


Clear[line];
ClearAttributes[line,HoldAll];
SetAttributes[line,HoldFirst]
line[name_,{list__}]:=Block[{},
Clear[Evaluate[ToString[HoldForm[name]]]];
Evaluate[ToExpression[ToString[name]]]:=elementLine[Sequence@@ToExpression[Evaluate[Names[elementLine[Evaluate[list]]]]],"NAME"->ToString[HoldForm[name]]];
name
]


Clear[line];
ClearAttributes[line,HoldAll];
SetAttributes[line,HoldAll];
line[name_,{list__}]:=Block[{nameS},
Clear[Evaluate[ToString[HoldForm[name]]]];
Evaluate[ToExpression[ToString[HoldForm[name]]]]:=elementLine["NAME"->ToString[HoldForm[name]],Sequence@@
Evaluate[Map[
Which[
Head[#]===Times,#[[1]]*ToExpression[#[[2]]],
True,ToExpression[#]
]&,
Names[elementLine[list],1]]]];
name
]


Clear[line];
ClearAttributes[line,HoldAll];
SetAttributes[line,HoldAll];
line[name_,{list__}]:=Block[{nameS},
Clear[Evaluate[ToString[HoldForm[name]]]];
Evaluate[ToExpression[ToString[HoldForm[name]]]]:=elementLine["NAME"->ToString[HoldForm[name]],Sequence@@
Map[
Which[
Head[#]===Times,#[[1]]*ToExpression[#[[2]]],
True,ToExpression[#]
]&,
Names[elementLine[list]]]];
name
]


Unprotect[quad,sext,sbend,rbend,drift]


Clear[quad,sext,sbend,csbend,quadrupole,kquadrupole,sextupole,ksextupole,sectorbend,rbend,crbend,csrcsbend,drift,marker,monitor,bpm,hkick,vkick,kick,lcav,rfca,profile,watch]


SetAttributes[watch,HoldAll];
watch[name_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Watch","FILENAME"->"\"%s-%03ld.w1\"","NAME"->ToString[HoldForm[name]],"LABEL"->If[label=="",Null,label],Sequence@@replaceRuleNames[{extra}]]
]
watch[name_,filename_String:"\"%s-%03ld.w1\"",label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Watch","FILENAME"->filename,"NAME"->ToString[HoldForm[name]],"LABEL"->If[label=="",Null,label],Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[quad,HoldAll];
quad[in__]:=kquadrupole[in]


SetAttributes[quadrupole,HoldAll];
quadrupole[name_,length_,strength_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Quadrupole","LENGTH"->length,"K1"->strength,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[kquadrupole,HoldAll];
kquadrupole[name_,length_,strength_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"KQuad","LENGTH"->length,"K1"->strength,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[sextupole,HoldAll];
sextupole[name_,length_,strength_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Sextupole","LENGTH"->length,"K2"->strength,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


Clear[sext];
SetAttributes[sext,HoldAll];
sext[in__]:=ksextupole[in]


SetAttributes[ksextupole,HoldAll];
ksextupole[name_,length_,strength_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"KSext","LENGTH"->length,"K2"->strength,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[sectorbend,HoldAll];
sectorbend[name_,length_,strength_,angle_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"SectorBend","LENGTH"->length,"K1"->strength,"BENDANGLE"->angle,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[sbend,HoldAll];
sbend[in__]:=csbend[in]


SetAttributes[rbend,HoldAll];
rbend[in__]:=crbend[in]


SetAttributes[csbend,HoldAll];
csbend[name_,length_,strength_,angle_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"CSBend","LENGTH"->length,"K1"->strength,"BENDANGLE"->angle,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[crbend,HoldAll];
crbend[in__]:=Block[{elem},
elem=csbend[in];
SetProperty[elem,{"E1"->elem[["E1"]]+elem[["BENDANGLE"]]/2,"E2"->elem[["E2"]]+elem[["BENDANGLE"]]/2}]
]


SetAttributes[csrcsbend,HoldAll];
csrcsbend[name_,length_,strength_,angle_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"CSRCSBend","LENGTH"->length,"K1"->strength,"BENDANGLE"->angle,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[drift,HoldAll];
drift[name_,length_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"EDrift","LENGTH"->length,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[marker,HoldAll];
marker[name_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Mark","NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[bpm,HoldAll];
bpm[in__]:=monitor[in]


SetAttributes[vbpm,HoldAll];
vbpm[in__]:=vmonitor[in]


SetAttributes[hbpm,HoldAll];
hbpm[in__]:=hmonitor[in]


SetAttributes[vmonitor,HoldAll];
vmonitor[name_,length_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"VMon","LENGTH"->length,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[hmonitor,HoldAll];
hmonitor[name_,length_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"HMon","LENGTH"->length,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[monitor,HoldAll];
monitor[name_,length_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Monitor","LENGTH"->length,"CO_FITPOINT"->0,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[hkick,HoldAll];
hkick[name_,length_,kick_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"HKicker","LENGTH"->length,"KICK"->kick,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[vkick,HoldAll];
vkick[name_,length_,kick_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"VKicker","LENGTH"->length,"KICK"->kick,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[kick,HoldAll];
kick[name_,length_,hkick_,vkick_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"Kicker","LENGTH"->length,"KICK"->hkick,"VKICK"->vkick,"NAME"->ToString[HoldForm[name]],"LABEL"->label,Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[lcav,HoldAll];
lcav[in__]:=Block[{elem},
elem=rfca[in];
SetProperty[elem,{"PHASE"->elem[["CAVITYPHASE"]]*360+90,"VOLT"->elem[["VOLTAGEGAIN"]]*10^6,"FREQ"->elem[["FREQUENCY"]]*10^6,"CAVITYPHASE"->Null,"VOLTAGEGAIN"->Null,"FREQUENCY"->Null}]
]


SetAttributes[rfca,HoldAll];
rfca[name_,length_,label_String:"",extra___Rule]:=Block[{},
element["TYPE"->"RFCA","LENGTH"->length,"NAME"->ToString[HoldForm[name]],"LABEL"->If[label=="",Null,label],Sequence@@replaceRuleNames[{extra}]]
]


SetAttributes[profile,HoldAll];
profile[name_,length_,label_String:"",extra___Rule]:=monitor[name,length,label,extra]


wrapString[inputstring_String]:=Block[{string=inputstring,string2="",stringpos},
If[StringLength[string]>80,
stringpos:=Last[Select[StringPosition[string,","][[All,1]],#<80&]];
While[StringLength[string]>80,string2=StringJoin[string2,StringTake[string,stringpos]<>"&\n"];string=StringDrop[string,stringpos]],
string2=string;
];
string2]


wrapString[inputstring_String]:=Block[{splitstring=StringSplit[inputstring,"\n"],stringpos,wrappedstrings},
wrappedstrings=Block[{string=#,string2=""},
If[StringLength[string]>80,
stringpos:=Last[Select[StringPosition[string,","][[All,1]],#<80&]];
While[StringLength[string]>80,string2=StringJoin[string2,StringTake[string,stringpos]<>"&\n"];string=StringDrop[string,stringpos]];
string2=StringJoin[string2,string],
string2=string;
string2];
string2<>"\n"
]&/@splitstring;
StringJoin@@wrappedstrings
]


MADRules["SBEND"]={"TYPE"->"sbend","LENGTH"->"L","K1","BENDANGLE"->"angle","LABEL"->"Type","E1","E2"}


MADRules["CSBEND"]={"TYPE"->"sbend","LENGTH"->"L","K1","BENDANGLE"->"angle","LABEL"->"Type","E1","E2"}


MADRules["KQUAD"]={"TYPE"->"quad","LENGTH"->"L","K1","LABEL"->"TYPE"}


MADRules["DRIFT"]={"TYPE"->"drift", "LENGTH"->"L","LABEL"->"TYPE"}


MADRules["CSRDRIFT"]={"TYPE"->"drift", "LENGTH"->"L","LABEL"->"TYPE"}


MADRules["MAXAMP"]={"TYPE"->"drift", "LENGTH"->"L","LABEL"->"TYPE"}


MADRules["KICKER"]={"TYPE"->"kicker","LENGTH"->"L","LABEL"->"TYPE"}


MADRules["MONI"]={"TYPE"->"drift","LENGTH"->"L","LABEL"->"TYPE"}


MADRules["MONITOR"]={"TYPE"->"drift","LENGTH"->"L","LABEL"->"TYPE"}


MADRules["SCREEN"]={"TYPE"->"drift","LENGTH"->"L","LABEL"->"TYPE"}


MADRules["VALVE"]={"TYPE"->"drift","LENGTH"->"L","LABEL"->"TYPE"}


MADRules["BELLOWS"]={"TYPE"->"drift","LENGTH"->"L","LABEL"->"TYPE"}


MADRules["SHUTTER"]={"TYPE"->"drift","LENGTH"->"L","LABEL"->"TYPE"}


MADRules["call"]={"filename"};


MADRules["use"]={"period"};


MADRules["select"]={"range", "flag","full"};


MADRules["optics"]={"filename", "betx","bety","alfx","alfy","columns"};


ElegantRules["ALPH"]={"XMAX", "XS1", "XS2", "DP1", "DP2", "XPUCK", "WIDTHPUCK", "DX", "DY", "DZ", "TILT", "PART", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["BGGEXP"]={"LFIELD", "FILENAME", "STRENGTH", "TILT", "DX", "DY", "DZ", "MAXIMUM_M", "MAXIMUM_2N", "Z_INTERVAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["BMAPXY"]={"STRENGTH", "ACCURACY", "METHOD", "FILENAME", "FX", "FY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["BMXYZ"]={"LFIELD", "STRENGTH", "ACCURACY", "METHOD", "FILENAME", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["BRAT"]={"ANGLE", "FSE", "ACCURACY", "METHOD", "FILENAME", "XVERTEX", "ZVERTEX", "XENTRY", "ZENTRY", "XEXIT", "ZEXIT", "DXMAP", "DZMAP", "YAWMAP", "FACTOR", "USE_FTABLE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["BUMPER"]={"ANGLE", "TILT", "DX", "DY", "DZ", "B2", "TIME_OFFSET", "PERIODIC", "PHASE_REFERENCE", "FIRE_ON_PASS", "N_KICKS", "WAVEFORM", "DEFLECTION_MAP", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["CENTER"]={"X", "XP", "Y", "YP", "S", "DELTA", "T", "ONCE_ONLY", "ON_PASS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["CEPL"]={"RAMP_TIME", "TIME_OFFSET", "VOLTAGE", "GAP", "STATIC_VOLTAGE", "TILT", "ACCURACY", "X_MAX", "Y_MAX", "DX", "DY", "PHASE_REFERENCE", "N_STEPS", "METHOD", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["CHARGE"]={"TOTAL", "PER_PARTICLE", "ALLOW_TOTAL_CHANGE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["CLEAN"]={"MODE", "XLIMIT", "XPLIMIT", "YLIMIT", "YPLIMIT", "TLIMIT", "DELTALIMIT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["CORGPIPE"]={"RADIUS", "PERIOD", "GAP", "DEPTH", "DT", "TMAX", "N_BINS", "INTERPOLATE", "SMOOTHING", "SG_HALFWIDTH", "SG_ORDER", "CHANGE_P0", "ALLOW_LONG_BEAM", "RAMP_PASSES", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["CSBEND"]={"ANGLE", "K1", "K2", "K3", "K4", "K5", "K6", "K7", "K8", "E1", "E2", "TILT", "H1", "H2", "HGAP", "FINT", "DX", "DY", "DZ", "FSE", "ETILT", "N_KICKS", "NONLINEAR", "SYNCH_RAD", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "EDGE_ORDER", "FRINGE", "INTEGRATION_ORDER", "EDGE1_KICK_LIMIT", "EDGE2_KICK_LIMIT", "KICK_LIMIT_SCALING", "USE_BN", "EXPANSION_ORDER", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "XREFERENCE", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "ISR", "ISR1PART", "SQRT_ORDER", "USE_RAD_DIST", "ADD_OPENING_ANGLE", "PHOTON_OUTPUT_FILE", "PHOTON_LOW_ENERGY_CUTOFF", "REFERENCE_CORRECTION", "TRACKING_MATRIX", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["CSRCSBEND"]={"ANGLE", "K1", "K2", "K3", "K4", "K5", "K6", "K7", "K8", "E1", "E2", "TILT", "H1", "H2", "HGAP", "FINT", "DX", "DY", "DZ", "FSE", "ETILT", "N_KICKS", "NONLINEAR", "LINEARIZE", "SYNCH_RAD", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "EDGE_ORDER", "INTEGRATION_ORDER", "BINS", "BIN_ONCE", "BIN_RANGE_FACTOR", "SG_HALFWIDTH", "SG_ORDER", "SGDERIV_HALFWIDTH", "SGDERIV_ORDER", "TRAPAZOID_INTEGRATION", "OUTPUT_FILE", "OUTPUT_INTERVAL", "OUTPUT_LAST_WAKE_ONLY", "STEADY_STATE", "IGF", "USE_BN", "EXPANSION_ORDER", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "ISR", "ISR1PART", "CSR", "BLOCK_CSR", "DERBENEV_CRITERION_MODE", "PARTICLE_OUTPUT_FILE", "PARTICLE_OUTPUT_INTERVAL", "SLICE_ANALYSIS_INTERVAL", "LOW_FREQUENCY_CUTOFF0", "LOW_FREQUENCY_CUTOFF1", "HIGH_FREQUENCY_CUTOFF0", "HIGH_FREQUENCY_CUTOFF1", "CLIP_NEGATIVE_BINS", "WAKE_FILTER_FILE", "WFF_FREQ_COLUMN", "WFF_REAL_COLUMN", "WFF_IMAG_COLUMN", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["CSRDRIFT"]={"ATTENUATION_LENGTH", "DZ", "N_KICKS", "SPREAD", "USE_OVERTAKING_LENGTH", "OL_MULTIPLIER", "USE_SALDIN54", "SALDIN54POINTS", "CSR", "SALDIN54NORM_MODE", "SPREAD_MODE", "WAVELENGTH_MODE", "BUNCHLENGTH_MODE", "SALDIN54_OUTPUT", "USE_STUPAKOV", "STUPAKOV_OUTPUT", "STUPAKOV_OUTPUT_INTERVAL", "SLICE_ANALYSIS_INTERVAL", "LINEARIZE", "LSC_BINS", "LSC_INTERPOLATE", "LSC_LOW_FREQUENCY_CUTOFF0", "LSC_LOW_FREQUENCY_CUTOFF1", "LSC_HIGH_FREQUENCY_CUTOFF0", "LSC_HIGH_FREQUENCY_CUTOFF1", "LSC_RADIUS_FACTOR", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["CWIGGLER"]={"B_MAX", "BX_MAX", "BY_MAX", "DX", "DY", "DZ", "TILT", "PERIODS", "STEPS_PER_PERIOD", "INTEGRATION_ORDER", "BY_FILE", "BX_FILE", "BY_SPLIT_POLE", "BX_SPLIT_POLE", "SYNCH_RAD", "ISR", "ISR1PART", "SINUSOIDAL", "VERTICAL", "HELICAL", "FORCE_MATCHED", "FIELD_OUTPUT", "VERBOSITY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["DRIF"]={"ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["DSCATTER"]={"PLANE", "FILENAME", "VALUENAME", "CDFNAME", "PDFNAME", "ONCEPERPARTICLE", "FACTOR", "PROBABILITY", "GROUPID", "RANDOMSIGN", "LIMITPERPASS", "LIMITTOTAL", "STARTONPASS", "ENDONPASS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["ECOL"]={"X_MAX", "Y_MAX", "DX", "DY", "OPEN_SIDE", "EXPONENT", "YEXPONENT", "INVERT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["EDRIFT"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["EHKICK"]={"KICK", "TILT", "CALIBRATION", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["EKICKER"]={"HKICK", "VKICK", "TILT", "HCALIBRATION", "VCALIBRATION", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["ELSE"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["EMATRIX"]={"ANGLE", "DX", "DY", "DZ", "TILT", "YAW", "PITCH", "ORDER", "C1", "C2", "C3", "C4", "C5", "C6", "DELTAP", "R11", "R12", "R13", "R14", "R15", "R16", "R21", "R22", "R23", "R24", "R25", "R26", "R31", "R32", "R33", "R34", "R35", "R36", "R41", "R42", "R43", "R44", "R45", "R46", "R51", "R52", "R53", "R54", "R55", "R56", "R61", "R62", "R63", "R64", "R65", "R66", "T111", "T121", "T122", "T131", "T132", "T133", "T141", "T142", "T143", "T144", "T151", "T152", "T153", "T154", "T155", "T161", "T162", "T163", "T164", "T165", "T166", "T211", "T221", "T222", "T231", "T232", "T233", "T241", "T242", "T243", "T244", "T251", "T252", "T253", "T254", "T255", "T261", "T262", "T263", "T264", "T265", "T266", "T311", "T321", "T322", "T331", "T332", "T333", "T341", "T342", "T343", "T344", "T351", "T352", "T353", "T354", "T355", "T361", "T362", "T363", "T364", "T365", "T366", "T411", "T421", "T422", "T431", "T432", "T433", "T441", "T442", "T443", "T444", "T451", "T452", "T453", "T454", "T455", "T461", "T462", "T463", "T464", "T465", "T466", "T511", "T521", "T522", "T531", "T532", "T533", "T541", "T542", "T543", "T544", "T551", "T552", "T553", "T554", "T555", "T561", "T562", "T563", "T564", "T565", "T566", "T611", "T621", "T622", "T631", "T632", "T633", "T641", "T642", "T643", "T644", "T651", "T652", "T653", "T654", "T655", "T661", "T662", "T663", "T664", "T665", "T666", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["EMITTANCE"]={"EMITX", "EMITY", "EMITNX", "EMITNY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["ENERGY"]={"CENTRAL_ENERGY", "CENTRAL_MOMENTUM", "MATCH_BEAMLINE", "MATCH_PARTICLES", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["EVKICK"]={"KICK", "TILT", "CALIBRATION", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["FLOOR"]={"X", "Y", "Z", "THETA", "PHI", "PSI", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["FMULT"]={"TILT", "DX", "DY", "DZ", "FSE", "N_KICKS", "SYNCH_RAD", "FILENAME", "SQRT_ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["FRFMODE"]={"FILENAME", "BIN_SIZE", "N_BINS", "RIGID_UNTIL_PASS", "USE_SYMM_DATA", "FACTOR", "CUTOFF", "OUTPUT_FILE", "FLUSH_INTERVAL", "RAMP_PASSES", "RESET_FOR_EACH_STEP", "LONG_RANGE_ONLY", "N_CAVITIES", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["FTABLE"]={"ANGLE", "L1", "L2", "E1", "E2", "TILT", "DX", "DY", "DZ", "FACTOR", "THRESHOLD", "INPUT_FILE", "N_KICKS", "VERBOSE", "SIMPLE_INPUT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["FTRFMODE"]={"FILENAME", "BIN_SIZE", "N_BINS", "RIGID_UNTIL_PASS", "USE_SYMM_DATA", "DX", "DY", "XFACTOR", "YFACTOR", "CUTOFF", "OUTPUT_FILE", "FLUSH_INTERVAL", "RAMP_PASSES", "RESET_FOR_EACH_STEP", "LONG_RANGE_ONLY", "N_CAVITIES", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["GFWIGGLER"]={"B_MAX", "SHIM_SCALE", "DX", "DY", "DZ", "TILT", "PERIODS", "STEP", "ORDER", "END_POLE", "SHIM_ON", "INPUT_FILE", "SHIM_INPUT", "SYNCH_RAD", "ISR", "ISR1PART", "X0", "GAP0", "D_GAP", "PHASE_1", "PHASE_2", "PHASE_3", "PHASE_4", "VERBOSITY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["HISTOGRAM"]={"INTERVAL", "START_PASS", "BINS", "FIXED_BIN_SIZE", "X_DATA", "Y_DATA", "LONGIT_DATA", "BIN_SIZE_FACTOR", "NORMALIZE", "DISABLE", "SPARSE", "START_PID", "END_PID", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["HKICK"]={"KICK", "TILT", "B2", "CALIBRATION", "EDGE_EFFECTS", "ORDER", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["HMON"]={"DX", "DY", "WEIGHT", "TILT", "CALIBRATION", "SETPOINT", "ORDER", "READOUT", "CO_FITPOINT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["IBSCATTER"]={"FACTOR", "DO_X", "DO_Y", "DO_Z", "NSLICE", "SMOOTH", "FORCE_MATCHED_TWISS", "ISRING", "INTERVAL", "FILENAME", "BUNCHED_BEAM_MODE", "VERBOSE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["ILMATRIX"]={"NUX", "NUY", "NUX1M", "NUY1M", "NUX2M", "NUY2M", "NUX3M", "NUY3M", "NUX1AX", "NUY1AX", "NUX1AY", "NUY1AY", "NUX2AX", "NUY2AX", "NUX2AY", "NUY2AY", "NUX1AX1AY", "NUY1AX1AY", "BETAX", "BETAY", "BETAX1M", "BETAY1M", "ALPHAX", "ALPHAY", "ALPHAX1M", "ALPHAY1M", "ETAX", "ETAPX", "ETAY", "ETAPY", "ETAX1", "ETAPX1", "ETAY1", "ETAPY1", "ALPHAC", "ALPHAC2", "ALPHAC3", "DS1AX", "DS1AY", "DS2AX", "DS2AY", "DS1AX1AY", "TILT", "CROSS_RESONANCE", "VERBOSITY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["KICKER"]={"HKICK", "VKICK", "TILT", "B2", "HCALIBRATION", "VCALIBRATION", "EDGE_EFFECTS", "ORDER", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["KOCT"]={"K3", "TILT", "BORE", "B", "DX", "DY", "DZ", "FSE", "N_KICKS", "SYNCH_RAD", "SYSTEMATIC_MULTIPOLES", "RANDOM_MULTIPOLES", "INTEGRATION_ORDER", "SQRT_ORDER", "ISR", "ISR1PART", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["KPOLY"]={"COEFFICIENT", "TILT", "DX", "DY", "DZ", "FACTOR", "ORDER", "PLANE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["KQUAD"]={"K1", "TILT", "BORE", "B", "DX", "DY", "DZ", "FSE", "HKICK", "VKICK", "HCALIBRATION", "VCALIBRATION", "HSTEERING", "VSTEERING", "N_KICKS", "SYNCH_RAD", "SYSTEMATIC_MULTIPOLES", "EDGE_MULTIPOLES", "RANDOM_MULTIPOLES", "STEERING_MULTIPOLES", "INTEGRATION_ORDER", "SQRT_ORDER", "ISR", "ISR1PART", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "LEFFECTIVE", "I0P", "I1P", "I2P", "I3P", "LAMBDA2P", "I0M", "I1M", "I2M", "I3M", "LAMBDA2M", "EDGE1_LINEAR", "EDGE2_LINEAR", "EDGE1_NONLINEAR_FACTOR", "EDGE2_NONLINEAR_FACTOR", "RADIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["KQUSE"]={"K1", "K2", "TILT", "DX", "DY", "DZ", "FSE1", "FSE2", "N_KICKS", "SYNCH_RAD", "INTEGRATION_ORDER", "ISR", "ISR1PART", "MATRIX_TRACKING", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["KSBEND"]={"ANGLE", "K1", "K2", "K3", "K4", "E1", "E2", "TILT", "H1", "H2", "HGAP", "FINT", "DX", "DY", "DZ", "FSE", "ETILT", "N_KICKS", "NONLINEAR", "SYNCH_RAD", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "EDGE_ORDER", "PARAXIAL", "TRANSPORT", "METHOD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["KSEXT"]={"K2", "TILT", "BORE", "B", "DX", "DY", "DZ", "FSE", "HKICK", "VKICK", "HCALIBRATION", "VCALIBRATION", "HSTEERING", "VSTEERING", "N_KICKS", "SYNCH_RAD", "SYSTEMATIC_MULTIPOLES", "EDGE_MULTIPOLES", "RANDOM_MULTIPOLES", "STEERING_MULTIPOLES", "INTEGRATION_ORDER", "SQRT_ORDER", "ISR", "ISR1PART", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["LMIRROR"]={"RX", "RY", "THETA", "DX", "DY", "DZ", "TILT", "YAW", "PITCH", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["LRWAKE"]={"INPUTFILE", "TCOLUMN", "WXCOLUMN", "WYCOLUMN", "WZCOLUMN", "QXCOLUMN", "QYCOLUMN", "FACTOR", "XFACTOR", "YFACTOR", "ZFACTOR", "QXFACTOR", "QYFACTOR", "TURNS_TO_KEEP", "RAMP_PASSES", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["LSCDRIFT"]={"LEFFECTIVE", "BINS", "SMOOTHING", "SG_HALFWIDTH", "SG_ORDER", "INTERPOLATE", "LOW_FREQUENCY_CUTOFF0", "LOW_FREQUENCY_CUTOFF1", "HIGH_FREQUENCY_CUTOFF0", "HIGH_FREQUENCY_CUTOFF1", "RADIUS_FACTOR", "LSC", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["LSRMDLTR"]={"BU", "PERIODS", "METHOD", "FIELD_EXPANSION", "ACCURACY", "N_STEPS", "POLE_FACTOR1", "POLE_FACTOR2", "POLE_FACTOR3", "LASER_WAVELENGTH", "LASER_PEAK_POWER", "LASER_W0", "LASER_PHASE", "LASER_X0", "LASER_Y0", "LASER_Z0", "LASER_TILT", "LASER_M", "LASER_N", "SYNCH_RAD", "ISR", "TIME_PROFILE", "TIME_OFFSET", "HELICAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["LTHINLENS"]={"FX", "FY", "DX", "DY", "DZ", "TILT", "YAW", "PITCH", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MAGNIFY"]={"MX", "MXP", "MY", "MYP", "MS", "MDP", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MALIGN"]={"DXP", "DYP", "DX", "DY", "DZ", "DT", "DP", "DE", "ON_PASS", "FORCE_MODIFY_MATRIX", "START_PID", "END_PID", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MAPSOLENOID"]={"DX", "DY", "ETILT", "EYAW", "EPITCH", "N_STEPS", "INPUTFILE", "RCOLUMN", "ZCOLUMN", "BRCOLUMN", "BZCOLUMN", "FACTOR", "BXUNIFORM", "BYUNIFORM", "LUNIFORM", "ACCURACY", "METHOD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MARK"]={"DX", "DY", "FITPOINT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MATR"]={"ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MATTER"]={"LEFFECTIVE", "XO", "ENERGY_DECAY", "ENERGY_STRAGGLE", "NUCLEAR_BREMSSTRAHLUNG", "ELECTRON_RECOIL", "Z", "A", "RHO", "PLIMIT", "WIDTH", "SPACING", "TILT", "CENTER", "N_SLOTS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MAXAMP"]={"X_MAX", "Y_MAX", "ELLIPTICAL", "EXPONENT", "YEXPONENT", "OPEN_SIDE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MBUMPER"]={"STRENGTH", "TILT", "DX", "DY", "DZ", "TIME_OFFSET", "ORDER", "PERIODIC", "PHASE_REFERENCE", "FIRE_ON_PASS", "N_KICKS", "WAVEFORM", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MHISTOGRAM"]={"FILE1D", "FILE2DH", "FILE2DV", "FILE2DL", "FILE4D", "FILE6D", "INPUT_BINS", "INTERVAL", "START_PASS", "NORMALIZE", "DISABLE", "LUMPED", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MODRF"]={"VOLT", "PHASE", "FREQ", "Q", "PHASE_REFERENCE", "AMMAG", "AMPHASE", "AMFREQ", "AMDECAY", "PMMAG", "PMPHASE", "PMFREQ", "PMDECAY", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MONI"]={"DX", "DY", "WEIGHT", "TILT", "XCALIBRATION", "YCALIBRATION", "XSETPOINT", "YSETPOINT", "ORDER", "XREADOUT", "YREADOUT", "CO_FITPOINT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MRFDF"]={"FACTOR", "TILT", "A1", "A2", "A3", "A4", "A5", "B1", "B2", "B3", "B4", "B5", "FREQUENCY1", "FREQUENCY2", "FREQUENCY3", "FREQUENCY4", "FREQUENCY5", "PHASE1", "PHASE2", "PHASE3", "PHASE4", "PHASE5", "PHASE_REFERENCE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["MULT"]={"KNL", "TILT", "BORE", "BTIPL", "DX", "DY", "DZ", "FACTOR", "ORDER", "N_KICKS", "SYNCH_RAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["NIBEND"]={"ANGLE", "E1", "E2", "TILT", "DX", "DY", "DZ", "FINT", "HGAP", "FP1", "FP2", "FP3", "FP4", "FSE", "ETILT", "ACCURACY", "MODEL", "METHOD", "SYNCH_RAD", "ADJUST_BOUNDARY", "ADJUST_FIELD", "FUDGE_PATH_LENGTH", "FRINGE_POSITION", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["NISEPT"]={"ANGLE", "E1", "B1", "Q1REF", "FLEN", "ACCURACY", "METHOD", "MODEL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["OCTU"]={"K3", "TILT", "DX", "DY", "DZ", "FSE", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["PEPPOT"]={"RADII", "TRANSMISSION", "TILT", "THETA_RMS", "N_HOLES", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["PFILTER"]={"DELTALIMIT", "LOWERFRACTION", "UPPERFRACTION", "FIXPLIMITS", "BEAMCENTERED", "BINS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["QUAD"]={"K1", "TILT", "DX", "DY", "DZ", "FSE", "HKICK", "VKICK", "HCALIBRATION", "VCALIBRATION", "HSTEERING", "VSTEERING", "ORDER", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "FRINGE_TYPE", "FFRINGE", "LEFFECTIVE", "I0P", "I1P", "I2P", "I3P", "LAMBDA2P", "I0M", "I1M", "I2M", "I3M", "LAMBDA2M", "RADIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["QUFRINGE"]={"K1", "TILT", "DX", "DY", "DZ", "FSE", "DIRECTION", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RAMPP"]={"WAVEFORM", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RAMPRF"]={"VOLT", "PHASE", "FREQ", "PHASE_REFERENCE", "VOLT_WAVEFORM", "PHASE_WAVEFORM", "FREQ_WAVEFORM", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RBEN"]={"ANGLE", "K1", "E1", "E2", "TILT", "K2", "H1", "H2", "HGAP", "FINT", "DX", "DY", "DZ", "FSE", "ETILT", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "ORDER", "EDGE_ORDER", "TRANSPORT", "USE_BN", "B1", "B2", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RCOL"]={"X_MAX", "Y_MAX", "DX", "DY", "OPEN_SIDE", "INVERT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RECIRC"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["REFLECT"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["REMCOR"]={"X", "XP", "Y", "YP", "WITH", "ONCE_ONLY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RFCA"]={"VOLT", "PHASE", "FREQ", "Q", "PHASE_REFERENCE", "CHANGE_P0", "CHANGE_T", "FIDUCIAL", "END1_FOCUS", "END2_FOCUS", "BODY_FOCUS_MODEL", "N_KICKS", "DX", "DY", "T_REFERENCE", "LINEARIZE", "LOCK_PHASE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RFCW"]={"CELL_LENGTH", "VOLT", "PHASE", "FREQ", "Q", "PHASE_REFERENCE", "CHANGE_P0", "CHANGE_T", "FIDUCIAL", "END1_FOCUS", "END2_FOCUS", "BODY_FOCUS_MODEL", "N_KICKS", "ZWAKE", "TRWAKE", "WAKEFILE", "ZWAKEFILE", "TRWAKEFILE", "TCOLUMN", "WXCOLUMN", "WYCOLUMN", "WZCOLUMN", "N_BINS", "INTERPOLATE", "SMOOTHING", "SG_HALFWIDTH", "SG_ORDER", "DX", "DY", "LINEARIZE", "LSC", "LSC_BINS", "LSC_INTERPOLATE", "LSC_LOW_FREQUENCY_CUTOFF0", "LSC_LOW_FREQUENCY_CUTOFF1", "LSC_HIGH_FREQUENCY_CUTOFF0", "LSC_HIGH_FREQUENCY_CUTOFF1", "LSC_RADIUS_FACTOR", "WAKES_AT_END", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RFDF"]={"PHASE", "TILT", "FREQUENCY", "VOLTAGE", "FSE", "B2", "TIME_OFFSET", "N_KICKS", "PHASE_REFERENCE", "STANDING_WAVE", "VOLTAGE_WAVEFORM", "VOLTAGE_PERIODIC", "ALIGN_WAVEFORMS", "VOLTAGE_NOISE", "PHASE_NOISE", "GROUP_VOLTAGE_NOISE", "GROUP_PHASE_NOISE", "VOLTAGE_NOISE_GROUP", "PHASE_NOISE_GROUP", "START_PASS", "END_PASS", "DRIFT_MATRIX", "DX", "DY", "DZ", "MAGNETIC_DEFLECTION", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RFMODE"]={"RA", "RS", "Q", "FREQ", "CHARGE", "INITIAL_V", "INITIAL_PHASE", "INITIAL_T", "BETA", "BIN_SIZE", "N_BINS", "INTERPOLATE", "PRELOAD", "PRELOAD_CHARGE", "PRELOAD_FACTOR", "PRELOAD_HARMONIC", "RIGID_UNTIL_PASS", "DETUNED_UNTIL_PASS", "SAMPLE_INTERVAL", "FLUSH_INTERVAL", "RECORD", "SINGLE_PASS", "PASS_INTERVAL", "FREQ_WAVEFORM", "Q_WAVEFORM", "RAMP_PASSES", "BINLESS", "RESET_FOR_EACH_STEP", "LONG_RANGE_ONLY", "N_CAVITIES", "BUNCHED_BEAM_MODE", "BUNCH_INTERVAL", "DRIVE_FREQUENCY", "V_SETPOINT", "PHASE_SETPOINT", "UPDATE_INTERVAL", "AMPLITUDE_FILTER", "PHASE_FILTER", "IN_PHASE_FILTER", "QUADRATURE_FILTER", "FEEDBACK_RECORD", "MUTE_GENERATOR", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RFTM110"]={"PHASE", "TILT", "FREQUENCY", "VOLTAGE", "PHASE_REFERENCE", "VOLTAGE_WAVEFORM", "VOLTAGE_PERIODIC", "ALIGN_WAVEFORMS", "VOLTAGE_NOISE", "PHASE_NOISE", "GROUP_VOLTAGE_NOISE", "GROUP_PHASE_NOISE", "VOLTAGE_NOISE_GROUP", "PHASE_NOISE_GROUP", "START_PASS", "END_PASS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RFTMEZ0"]={"FREQUENCY", "PHASE", "EZ_PEAK", "TIME_OFFSET", "PHASE_REFERENCE", "DX", "DY", "DZ", "ETILT", "EYAW", "EPITCH", "N_STEPS", "RADIAL_ORDER", "CHANGE_P0", "INPUTFILE", "ZCOLUMN", "EZCOLUMN", "SOLENOID_FILE", "SOLENOID_ZCOLUMN", "SOLENOID_RCOLUMN", "SOLENOID_BZCOLUMN", "SOLENOID_BRCOLUMN", "SOLENOID_FACTOR", "SOLENOID_DX", "SOLENOID_DY", "SOLENOID_DZ", "SOLENOID_ETILT", "SOLENOID_EYAW", "SOLENOID_EPITCH", "BX_STRAY", "BY_STRAY", "ACCURACY", "METHOD", "FIDUCIAL", "FIELD_TEST_FILE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RIMULT"]={"FACTOR", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["RMDF"]={"TILT", "RAMP_TIME", "VOLTAGE", "GAP", "TIME_OFFSET", "N_SECTIONS", "PHASE_REFERENCE", "DX", "DY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["ROTATE"]={"TILT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["SAMPLE"]={"FRACTION", "INTERVAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["SBEN"]={"ANGLE", "K1", "E1", "E2", "TILT", "K2", "H1", "H2", "HGAP", "FINT", "DX", "DY", "DZ", "FSE", "ETILT", "EDGE1_EFFECTS", "EDGE2_EFFECTS", "ORDER", "EDGE_ORDER", "TRANSPORT", "USE_BN", "B1", "B2", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["SBEND"]:=ElegantRules["SBEN"]


ElegantRules["SCATTER"]={"X", "XP", "Y", "YP", "DP", "PROBABILITY", "STARTONPASS", "ENDONPASS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["SCMULT"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["SCRAPER"]={"XO", "ENERGY_DECAY", "ENERGY_STRAGGLE", "NUCLEAR_BREMSSTRAHLUNG", "ELECTRON_RECOIL", "Z", "A", "RHO", "PLIMIT", "POSITION", "DX", "DY", "INSERT_FROM", "DIRECTION", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["SCRIPT"]={"COMMAND", "USE_CSH", "VERBOSITY", "START_PASS", "END_PASS", "PASS_INTERVAL", "ON_PASS", "DIRECTORY", "ROOTNAME", "INPUT_EXTENSION", "OUTPUT_EXTENSION", "KEEP_FILES", "DRIFT_MATRIX", "USE_PARTICLE_ID", "NO_NEW_PARTICLES", "NP0", "NP1", "NP2", "NP3", "NP4", "NP5", "NP6", "NP7", "NP8", "NP9", "SP0", "SP1", "SP2", "SP3", "SP4", "SP5", "SP6", "SP7", "SP8", "SP9", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["SEXT"]={"K2", "TILT", "DX", "DY", "DZ", "FSE", "FFRINGE", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["SOLE"]={"KS", "B", "DX", "DY", "DZ", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["SREFFECTS"]={"JX", "JY", "JDELTA", "EXREF", "EYREF", "SDELTAREF", "DDELTAREF", "PREF", "COUPLING", "FRACTION", "DAMPING", "QEXCITATION", "LOSSES", "CUTOFF", "INCLUDE_OFFSETS", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["STRAY"]={"LBX", "LBY", "GBX", "GBY", "GBZ", "ORDER", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TFBDRIVER"]={"ID", "STRENGTH", "KICK_LIMIT", "DELAY", "LONGITUDINAL", "OUTPUT_FILE", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "BUNCHED_BEAM_MODE", "UPDATE_INTERVAL", "OUTPUT_INTERVAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TFBPICKUP"]={"ID", "PLANE", "RMS_NOISE", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "BUNCHED_BEAM_MODE", "UPDATE_INTERVAL", "REFERENCE_FREQUENCY", "DX", "DY", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TMCF"]={"FREQUENCY", "PHASE", "TIME_OFFSET", "RADIAL_OFFSET", "TILT", "ER", "BPHI", "EZ", "ACCURACY", "X_MAX", "Y_MAX", "DX", "DY", "PHASE_REFERENCE", "N_STEPS", "METHOD", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TRCOUNT"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TRFMODE"]={"RA", "RS", "Q", "FREQ", "CHARGE", "BETA", "BIN_SIZE", "N_BINS", "INTERPOLATE", "PLANE", "SAMPLE_INTERVAL", "PER_PARTICLE_OUTPUT", "RECORD", "SINGLE_PASS", "RIGID_UNTIL_PASS", "DX", "DY", "XFACTOR", "YFACTOR", "RAMP_PASSES", "BINLESS", "RESET_FOR_EACH_STEP", "LONG_RANGE_ONLY", "N_CAVITIES", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TRWAKE"]={"INPUTFILE", "TCOLUMN", "WXCOLUMN", "WYCOLUMN", "CHARGE", "FACTOR", "XFACTOR", "YFACTOR", "N_BINS", "INTERPOLATE", "SMOOTHING", "SG_HALFWIDTH", "SG_ORDER", "DX", "DY", "TILT", "X_DRIVE_EXPONENT", "Y_DRIVE_EXPONENT", "X_PROBE_EXPONENT", "Y_PROBE_EXPONENT", "RAMP_PASSES", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TSCATTER"]={"GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TUBEND"]={"ANGLE", "FSE", "OFFSET", "MAGNET_WIDTH", "MAGNET_ANGLE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TWISS"]={"BETAX", "ALPHAX", "ETAX", "ETAXP", "BETAY", "ALPHAY", "ETAY", "ETAYP", "FROM_BEAM", "FROM_0VALUES", "COMPUTE_ONCE", "APPLY_ONCE", "VERBOSE", "DISABLE", "BETAX0", "ALPHAX0", "ETAX0", "ETAXP0", "BETAY0", "ALPHAY0", "ETAY0", "ETAYP0", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TWLA"]={"FREQUENCY", "PHASE", "TIME_OFFSET", "EZ", "B_SOLENOID", "ACCURACY", "X_MAX", "Y_MAX", "DX", "DY", "BETA_WAVE", "ALPHA", "PHASE_REFERENCE", "N_STEPS", "FOCUSSING", "METHOD", "FIDUCIAL", "CHANGE_P0", "SUM_BN2", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TWMTA"]={"FREQUENCY", "PHASE", "EZ", "ACCURACY", "X_MAX", "Y_MAX", "DX", "DY", "KX", "BETA_WAVE", "BSOL", "ALPHA", "PHASE_REFERENCE", "N_STEPS", "METHOD", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["TWPL"]={"RAMP_TIME", "TIME_OFFSET", "VOLTAGE", "GAP", "STATIC_VOLTAGE", "TILT", "ACCURACY", "X_MAX", "Y_MAX", "DX", "DY", "PHASE_REFERENCE", "N_STEPS", "METHOD", "FIDUCIAL", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["UKICKMAP"]={"TILT", "DX", "DY", "DZ", "FIELD_FACTOR", "XY_FACTOR", "INPUT_FILE", "N_KICKS", "PERIODS", "KREF", "SYNCH_RAD", "ISR", "GROUP", "x \[LongDash] Horizontal position in meters.","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["VKICK"]={"KICK", "TILT", "B2", "CALIBRATION", "EDGE_EFFECTS", "ORDER", "STEERING", "SYNCH_RAD", "ISR", "LERAD", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["VMON"]={"DX", "DY", "WEIGHT", "TILT", "CALIBRATION", "SETPOINT", "ORDER", "READOUT", "CO_FITPOINT", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["WAKE"]={"INPUTFILE", "TCOLUMN", "WCOLUMN", "CHARGE", "FACTOR", "N_BINS", "INTERPOLATE", "SMOOTHING", "SG_HALFWIDTH", "SG_ORDER", "CHANGE_P0", "ALLOW_LONG_BEAM", "RAMP_PASSES", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["WATCH"]={"FRACTION", "START_PID", "END_PID", "INTERVAL", "START_PASS", "END_PASS", "FILENAME", "LABEL", "MODE", "X_DATA", "Y_DATA", "LONGIT_DATA", "EXCLUDE_SLOPES", "FLUSH_INTERVAL", "DISABLE", "USE_DISCONNECT", "INDEX_OFFSET", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["WIGGLER"]={"RADIUS", "K", "B", "DX", "DY", "DZ", "TILT", "POLES", "FOCUSING", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["ZLONGIT"]={"CHARGE", "BROAD_BAND", "RA", "RS", "Q", "FREQ", "ZREAL", "ZIMAG", "BIN_SIZE", "N_BINS", "MAX_N_BINS", "WAKES", "WAKE_INTERVAL", "WAKE_START", "WAKE_END", "AREA_WEIGHT", "INTERPOLATE", "SMOOTHING", "SG_ORDER", "SG_HALFWIDTH", "REVERSE_TIME_ORDER", "FACTOR", "START_ON_PASS", "RAMP_PASSES", "HIGH_FREQUENCY_CUTOFF0", "HIGH_FREQUENCY_CUTOFF1", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["ZTRANSVERSE"]={"CHARGE", "BROAD_BAND", "RS", "Q", "FREQ", "INPUTFILE", "FREQCOLUMN", "ZXREAL", "ZXIMAG", "ZYREAL", "ZYIMAG", "BIN_SIZE", "INTERPOLATE", "N_BINS", "MAX_N_BINS", "SMOOTHING", "SG_ORDER", "SG_HALFWIDTH", "DX", "DY", "FACTOR", "XFACTOR", "YFACTOR", "WAKES", "WAKE_INTERVAL", "WAKE_START", "WAKE_END", "START_ON_PASS", "RAMP_PASSES", "HIGH_FREQUENCY_CUTOFF0", "HIGH_FREQUENCY_CUTOFF1", "X_DRIVE_EXPONENT", "Y_DRIVE_EXPONENT", "X_PROBE_EXPONENT", "Y_PROBE_EXPONENT", "BUNCHED_BEAM_MODE", "GROUP","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE"};


ElegantRules["SECTORBEND"]={"TYPE"->"SBEN","LENGTH"->"L","BENDANGLE"->"ANGLE","L","ANGLE","K1","E1","E2","TILT","K2","H1","H2","HGAP","FINT","DX","DY","DZ","FSE","ETILT","EDGE1_EFFECTS","EDGE2_EFFECTS","ORDER","EDGE_ORDER","TRANSPORT","USE_BN","B1","B2","GROUP"};


ElegantRules["CSBEND"]={"TYPE"->"CSBEN","LENGTH"->"L","L","BENDANGLE"->"ANGLE","ANGLE","K1","K2","K3","K4","K5","K6","K7","K8","E1","E2","TILT","H1","H2","HGAP","FINT","DX","DY","DZ","FSE","ETILT","N_KICKS","NONLINEAR","SYNCH_RAD","EDGE1_EFFECTS","EDGE2_EFFECTS","EDGE_ORDER","FRINGE","INTEGRATION_ORDER","EDGE1_KICK_LIMIT","EDGE2_KICK_LIMIT","KICK_LIMIT_SCALING","USE_BN","EXPANSION_ORDER","B1","B2","B3","B4","B5","B6","B7","B8","XREFERENCE","F1","F2","F3","F4","F5","F6","F7","F8","ISR","ISR1PART","SQRT_ORDER","USE_RAD_DIST","ADD_OPENING_ANGLE","GROUP"};


ElegantRules["CSRCSBEND"]={"TYPE"->"CSRCSBEND","LENGTH"->"L","L","BENDANGLE"->"ANGLE","ANGLE","K1","K2","K3","K4","K5","K6","K7","K8","E1","E2","TILT","H1","H2","HGAP","FINT","DX","DY","DZ","FSE","ETILT","N_KICKS","NONLINEAR","LINEARIZE","SYNCH_RAD","EDGE1_EFFECTS","EDGE2_EFFECTS","EDGE_ORDER","INTEGRATION_ORDER","BINS","BIN_ONCE","BIN_RANGE_FACTOR","SG_HALFWIDTH","SG_ORDER","SGDERIV_HALFWIDTH","SGDERIV_ORDER","TRAPAZOID_INTEGRATION","OUTPUT_FILE","OUTPUT_INTERVAL","OUTPUT_LAST_WAKE_ONLY","STEADY_STATE","IGF","USE_BN","EXPANSION_ORDER","B1","B2","B3","B4","B5","B6","B7","B8","ISR","ISR1PART","CSR","BLOCK_CSR","DERBENEV_CRITERION_MODE","PARTICLE_OUTPUT_FILE","PARTICLE_OUTPUT_INTERVAL","SLICE_ANALYSIS_INTERVAL","LOW_FREQUENCY_CUTOFF0","LOW_FREQUENCY_CUTOFF1","HIGH_FREQUENCY_CUTOFF0","HIGH_FREQUENCY_CUTOFF1","CLIP_NEGATIVE_BINS","WAKE_FILTER_FILE","WFF_FREQ_COLUMN","WFF_REAL_COLUMN","WFF_IMAG_COLUMN","GROUP"};


ElegantRules["KQUAD"]={"TYPE"->"KQUAD","LENGTH"->"L","K1","TILT","BORE","B","DX","DY","DZ","FSE","HKICK","VKICK","HCALIBRATION","VCALIBRATION","HSTEERING","VSTEERING","N_KICKS","SYNCH_RAD","SYSTEMATIC_MULTIPOLES","RANDOM_MULTIPOLES","STEERING_MULTIPOLES","INTEGRATION_ORDER","SQRT_ORDER","ISR","ISR1PART","EDGE1_EFFECTS","EDGE2_EFFECTS","I0P","I1P","I2P","I3P","LAMBDA2P","I0M","I1M","I2M","I3M","LAMBDA2M","RADIAL","GROUP"};


ElegantRules["QUADRUPOLE"]={"TYPE"->"QUAD","LENGTH"->"L","K1","N_KICKS","TILT","DX","DY","DZ","FSE","HKICK","VKICK","HCALIBRATION","VCALIBRATION","HSTEERING","VSTEERING","ORDER","EDGE1_EFFECTS","EDGE2_EFFECTS","FRINGE_TYPE","FFRINGE","I0P","I1P","I2P","I3P","LAMBDA2P","I0M","I1M","I2M","I3M"};


ElegantRules["SEXTUPOLE"]={"TYPE"->"SEXT","LENGTH"->"L","K1","L","K2","TILT","DX","DY","DZ","FSE","FFRINGE","ORDER","GROUP"};


ElegantRules["KSEXT"]={"TYPE"->"KSEXT","LENGTH"->"L","K1","L","K2","TILT","BORE","B","DX","DY","DZ","FSE","N_KICKS","SYNCH_RAD","SYSTEMATIC_MULTIPOLES","RANDOM_MULTIPOLES","INTEGRATION_ORDER","SQRT_ORDER","ISR","ISR1PART","GROUP"};


ElegantRules["DRIFT"]={"TYPE"->"DRIFT","LENGTH"->"L","L"};


ElegantRules["EDRIFT"]={"TYPE"->"EDRIFT","LENGTH"->"L","L"};


ElegantRules["CSRDRIFT"]={"TYPE"->"CSRDRIFT","LENGTH"->"L","L","ATTENUATION_LENGTH","DZ","N_KICKS","SPREAD","USE_OVERTAKING_LENGTH","OL_MULTIPLIER","USE_SALDIN54","SALDIN54POINTS","CSR","SALDIN54NORM_MODE","SPREAD_MODE","WAVELENGTH_MODE","BUNCHLENGTH_MODE","SALDIN54_OUTPUT","USE_STUPAKOV","STUPAKOV_OUTPUT","STUPAKOV_OUTPUT_INTERVAL","SLICE_ANALYSIS_INTERVAL","LINEARIZE","GROUP",ToUpperCase["lsc_high_frequency_cutoff0"],ToUpperCase["lsc_high_frequency_cutoff1"],ToUpperCase["lsc_bins"]};


ElegantRules["MARKER"]={"TYPE"->"MARK","DX","DY","FITPOINT","GROUP"};


ElegantRules["MONITOR"]={"TYPE"->"MONI","LENGTH"->"L","L","DX","DY","WEIGHT","TILT","XCALIBRATION","YCALIBRATION","ORDER","XREADOUT","YREADOUT","CO_FITPOINT","GROUP"};


ElegantRules["HKICKER"]={"TYPE"->"HKICK","LENGTH"->"L","L","KICK","TILT","B2","CALIBRATION","EDGE_EFFECTS","ORDER","STEERING","SYNCH_RAD","ISR","LERAD","GROUP"};


ElegantRules["VKICKER"]={"TYPE"->"VKICK","LENGTH"->"L","L","KICK","TILT","B2","CALIBRATION","EDGE_EFFECTS","ORDER","STEERING","SYNCH_RAD","ISR","LERAD","GROUP"};


ElegantRules["KICKER"]={"TYPE"->"KICKER","LENGTH"->"L","L","HKICK","VKICK","TILT","B2","HCALIBRATION","VCALIBRATION","EDGE_EFFECTS","ORDER","STEERING","SYNCH_RAD","ISR","LERAD","GROUP"};


ElegantRules["RFCA"]={"TYPE"->"RFCA","LENGTH"->"L","L","VOLT","PHASE","FREQ","Q","PHASE_REFERENCE","CHANGE_P0","CHANGE_T","FIDUCIAL","END1_FOCUS","END2_FOCUS","BODY_FOCUS_MODEL","N_KICKS","DX","DY","T_REFERENCE","LINEARIZE","LOCK_PHASE","GROUP","FREQUENCY"->"FREQ"};


ElegantRules["SCREEN"]=ElegantRules["MONITOR"];


ElegantRules["PROFILE"]=ElegantRules["MONITOR"];


ElegantRules["VALVE"]=ElegantRules["DRIFT"];


ElegantRules["SHUTTER"]=ElegantRules["DRIFT"];


ElegantRules["BELLOWS"]=ElegantRules["DRIFT"];


ElegantRules["alter_elements"]={"name", "item", "type", "exclude", "value", "string_value", "differential", "multiplicative", "verbose", "allow_missing_elements", "allow_missing_parameters", "start_occurence", "end_occurence", "s_start", "s_end", "before", "after"};


ElegantRules["amplification_factors"]={"output", "uncorrected_orbit_function", "corrected_orbit_function", "kick_function", "name", "type", "item", "plane", "change", "number_to_do", "maximum_z"};


ElegantRules["analyze_map"]={"output", "printout", "delta_x", "delta_xp", "delta_y", "delta_yp", "delta_s", "delta_dp", "accuracy_factor", "center_on_orbit", "verbosity", "canonical_variables", "printout_order", "periodic", "beta_x", "alpha_x", "eta_x", "etap_x", "beta_y", "alpha_y", "eta_y", "etap_y"};


ElegantRules["aperture_data"]={"input", "periodic", "persistent", "disable"};


ElegantRules["bunched_beam"] = {"bunch", "n_particles_per_bunch", "time_start", "matched_to_cell", "emit_x", "emit_nx", "beta_x", "alpha_x", "eta_x", "etap_x", "emit_y", "emit_ny", "beta_y", "alpha_y", "eta_y", "etap_y", "use_twiss_command_values", "Po", "sigma_dp", "sigma_s", "dp_s_coupling", "emit_z", "beta_z", "alpha_z", "momentum_chirp", "one_random_bunch", "symmetrize", "optimized_halton", "limit_invariants", "limit_in_4d", "first_is_fiducial", "save_initial_coordinates", "halton_sequence", "halton_radix", "randomize_order", "enforce_rms_values", "distribution_cutoff", "distribution_type", "centroid"};


ElegantRules["change_particle"]={"name", "mass_ratio", "charge_ratio"};


ElegantRules["chromaticity"]={"sextupoles", "dnux_dp", "dnuy_dp", "sextupole_tweek", "correction_fraction", "n_iterations", "tolerance", "strength_log", "change_defined_values", "strength_limit", "use_perturbed_matrix", "exit_on_failure", "verbosity", "dK2_weight"};


ElegantRules["closed_orbit"]={"output", "output_monitors_only", "start_from_centroid", "start_from_dp_centroid", "closed_orbit_accuracy", "closed_orbit_iterations", "iteration_fraction", "fixed_length", "start_from_recirc", "verbosity", "tracking_turns"};


ElegantRules["correct"]={"mode", "method", "trajectory_output", "corrector_output", "statistics", "verbose", "fixed_length", "fixed_length_matrix", "n_xy_cycles", "minimum_cycles", "n_iterations", "prezero_correctors", "track_before_and_after", "start_from_centroid", "use_actual_beam", "closed_orbit_accuracy", "closed_orbit_iterations", "closed_orbit_iteration_fraction", "closed_orbit_tracking_turns", "use_perturbed_matrix", "disable", "use_response_from_computed_orbits", "corrector_tweek", "corrector_limit", "correction_fraction", "correction_accuracy", "do_correction", "remove_smallest_SVs", "keep_largest_SVs", "minimum_SV_ratio", "auto_limit_SVs", "removed_pegged", "threading_divisor", "threading_correctors", "bpm_noise", "bpm_noise_cutoff", "bpm_noise_distribution"};


ElegantRules["correction_matrix_output"]={"KnL_units", "BnL_units", "output_at_each_step", "output_before_tune_correction", "fixed_length", "coupled", "use_response_from_computed_orbits", "response", "inverse"};


ElegantRules["correct_tunes"]={"quadrupoles", "tune_x", "tune_y", "n_iterations", "correction_fraction", "tolerance", "step_up_interval", "max_correction_fraction", "delta_correction_fraction", "strength_log", "change_defined_values", "use_perturbed_matrix", "dK1_weight"};


ElegantRules["coupled_twiss_output"]={"filename", "output_at_each_step", "emittances_from_twiss_command", "emit_x", "emittance_ratio", "sigma_dp", "calculate_3d_coupling", "verbosity", "concat_order"};


ElegantRules["divide_elements"]={"name", "type", "exclude", "divisions", "maximum_length", "clear"};


ElegantRules["error_element"]={"name", "element_type", "item", "type", "amplitude", "cutoff", "bind", "bind_number", "post_correction", "fractional", "additive", "allow_missing_elements", "after", "before","bind_across_names"};


ElegantRules["error_control"]={"clear_error_settings", "summarize_error_settings", "no_errors_for_first_step", "error_log", "error_factor"};


ElegantRules["find_aperture"]={"output", "search_output", "boundary", "mode", "xmin", "xmax", "ymin", "ymax", "nx", "ny", "n_splits", "split_fraction", "desired_resolution", "assume_nonincreasing", "verbosity", "offset_by_orbit", "n_lines", "optimization_mode"};


ElegantRules["floor_coordinates"]={"filename", "X0", "Z0", "theta0", "include_vertices", "vertices_only", "magnet_centers", "store_vertices"};


ElegantRules["frequency_map"]={"output", "xmin", "xmax", "ymin", "ymax", "delta_min", "delta_max", "nx", "ny", "ndelta", "verbosity", "include_changes", "quadratic_spacing", "full_grid_output"};


ElegantRules["global_settings"]={"inhibit_fsync", "echo_namelists", "SR_gaussian_limit", "log_file", "error_log_file", "mpi_randomization_mode", "exact_normalized_emittance"};


ElegantRules["insert_elements"]={"name", "type", "exclude", "s_start", "s_end", "skip", "disable", "add_at_end", "add_at_start", "element_def", "total_occurrences", "occurrence"};


ElegantRules["insert_sceffects"]={"name", "type", "exclude", "disable", "clear", "element_prefix", "skip", "vertical", "horizontal", "nonlinear", "uniform_distribution", "verbosity"};


ElegantRules["linear_chromatic_tracking_setup"]={"nux", "betax", "alphax", "etax", "etapx", "nuy", "betay", "alphay", "etay", "etapy", "alphac"};


ElegantRules["link_control"]={"clear_links", "summarize_links", "verbosity"};


ElegantRules["link_elements"]={"target", "exclude", "item", "source", "source_position", "mode", "equation", "minimium", "maximum", "exclude_self"};


ElegantRules["load_parameters"]={"filename", "filename_list", "include_name_pattern", "exclude_name_pattern", "include_item_pattern", "exclude_item_pattern", "include_type_pattern", "exclude_type_pattern", "edit_name_command", "change_defined_values", "clear_settings", "allow_missing_elements", "allow_missing_parameters", "allow_missing_files", "force_occurence_data", "verbose", "skip_pages", "use_first"};


ElegantRules["matrix_output"]={"printout", "printout_order", "full_matrix_only", "SDDS_output", "SDDS_output_order", "individual_matrices", "SDDS_output_match", "output_at_each_step", "start_from", "start_from_occurrence"};


ElegantRules["modulate_elements"]={"name", "item", "type", "expression", "filename", "time_column", "amplitude_column", "refresh_matrix", "differential", "multiplicative", "start_occurence", "end_occurence", "s_start", "s_end", "before", "after", "verbose", "verbose_threshold", "record", "flush_record"};


ElegantRules["moments_output"]={"filename", "output_at_each_step", "output_before_tune_correction", "final_values_only", "verbosity", "matched", "equilibrium", "radiation", "n_slices", "slice_etilted", "emit_x", "beta_x", "alpha_x", "eta_x", "etap_x", "emit_y", "beta_y", "alpha_y", "eta_y", "etap_y", "emit_z", "beta_z", "alpha_z"};


ElegantRules["momentum_aperture"]={"output", "x_initial", "y_initial", "delta_negative_start", "delta_positive_start", "delta_negative_limit", "delta_positive_limit", "delta_step_size", "steps_back", "splits", "split_step_divisor", "skip_elements", "process_elements", "s_start", "s_end", "include_name_pattern", "include_type_pattern", "fiducialize", "verbosity", "soft_failure", "output_mode", "forbid_resonance_crossing"};


ElegantRules["optimize"]={"summarize_setup"};


ElegantRules["optimization_constraint"]={"quantity", "lower", "upper"};


ElegantRules["optimization_covariable"]={"name", "item", "equation", "disable"};


ElegantRules["optimization_setup"]={"equation", "mode", "method", "tolerance", "target", "center_on_orbit", "center_momentum_also", "soft_failure", "n_passes", "n_evaluations", "n_restarts", "matrix_order", "log_file", "term_log_file", "output_sparsing_factor", "balance_terms", "restart_worst_term_factor", "restart_worst_terms", "verbose", "balance_terms", "simplex_divisor", "simplex_pass_range_factor", "include_simplex_1d_scans", "start_from_simplex_vertex1", "restart_random_numbers", "interrupt_file"};


ElegantRules["parallel_optimization_setup"]={"method", "random_factor", "n_iterations", "max_no_change", "population_size", "population_log", "print_all_individuals", "output_sparsing_factor", "crossover"};


ElegantRules["optimization_term"]={"term", "weight", "field_string", "field_initial_value", "field_final_value", "field_interval", "input_file", "input_column", "verbose"};


ElegantRules["optimization_variable"]={"name", "item", "lower_limit", "upper_limit", "step_size", "disable", "force_inside"};


ElegantRules["print_dictionary"]={"filename", "SDDS_form"};


ElegantRules["ramp_elements"]={"name", "item", "type", "start_pass", "end_pass", "start_value", "end_value", "differential", "multiplicative", "start_occurence", "end_occurence", "exponent", "s_start", "s_end", "before", "after", "verbose", "record"};


ElegantRules["rf_setup"]={"filename", "name", "start_occurence", "end_occurence", "s_start", "s_end", "set_for_each_step", "near_frequency", "harmonic", "bucket_half_height", "over_voltage", "total_voltage"};


ElegantRules["replace_elements"]={"name", "type", "exclude", "skip", "disable", "element_def", "total_occurrences", "occurrence"};


ElegantRules["rpn_expression"]={"expression"};


ElegantRules["rpn_load"]={"tag", "filename", "match_column", "match_column_value", "matching_row_number", "match_parameter", "match_parameter_value", "use_row", "use_page", "load_parameters"};


ElegantRules["run_control"]={"n_steps", "bunch_frequency", "n_indices", "n_passes", "n_passes_fiducial", "reset_rf_for_each_step", "first_is_fiducial", "restrict_fiducialization"};


ElegantRules["run_setup"]={"lattice", "use_beamline", "rootname", "output", "centroid", "sigma", "final", "acceptance", "losses", "magnets", "semaphore_file", "parameters", "combine_bunch_statistics", "wrap_around", "final_pass", "default_order", "concat_order", "print_statistics", "show_element_timing", "monitor_memory_usage", "random_number_seed", "correction_iterations", "p_central", "p_central_mev", "always_change_p0", "expand_for", "tracking_updates", "echo_lattice", "search_path", "element_divisions", "load_balancing_on"};


ElegantRules["sasefel"]={"output", "model", "beta", "undulator_K", "undulator_period", "slice_fraction", "n_slices"};


ElegantRules["save_lattice"]={"filename", "output_seq"};


ElegantRules["sdds_beam"]={"input", "input_list", "input_type", "n_particles_per_ring", "selection_parameter", "selection_string", "one_random_bunch", "reuse_bunch", "prebunched", "track_pages_separately", "use_bunched_mode", "sample_interval", "n_tables_to_skip", "center_transversely", "center_arrival_time", "sample_fraction", "p_lower", "p_upper", "save_initial_coordinates", "reverse_t_sign", "n_duplicates", "duplicate_stagger"};


ElegantRules["semaphores"]={};


ElegantRules["slice_analysis"]={"output", "n_slices", "s_start", "s_end", "final_values_only"};


ElegantRules["subprocess"]={"command"};


ElegantRules["steering_element"]={"name", "element_type", "item", "plane", "tweek", "limit"};


ElegantRules["touschek_scatter"]={"charge", "frequency", "emit_x", "emit_nx", "emit_y", "emit_ny", "sigma_dp", "sigma_s", "Momentum_Aperture_scale", "Momentum_Aperture", "XDist", "YDist", "ZDist", "TranDist", "FullDist", "bunch", "loss", "distribution", "initial", "output", "nbins", "sbin_step", "n_simulated", "ignored_portion", "i_start", "i_end", "do_track", "match_position_only", "overwrite_files", "verbosity", "distribution_cutoff"};


ElegantRules["transmute_elements"]={"name", "type", "exclude", "new_type", "disable", "clear"};


ElegantRules["tune_footprint"]={"delta_output", "xy_output", "xmin", "xmax", "ymin", "ymax", "x_for_delta", "y_for_delta", "delta_min", "delta_max", "nx", "ny", "ndelta", "verbosity", "quadratic_spacing", "compute_diffusion", "diffusion_rate_limit", "immediate", "filtered_output", "ignore_half_integer"};


ElegantRules["twiss_analysis"]={"match_name", "start_name", "end_name", "s_start", "s_end", "tag", "verbosity", "clear"};


ElegantRules["twiss_output"]={"filename", "matched", "output_at_each_step", "output_before_tune_correction", "final_values_only", "statistics", "radiation_integrals", "concat_order", "higher_order_chromaticity", "higher_order_chromaticity_points", "higher_order_chromaticity_range", "chromatic_tune_spread_half_range", "quick_higher_order_chromaticity", "beta_x", "alpha_x", "eta_x", "etap_x", "beta_y", "alpha_y", "eta_y", "etap_y", "reference_file", "reference_element", "reference_element_occurrence", "reflect_reference_values", "cavities_are_drifts_if_matched", "compute_driving_terms", "leading_order_driving_terms_only", "s_dependent_driving_terms_file", "local_dispersion"};


ElegantRules["track"]={"center_on_orbit", "center_momentum_also", "offset_by_orbit", "offset_momentum_also", "soft_failure", "use_linear_chromatic_matrix", "longitudinal_ring_only", "stop_tracking_particle_limit"};


ElegantRules["tune_shift_with_amplitude"]={"turns", "x0", "y0", "x1", "y1", "grid_size", "lines_only", "sparse_grid", "spread_only", "nux_roi_width", "nuy_roi_width", "scale_down_factor", "scale_up_factor", "scale_down_limit", "scale_up_limit", "scaling_iterations", "use_concatenation", "verbose", "order", "tune_output"};


ElegantRules["vary_element"]={"index_number", "index_limit", "name", "item", "initial", "final", "differential", "multiplicative", "geometric", "enumeration_file", "enumeration_column"};


addRules[rules_]:=Block[{},
Union[Flatten[Switch[Head[#],
String,{#,ToUpperCase[#],ToLowerCase[#]},
Symbol,{#,ToString[#],ToUpperCase[ToString[#]],ToLowerCase[ToString[#]],Symbol@ToUpperCase[ToString[#]],Symbol@ToLowerCase[ToString[#]]},
Rule,Block[{a=#[[1]],b=#[[2]]},
Map[Rule[#,b]&,{a,ToString[a],ToUpperCase[ToString[a]],ToLowerCase[ToString[a]],Symbol@ToUpperCase[ToString[a]],Symbol@ToLowerCase[ToString[a]]}]
]
]&/@rules]]
]


formatString[in_]:=Block[{},
Switch[Head[in],
String,in,
Real,ToString[numberRight[in]],
Integer,ToString[in],
Rational,ToString[CForm[in]],
List,MapIndexed[If[#2[[1]]>1,",",""]<>ToString[CForm[#]]&,in],
_,ToString[numberRight[in]]
]
]


MADNameRules={"-"->"", "$"->""}


Clear[MADElementNames];
MADElementNames[elementLine[list__],type_:None]:=MADElementNames/@Select[DeleteDuplicates[Cases[{list},elementDefinition[__Rule],\[Infinity]]],If[type===None,True,StringMatchQ[ToUpperCase[("TYPE"/.#)],ToUpperCase[type]]]&]
MADElementNames[elementDefinition[list__Rule]]:=Block[{element},
element=capitalRuleNames[elementDefinition[list]];
Rule[StringTake[StringReplace["NAME"/.element,MADNameRules],UpTo[16]],"NAME"/.element]
]


Clear[MADWriteElements];
MADWriteElements[elementLine[list__]]:=MADWriteElements/@Union[Cases[{list},elementDefinition[__Rule],\[Infinity]]]
MADWriteElements[elementDefinition[list__Rule]]:=Block[{element},
element=capitalRuleNames[elementDefinition[list]];
StringReplace["NAME"/.element,MADNameRules]<>":"<>("TYPE"/.Cases[MADRules[ToUpperCase[Evaluate["TYPE"/.element]]],Rule["TYPE",a_]:>Rule["TYPE",a]]/.element)<>StringJoin@@(
Switch[
Head[#],
Symbol,If[(#/.element/.{#->Null})=!=Null,","<>ToString[#]<>"="<>formatString[Evaluate[(#/.element)]],""],
String,If[(#/.element/.{#->Null})=!=Null,","<>ToString[#]<>"="<>formatString[Evaluate[(#/.element)]],""],
Rule,If[(#[[1]]/.element/.{#[[1]]->Null})=!=Null,","<>ToString[#[[2]]]<>"="<>formatString[Evaluate[(#[[1]]/.element)]],""]
]&/@DeleteCases[MADRules[ToUpperCase[Evaluate["TYPE"/.element]]],Rule["TYPE",a_]])<>";\n"
]


Clear[generateLineDefinitionMAD];
generateLineDefinitionMAD[line:elementLine[list__],file_,subline_:False]:=Block[{},
If[Not[subline],generatedLines={}];
Map[generateLineDefinitionMAD[#,file,True]&,Union[Select[{list},Head[#]===elementLine&],SameTest->(ToUpperCase[#1["NAME"]]===ToUpperCase[#2["NAME"]]&)]];
If[!MemberQ[generatedLines,StringReplace[line["NAME"],MADNameRules]],
AppendTo[generatedLines,StringReplace[line["NAME"],MADNameRules]];
(*Print[StringReplace[line["NAME"],"-"\[Rule]""]<>": Line = ("<>StringJoin@@
MapIndexed[If[#2[[1]]>1,",",""]<>ToString[#]&,Names[elementLine[list]]]<>")\n"];*)
WriteString[file,wrapString[StringReplace[line["NAME"],MADNameRules]<>": Line = ("<>StringJoin@@
MapIndexed[If[#2[[1]]>1,",",""]<>StringReplace[ToString[#],MADNameRules]&,Names[elementLine[list],True]]<>");\n"]]
]
]


Clear[generateLineDefinition];
generateLineDefinition[line:elementLine[list__],file_,subline_:False]:=Block[{},
If[Not[subline],generatedLines={}];
Map[generateLineDefinition[#,file,True]&,Union[Select[{list},Head[#]===elementLine&],SameTest->(ToUpperCase[#1["NAME"]]===ToUpperCase[#2["NAME"]]&)]];
If[!MemberQ[generatedLines,ToUpperCase[StringReplace[line["NAME"],"-"->""]]],
AppendTo[generatedLines,ToUpperCase[StringReplace[line["NAME"],"-"->""]]];
(*Print[StringReplace[line["NAME"],"-"\[Rule]""]<>": Line = ("<>StringJoin@@
MapIndexed[If[#2[[1]]>1,",",""]<>ToString[#]&,Names[elementLine[list]]]<>")\n"];*)
WriteString[file,wrapString[StringReplace[line["NAME"],"-"->""]<>": Line = ("<>StringJoin@@
MapIndexed[If[#2[[1]]>1,",",""]<>ToString[#]&,Names[elementLine[list],True]]<>")\n"]]
]
]


Clear[MADWriteElementStrings];
SetAttributes[MADWriteElementStrings,HoldFirst];
MADWriteElementStrings[lattice_Symbol]/;Head[Evaluate[lattice]]==elementLine:=Block[{},
generatedLines={"NAME"};
MADWriteElements[lattice]
];
MADWriteElementStrings[lattice_elementLine]:=Block[{},
MADWriteElements[lattice]
]


Clear[elegantWriteElements];
elegantWriteElements[elementLine[list__]]:=elegantWriteElements/@Union[Cases[{list},elementDefinition[__Rule],\[Infinity]],SameTest->(ToUpperCase[#1["NAME"]]===ToUpperCase[#2["NAME"]]&)]
elegantWriteElements[elementDefinition[list__Rule]]:=Block[{element},
element=capitalRuleNames[elementDefinition[list]];
("NAME"/.element)<>":"<>("TYPE"/.Cases[ElegantRules[ToUpperCase[Evaluate["TYPE"/.element]]],Rule["TYPE",a_]:>Rule["TYPE",a]]/.element)<>StringJoin@@(
Switch[
Head[#],
Symbol,If[(#/.element/.{#->Null})=!=Null,","<>ToString[#]<>"="<>formatString[Evaluate[(#/.element)]],""],
String,If[(#/.element/.{#->Null})=!=Null,","<>ToString[#]<>"="<>formatString[Evaluate[(#/.element)]],""],
Rule,If[(#[[1]]/.element/.{#[[1]]->Null})=!=Null,","<>ToString[#[[2]]]<>"="<>formatString[Evaluate[(#[[1]]/.element)]],""]
]&/@DeleteCases[ElegantRules[ToUpperCase[Evaluate["TYPE"/.element]]],Rule["TYPE",a_]])<>";\n"
]


Clear[ElegantWriteElementStrings];
SetAttributes[ElegantWriteElementStrings,HoldFirst];
ElegantWriteElementStrings[lattice_Symbol]/;Head[Evaluate[lattice]]==elementLine:=Block[{},
generatedLines={"NAME"};
elegantWriteElements[lattice]
];
ElegantWriteElementStrings[lattice_elementLine]:=Block[{},
elegantWriteElements[lattice]
]


Clear[elegantWriteCommand];
elegantWriteCommand[list__commandDefinition]:=Quiet@Block[{option,name},
option=capitalRuleNames[#];
"&"<>("command"/.option)<>"\n"<>StringJoin@@(
(If[(param=#/.option/.{#->Null})=!=Null,
Switch[
Head[param],
List,name=#;
MapIndexed[Block[{no=#2[[1]]-1},
"\t"<>ToString[name]<>"["<>ToString[no]<>"]="<>formatString[#]<>"\n"]&,param],
HoldForm,"\t"<>ToString[#]<>"="<>formatString[param]<>"\n",
Symbol,"\t"<>ToString[#]<>"="<>formatString[param]<>"\n",
String,"\t"<>ToString[#]<>"="<>formatString[param]<>"\n",
Integer,"\t"<>ToString[#]<>"="<>formatString[ToString[param]]<>"\n",
Real,"\t"<>ToString[#]<>"="<>formatString[ToString[param]]<>"\n",
Rule,"\t"<>ToString[#[[2]]]<>"="<>formatString[Evaluate[(#[[1]]/.option)]]<>"\n",
_,"\t"<>ToString[#]<>"="<>formatString[param]<>"\n"
],""])&/@ElegantRules[ToLowerCase[Evaluate["command"/.option]]])<>"&end\n\n"
]&/@Union[{list},SameTest->(("command"/.capitalRuleNames[#1])==("command"/.capitalRuleNames[#2])&)]


Clear[MADWriteCommand];
MADWriteCommand[list__commandDefinition]:=Quiet@Block[{option,name},
option=capitalRuleNames[#];
("command"/.option)<>","<>StringJoin@@(
(If[(param=#/.option/.{#->Null})=!=Null,
(*Print[#,"  ",Head[param]];*)
Switch[
Head[param],
List,name=#;
ToString[name]<>"="<>StringJoin@@Map[formatString[#]<>","&,param]<>"&\n",
HoldForm,ToString[#]<>"="<>formatString[param]<>",&\n",
Symbol,ToString[#]<>If[formatString[param]=!="","="<>formatString[param],""]<>",&\n",
String,ToString[#]<>If[formatString[param]=!="","="<>formatString[param],""]<>",&\n",
Integer,ToString[#]<>"="<>formatString[ToString[param]]<>",&\n",
Real,ToString[#]<>"="<>formatString[ToString[param]]<>",&\n",
Nothing,ToString[#]<>",&\n",
Rule,ToString[#[[2]]]<>"="<>formatString[Evaluate[(#[[1]]/.option)]]<>",&\n",
_,ToString[#]<>"="<>formatString[param]<>",&\n"
],""])&/@MADRules[ToLowerCase[Evaluate["command"/.option]]])<>";\n"
]&/@Union[{list},SameTest->(("command"/.capitalRuleNames[#1])==("command"/.capitalRuleNames[#2])&)]


Head[Nothing]


Clear[elegantWriteCommandStrings];
SetAttributes[elegantWriteCommandStrings,HoldFirst];
elegantWriteCommandStrings[commands_]/;Head[Evaluate[commands]]==List:=Block[{},
Map[elegantWriteCommand[#]&,commands]
]


Clear[MADWriteCommandStrings];
SetAttributes[MADWriteCommandStrings,HoldFirst];
MADWriteCommandStrings[commands_]/;Head[Evaluate[commands]]==List:=Block[{},
Map[MADWriteCommand[#]&,commands]
]


Clear[MADWriteLattice];
SetAttributes[MADWriteLattice,HoldFirst];
MADWriteLattice[lattice_,filename_]:=Block[{file},
Quiet[Close[filename]];
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,MADWriteElementStrings[lattice]];
generateLineDefinitionMAD[Evaluate[lattice],file];
Close[file]
];


Clear[ElegantWriteLattice];
SetAttributes[ElegantWriteLattice,HoldFirst];
ElegantWriteLattice[lattice_,filename_]:=Block[{file},
Quiet[Close[filename]];
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,ElegantWriteElementStrings[lattice]];
generateLineDefinition[Evaluate[lattice],file];
Close[file]
];


Clear[ElegantWriteCommands];
SetAttributes[ElegantWriteCommands,HoldFirst];
ElegantWriteCommands[commands_List,filename_]:=Block[{file},
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,elegantWriteCommandStrings[Select[commands,Length[Cases[capitalRuleNames[#],Rule["command",a_]:>a]]>0&]]];
Close[file]
];
ElegantWriteCommands[commands_commandDefinition,filename_]:=Block[{file},
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,elegantWriteCommandStrings[Select[{commands},Length[Cases[capitalRuleNames[#],Rule["command",a_]:>a]]>0&]]];
Close[file]
];


Clear[MADWriteCommands];
SetAttributes[MADWriteCommands,HoldFirst];
MADWriteCommands[commands_List,filename_]:=Block[{file},
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,MADWriteCommandStrings[Select[commands,Length[Cases[capitalRuleNames[#],Rule["command",a_]:>a]]>0&]]];
Close[file]
];
MADWriteCommands[commands_commandDefinition,filename_]:=Block[{file},
file=OpenWrite[filename];
Map[WriteString[file,wrapString[StringJoin@@#]]&,MADWriteCommandStrings[Select[{commands},Length[Cases[capitalRuleNames[#],Rule["command",a_]:>a]]>0&]]];
Close[file]
];


(* ::Code:: *)
$MADPath="c:\\mad8dl\\";


(* ::Code:: *)
$MADFilename="mad8dl.bat";


(* ::Code:: *)
MADRun[filename_]:=Block[{},
ReadList["!"<>$MADPath<>If[$MADPath=!="","\\",""]<>$MADFilename<>" "<>filename,Record]
]


(* ::Code:: *)
$elegantPath="";


(* ::Code:: *)
$sddsPath="";


(* ::Code:: *)
$elegantFilename="elegant";


(* ::Code:: *)
ElegantRun[filename_]:=Block[{},
ReadList["!"<>$elegantPath<>If[$elegantPath=!="","\\",""]<>$elegantFilename<>" "<>filename<>" > "<>StringReplace[filename,".ele"->".log"],Record]
]


(* ::Code:: *)
sddsCommand[command_String, filename_String,opts___Rule]:=Block[{createOutput},
createOutput=Global`CreateOutput/.{opts}/.{Global`CreateOutput->False};
If[createOutput==True,
ReadList["!"<>$sddsPath<>If[$sddsPath=!="","\\",""]<>command<>" "<>filename<>" "<>filename<>"."<>command,Record];
sddsBinaryInterpret[filename<>".analysis",opts],
sddsBinaryInterpret[OpenRead["!"<>command<>" -pipe=output "<>filename,BinaryFormat->True],opts]
]
]


(* ::Code:: *)
sddsAnalyzeBeam[filename_,opts___Rule]:=Block[{createOutput},
createOutput=Global`CreateOutput/.{opts}/.{Global`CreateOutput->False};
If[createOutput==True,
ReadList["!"<>$elegantPath<>If[$elegantPath=!="","\\",""]<>"sddsanalyzebeam "<>filename<>" "<>filename<>".analysis",Record];
sddsBinaryInterpret[filename<>".analysis",opts],
sddsBinaryInterpret[OpenRead["!"<>$elegantPath<>If[$elegantPath=!="","\\",""]<>"sddsanalyzebeam -pipe=output "<>filename,BinaryFormat->True],opts]
]
]


Clear[MADTwiss];


SetAttributes[MADTwiss,HoldFirst];
MADTwiss[lattice_,commands___commandDefinition,opts___Rule]:=Block[{filename},
filename="temp";
callfile=commandDefinition[opts,"filename"->filename<>".mff","command"->"call"];
runsetup=commandDefinition[opts,"PERIOD"->HoldForm[lattice],"command"->"use"];
selectcommand=commandDefinition[opts,"full"->"","flag"->"optics","Command"->"select"];
twissoutput=commandDefinition[opts,"filename"->filename<>".twi","Command"->"optics","columns"->{"s","betx","bety","alfx","alfy","dx","dy","dpx","dpy","name"}];
MADWriteCommands[{callfile,runsetup,selectcommand,twissoutput,commands},filename<>".mad"];
MADWriteLattice[lattice,filename<>".mff"];
MADRun[filename<>".mad"];
mfsInterpret[filename<>".twi",mfsDrop->False];
Global`s=Drop[Global`S,-1];
Global`betax=Drop[Global`BETX,-1];
Global`betay=Drop[Global`BETY,-1];
Global`alphax=Drop[Global`ALFX,-1];
Global`alphay=Drop[Global`ALFY,-1];
Global`etax=Drop[Global`DX,-1];
Global`etay=Drop[Global`DY,-1];
Global`etaxp=Drop[Global`DPX,-1];
Global`etayp=Drop[Global`DPY,-1];
Global`ElementName=Drop[Global`NAME,-1];
]


SetAttributes[MADTwiss,HoldFirst];
MADTwiss[lattice_,{alphax_, betax_,alphay_,betay_,enx_:10^-6,eny_:10^-6},commands___commandDefinition,opts___Rule]:=Block[{filename},
filename="temp";
callfile=commandDefinition[opts,"filename"->filename<>".mff","command"->"call"];
runsetup=commandDefinition[opts,"PERIOD"->HoldForm[lattice],"command"->"use"];
selectcommand=commandDefinition[opts,"full"->"","flag"->"optics","Command"->"select"];
twissoutput=commandDefinition[opts,"filename"->filename<>".twi","Command"->"optics","betx"->betax,"bety"->betay,"alfx"->alphax,"alfy"->alphay,"columns"->{"s","betx","bety","alfx","alfy","dx","dy","dpx","dpy","name"}];
MADWriteCommands[{callfile,runsetup,selectcommand,twissoutput,commands},filename<>".mad"];
MADWriteLattice[lattice,filename<>".mff"];
MADRun[filename<>".mad"];
mfsInterpret[filename<>".twi",mfsDrop->False];
Global`s=Drop[Global`S,-1];
Global`betax=Drop[Global`BETX,-1];
Global`betay=Drop[Global`BETY,-1];
Global`alphax=Drop[Global`ALFX,-1];
Global`alphay=Drop[Global`ALFY,-1];
Global`etax=Drop[Global`DX,-1];
Global`etay=Drop[Global`DY,-1];
Global`etaxp=Drop[Global`DPX,-1];
Global`etayp=Drop[Global`DPY,-1];
Global`ElementName=Drop[Global`NAME,-1];
]


Clear[ElegantTwiss];


SetAttributes[ElegantTwiss,HoldFirst];
ElegantTwiss[lattice_,momentum_:1000,commands___commandDefinition,split_Integer:1,opts___Rule]:=ElegantTwiss[lattice,momentum,commands,Before[],split,opts]
ElegantTwiss[lattice_,momentum_:1000,commands___commandDefinition,Before[bcommands___commandDefinition],split_Integer:1,opts___Rule]:=Block[{filename},
filename="temp";
runsetup=commandDefinition[opts,"LATTICE"->FileBaseName[filename]<>".lte","command"->"run_setup","use_beamline"->HoldForm[lattice],"p_central_mev"->momentum,"centroid"->"%s.cen","sigma" ->"%s.sig","default_order"->3,"parameters"->"%s.param",
"output"->"%s.out","losses"->"%s.lost","final"->"%s.final","element_divisions"->split];
runcontrol=commandDefinition[opts,"n_steps"->1,"n_passes"->1,"Command"->"run_control"];
twissoutput=commandDefinition[opts,"filename"->"%s.twi","matched"->1,"Command"->"twiss_output","radiation_integrals"->1,"statistics"->1];
matrixoutput=commandDefinition[opts,"SDDS_output"->"%s.matrix","SDDS_output_order"->2,"individual_matrices"->0,"Command"->"matrix_output"];
flooroutput=commandDefinition[opts,"filename"->"%s.flr","Command"->"floor_coordinates"];
beamoutput=commandDefinition[opts,"Command"->"bunched_beam","n_particles_per_bunch"->2^10,"use_twiss_command_values"->1];
trackoutput=commandDefinition[opts,"Command"->"track"];
ElegantWriteCommands[{runsetup,runcontrol,bcommands,twissoutput,matrixoutput,flooroutput,commands(*,beamoutput,trackoutput*)},filename<>".ele"];
ElegantWriteLattice[lattice,filename<>".lte"];
ElegantRun[filename<>".ele"];
If[FileExistsQ[filename<>".sig"],
sddsBinaryInterpret[filename<>".sig",Global`sddsPrefix->"sig$"]];
If[FileExistsQ[filename<>".cen"],
sddsBinaryInterpret[filename<>".cen",Global`sddsPrefix->"cen$"]];
sddsBinaryInterpret[filename<>".twi"]
]


SetAttributes[ElegantTwiss,HoldFirst];
ElegantTwiss[lattice_,{alphax_, betax_,alphay_,betay_,enx_:10^-6,eny_:10^-6},momentum_:1000,commands___commandDefinition,split_Integer:1,opts___Rule]:=ElegantTwiss[lattice,{alphax, betax,alphay,betay,enx,eny},momentum,commands,Before[],split,opts]
ElegantTwiss[lattice_,{alphax_, betax_,alphay_,betay_,enx_:10^-6,eny_:10^-6},momentum_:1000,commands___commandDefinition,Before[bcommands___commandDefinition],split_Integer:1,opts___Rule]:=Block[{filename},
filename="temp";
runsetup=commandDefinition[opts,"LATTICE"->FileBaseName[filename]<>".lte","command"->"run_setup","use_beamline"->HoldForm[lattice],"p_central_mev"->momentum,"centroid"->"%s.cen","sigma" ->"%s.sig","default_order"->3,"parameters"->"%s.param",
"output"->"%s.out","losses"->"%s.lost","final"->"%s.final","element_divisions"->split];
runcontrol=commandDefinition[opts,"n_steps"->1,"n_passes"->1,"Command"->"run_control"];
twissoutput=commandDefinition[opts,"filename"->"%s.twi","matched"->0,"Command"->"twiss_output","beta_x"->betax,"beta_y"->betay,"alpha_x"->alphax,"alpha_y"->alphay,"enx"];
matrixoutput=commandDefinition[opts,"SDDS_output"->"%s.matrix","SDDS_output_order"->2,"individual_matrices"->0,"Command"->"matrix_output"];
flooroutput=commandDefinition[opts,"filename"->"%s.flr","Command"->"floor_coordinates"];
beamoutput=commandDefinition[opts,"Command"->"bunched_beam","n_particles_per_bunch"->2^10,"use_twiss_command_values"->1];
trackoutput=commandDefinition[opts,"Command"->"track"];
ElegantWriteCommands[{runsetup,runcontrol,bcommands,twissoutput,matrixoutput,flooroutput,commands(*,beamoutput,trackoutput*)},filename<>".ele"];
ElegantWriteLattice[lattice,filename<>".lte"];
ElegantRun[filename<>".ele"];
If[FileExistsQ[filename<>".sig"],
sddsBinaryInterpret[filename<>".sig",Global`sddsPrefix->"sig$"]];
If[FileExistsQ[filename<>".cen"],
sddsBinaryInterpret[filename<>".cen",Global`sddsPrefix->"cen$"]];
sddsBinaryInterpret[filename<>".twi"]
]


elementClass["dipole"]={"CSBEND","CSRCSBend","KSBEND","NIBEND","dipole","sbend"};
elementClass["quadrupole"]={"KQUAD","QUAD","quadrupole"};
elementClass["sextupole"]={"KSEXT","SEXT"};
elementClass["drift"]={"CSRDRIFT","DRIF","EDRIFT","LSCDRIFT","drift"};
elementClass["octupole"]={"KOCT","OCTU"};
elementClass["rfc"]={"RFCA","RFCW","MODRF","RFTMEZ0","LCAV"};
elementClass["solenoid"]={"MAPSOLENOID","SOLE"};
elementClass["wiggler"]={"WIGGLER","CWIGGLER","GFWIGGLER"};
elementClass["kicker"]={"EHKICK","EKICKER","EVKICK","HKICK","KICKER","UKICKMAP","VKICK","kicker","hkicker","vkicker"};
elementClass["bpm"]={"MONI","HMON","VMON","MONITOR","beam_position_monitor"};
elementClass["multipole"]={"FMULT","MULT"};
elementClass["collimator"]={"ECOL","RCOL"};
elementClass["marker"]={"MARK","WATCH"};
elementClass["cavity"]={"RFC","cavity","integrated_current_transformer","RFCW","RFCA"};
elementClass["screen"]={"screen"};
elementClass["shutter"]={"shutter"};
elementClass["valve"]={"valve"};
elementClass["bellows"]={"bellows"};


Clear[findElementClass];
findElementClass[a_elementDefinition]:=Block[{},
type=a["TYPE"];
If[type===0,elementClass["marker"],
class=Select[DownValues[elementClass],MemberQ[ToUpperCase[#[[2]]],ToUpperCase[type]]&];
If[class==={},"marker",
class[[1,1,1,1]]
]
]
]


Clear[pelement];


Clear[elementDrawRotation];
elementDrawRotation[{x_,y_},\[Theta]_]:={x Cos[\[Theta]]-y Sin[\[Theta]],x Sin[\[Theta]]+y Cos[\[Theta]]};


TextOscillate[]:=Switch[TEXTOSCILLATE,1,TEXTOSCILLATE=-1,-1,TEXTOSCILLATE=1,_,1]


TextDirection[]:=Switch[TEXTOSCILLATE,-1,1,_,-1]


pelement["drift",position_,length_,bend_,rotation_,label_,opts___]:=Block[{wdr,widthscale,text,driftlabels,driftlengths},
driftlabels=Global`DriftLabels/.{opts}/.{Global`DriftLabels->False};
driftlengths=Global`DriftLengths/.{opts}/.{Global`DriftLengths->False};
text=ElementDrawText/. {opts}/. Options[ElementDraw];
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wdr=0.16widthscale;
Join[{Line[{position,position+elementDrawRotation[length*{1,0},rotation]}]},
If[text,
If[driftlabels===True,
If[driftlengths===True,label=label<>"\n"<>ToString[numberRight[length]]<>"m"];
{Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{0.5wdr Sin[-rotation], 0.5 wdr Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}]},
If[driftlengths===True,{Text[ToString[numberRight[length]]<>"m",position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1wdr Sin[-rotation], 1 wdr Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}]},{}]]
,{}]]];


wd:=0.1*widthscale;


rho[l_,\[Theta]_]:=l/\[Theta]


Clear[arcPos];
arcPos[r_,\[Theta]_]:=Reverse[{Limit[r(Cos[\[Theta]1]-1),\[Theta]1->\[Theta]],Limit[r Sin[\[Theta]1],\[Theta]1->\[Theta]]}]


pelement["dipole",position_,length_,bend_,rotation_,label_,opts___]:=Block[{elem,text,bends,thick,colour,widthscale,e1,e2},
elem=Element/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
bends=Bends/. {opts}/. Options[ElementDraw];
thick=Thickness/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wd=0.1*widthscale;
e1=elem[[6]]["E1"];
e2=elem[[6]]["E2"];
ArcMatrix[\[Theta]_]:={{1,0},{Sin[bend],(Cos[bend]-1)}};
If[bends&&Abs[bend]>0.001&&length>0,
{colour,Thickness[thick],

If[Abs[e1]>0||Abs[e2]>0,
If[bend<0,
{Line[{position+elementDrawRotation[{0,wd},rotation].RotationMatrix[Sign[bend]e1],position+elementDrawRotation[arcPos[rho[length,-bend],-bend],rotation]+elementDrawRotation[{0,wd},rotation+bend].RotationMatrix[-Sign[bend]e2]}],
Line[{position+elementDrawRotation[{0,-wd},rotation].RotationMatrix[Sign[bend]e1],position+elementDrawRotation[arcPos[rho[length,-bend],-bend],rotation]+elementDrawRotation[{0,-wd},rotation+bend].RotationMatrix[-Sign[bend]e1]}]},
{Line[{position+elementDrawRotation[{0,wd},rotation].RotationMatrix[-Sign[bend]e1],position+elementDrawRotation[arcPos[rho[length,-bend],-bend],rotation]+elementDrawRotation[{0,wd},rotation+bend].RotationMatrix[Sign[bend]e2]}],
Line[{position+elementDrawRotation[{0,-wd},rotation].RotationMatrix[-Sign[bend]e1],position+elementDrawRotation[arcPos[rho[length,-bend],-bend],rotation]+elementDrawRotation[{0,-wd},rotation+bend].RotationMatrix[Sign[bend]e1]}]}],
{Circle[position+elementDrawRotation[{0,length/bend},rotation],Abs[length/Abs[bend]-wd],
If[bend>=0,{(3\[Pi])/2+rotation+e1,(3\[Pi])/2+bend+rotation},{(-3\[Pi])/2+rotation+bend,(-3\[Pi])/2+rotation}]],

Circle[position+elementDrawRotation[{0,length/bend},rotation],Abs[length/Abs[bend]+wd  ],
If[bend>=0,{(3\[Pi])/2+rotation,(3\[Pi])/2+bend+rotation},{(-3\[Pi])/2+rotation+bend,(-3\[Pi])/2+rotation}]]}
],


Line[{position+elementDrawRotation[{0,wd},rotation].RotationMatrix[-e1],position+elementDrawRotation[{0,-wd},rotation].RotationMatrix[-e1]}],

Line[{position+elementDrawRotation[arcPos[rho[length,-bend],-bend],rotation]+elementDrawRotation[{0,wd},rotation+bend].RotationMatrix[e2],position+elementDrawRotation[arcPos[rho[length,-bend],-bend],rotation]+elementDrawRotation[{0,-wd},rotation+bend].RotationMatrix[e2]}],



(*Line[{position+elementDrawRotation[{(length/bend-wd )Sin[bend],length/bend(1-Cos[bend])+wd Cos[bend]},rotation],position+elementDrawRotation[{(length/bend+wd)(Sin[bend]),length/bend(1-Cos[bend])-wd Cos[bend]},rotation]}]*)If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.3wd Sin[-rotation-bend/2],1.3wd Cos[-rotation-bend/2]},{TextDirection[],0},{Sin[-rotation-bend/2],Cos[-rotation-bend/2]}],{}]},
{White,colour,Thickness[thick],EdgeForm[Thickness[Medium]],
Polygon[{position+elementDrawRotation[{0,wd},rotation],position+elementDrawRotation[{length,wd},rotation],position+elementDrawRotation[{length,-wd},rotation],position+elementDrawRotation[{0,-wd},rotation]}],Black,If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.3wd Sin[-rotation-0],1.3wd Cos[-rotation-0]},{TextDirection[],0},{Sin[-rotation-0],Cos[-rotation-0]}],{}]}]
]





pelement["quadrupole",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wq=0.12*widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],RGBColor[1,0,0]}],
Polygon[{position,position+elementDrawRotation[{0,1.4wq},ar rotation],position+elementDrawRotation[{length,1.4wq},ar rotation],position+elementDrawRotation[{length,-1.4wq},ar rotation],position+elementDrawRotation[-{0,1.4wq},ar rotation],position}],
Polygon[{position,position+elementDrawRotation[{0,wq},ar rotation],position+elementDrawRotation[{length,wq},ar rotation],position+elementDrawRotation[{length,-wq},ar rotation],position+elementDrawRotation[-{0,wq},ar rotation],position}],If[text,{Red,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.5wq Sin[-rotation], 1.5 wq Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}]},{}]}
];


pelement["sextupole",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale,wq},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
ws=0.08*widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],RGBColor[0,0,1]}],
Polygon[{position,position+elementDrawRotation[{0,1.4ws},rotation],position+elementDrawRotation[{length,1.4ws},rotation],position+elementDrawRotation[{length,-1.4ws},rotation],position+elementDrawRotation[-{0,1.4ws},rotation],position}],
Polygon[{position,position+elementDrawRotation[{0,ws},rotation],position+elementDrawRotation[{length,ws},rotation],position+elementDrawRotation[{length,-ws},rotation],position+elementDrawRotation[-{0,ws},rotation],position}],If[text,{Red,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.5wq Sin[-rotation], 1.5 wq Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}]},{}]}
];


pelement["symmline",position_,length_,bend_,rotation_,label_,opts___]:=Block[{text,wm=wkick,thick},
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
Print[widthscale];
wm=0.1*widthscale;
{Thickness[thick],Dashing[{0.01,0.01}],Line[{position+elementDrawRotation[{0,wm},rotation],position+elementDrawRotation[{0,-wm},rotation]}],If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{wm Sin[-rotation],wm Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]}
];


pelement["marker",position_,length_,bend_,rotation_,label_,opts___]:=Block[{text,widthscale,thick},
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wm=0.1*widthscale;
{Thickness[thick],RGBColor[0,0.79,0.34],Line[{position+elementDrawRotation[{0,wm},rotation],position+elementDrawRotation[{0,-wm},rotation]}],If[text&&False,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.3wm Sin[-rotation-0],1.3wm Cos[-rotation-0]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]}
];


pelement["kicker",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=text/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.07widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],RGBColor[.4,.4,.4]}],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position}],RGBColor[.4,.4,.4],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.8wkick Sin[-rotation],1.8wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


pelement["collimator",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.07widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],RGBColor[.4,.4,.4]}],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.8wkick Sin[-rotation],1.8wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


pelement["bpm",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.05widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],RGBColor[.8,.3,.8]}],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position}],RGBColor[.8,.3,.8],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.3wkick Sin[-rotation],1.3wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


screenWidth=0.1;


screenThickness=0.01;


pelement["screen",position_,lengthin_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale,length=0.05,wscreen},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wscreen=screenWidth*widthscale;
If[lengthin<0.01,length=screenThickness,length=lengthin];
{colour,Thickness[thick],RGBColor[.5,.3,.7],EdgeForm[{Thickness[Medium],RGBColor[.5,.3,.7]}],
Polygon[{position,position+elementDrawRotation[{0,wscreen},rotation],position+elementDrawRotation[{length,wscreen},rotation],position+elementDrawRotation[{length,-1*wscreen},rotation],position+elementDrawRotation[-{0,wscreen},rotation],position}],
If[text,Text[label,position+{0.05 Cos[rotation],0.05 Sin[rotation]}+TextOscillate[]{1.3wscreen Sin[-rotation],1.3wscreen Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


pelement["shutter",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->Darker[Gray]};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.07widthscale;
{colour,Thickness[thick],Black,EdgeForm[{Thickness[Medium],Black}],colour,
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.8wkick Sin[-rotation],1.8wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


pelement["valve",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->Lighter[Green]};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.07widthscale;
{Thickness[thick],Black,EdgeForm[{Thickness[Medium],Black}],colour,
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.8wkick Sin[-rotation],1.8wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


pelement["bellows",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->Lighter[Green,0.7]};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.07widthscale;
{Thickness[thick],EdgeForm[{Thickness[Small],Black}],colour,
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{1.8wkick Sin[-rotation],1.8wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


pelement["wiggler",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.1widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],Brown}],FaceForm[Brown],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position},VertexTextureCoordinates->{{0,0},{1,0},{1/2,1}}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{2.3wkick Sin[-rotation],2.3wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


pelement["solenoid",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.12widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],Pink}],FaceForm[Pink],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position},VertexTextureCoordinates->{{0,0},{1,0},{1/2,1}}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{2.3wkick Sin[-rotation],2.3wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


pelement["cavity",position_,length_,bend_,rotation_,label_,opts___]:=Block[{ar,thick,text,colour,widthscale},
ar= 1+0(1/AspectRatio/.{opts}/.{AspectRatio->1});
thick=Thickness/. {opts}/. Options[ElementDraw];
text=Labels/. {opts}/. Options[ElementDraw];
colour=Colour/.{opts}/.{Colour->{}};
widthscale=WidthScale/. {opts}/. Options[ElementDraw];
wkick=0.12widthscale;
{colour,Thickness[thick],White,EdgeForm[{Thickness[Medium],Green}],FaceForm[Green],
Polygon[{position,position+elementDrawRotation[{0,wkick},rotation],position+elementDrawRotation[{length,wkick},rotation],position+elementDrawRotation[{length,-1*wkick},rotation],position+elementDrawRotation[-{0,wkick},rotation],position},VertexTextureCoordinates->{{0,0},{1,0},{1/2,1}}],
If[text,Text[label,position+{length/2 Cos[rotation],length/2 Sin[rotation]}+TextOscillate[]{2.3wkick Sin[-rotation],2.3wkick Cos[-rotation]},{TextDirection[],0},{Sin[-rotation],Cos[-rotation]}],{}]
}
];


Clear[ElementDraw,ElementPositions];


ElementPositions[data_,opts___]:=Block[{text,thick,bpms,lengths,filled,widthscale,symms,bends,closed,offset,optShow,elementList,lattice,elementDrawRot, roty,sinc2,xform,localXYZ,x,graph,sinc,cosc,sym, tilt,findrotations,findrotationsv,anglesum=0,sum1,x1,prepositions2,start,end,names,vbends},
text=Labels/. {opts}/. Options[ElementDraw];thick=Thick/. {opts}/. Options[ElementDraw];bpms=Monitors/. {opts}/. Options[ElementDraw];lengths=Lengths/. {opts}/. Options[ElementDraw];filled=Filled/. {opts}/. Options[ElementDraw];If[filled,shape="Polygon",shape="Line"];widthscale=WidthScale/. {opts}/. Options[ElementDraw];symms=Symms/. {opts}/. Options[ElementDraw];bends=Bends/. {opts}/. Options[ElementDraw];closed=CheckClosed/. {opts}/. Options[ElementDraw];offset=Offset/. {opts}/. {Offset->{0,0,0}};
names=Global`ElementNames/. {opts}/. {Global`ElementNames->False};
vbends=Global`VerticalBends/.{opts}/.{Global`VerticalBends->False};optShow=Join[{Sequence@@FilterRules[Flatten[{opts}],Options[Graphics]]},{Sequence@@FilterRules[Flatten[{opts}],Options[Show]]}];

If[symms,
start=elementDefinition["TYPE"->"Mark","NAME"->"START","LABEL"->""];
end=elementDefinition["TYPE"->"Mark","NAME"->"END","LABEL"->""];
elementList=Join[{start},Flatten[data],{end}];
,elementList=Flatten[data]];
(*If[Not[bpms],elementList=Select[elementList,#1\[LeftDoubleBracket]2\[RightDoubleBracket]=!="BPM"&]];*)

tilt[element_]:=Switch[findElementClass[element],
"adipole",element["TILT"] ,
_,0];

lattice=({findElementClass[#],#1["LENGTH"],N[#["BENDANGLE"]],"",tilt[#1],#}&)/@elementList;

(*roty[line_,\[Theta]_]:={line\[LeftDoubleBracket]1\[RightDoubleBracket] Sin[\[Theta]]-line\[LeftDoubleBracket]2\[RightDoubleBracket] Cos[\[Theta]],line\[LeftDoubleBracket]1\[RightDoubleBracket] Cos[\[Theta]]+line\[LeftDoubleBracket]2\[RightDoubleBracket] Sin[\[Theta]]};
sinc[\[Theta]_]:=If[Abs[\[Theta]]>0,Sin[\[Theta]]/\[Theta],1];
cosc[\[Theta]_]:=If[Abs[\[Theta]]>0,(1-Cos[\[Theta]])/\[Theta],0];
sinc2[\[Theta]_]:=If[Abs[\[Theta]]>0,Sin[\[Theta]]/\[Theta],0];
sym={"symmline",0,0,"",0};*)

(*If[bends===True,findrotations=(
Switch[#\[LeftDoubleBracket]1\[RightDoubleBracket],
"dipole",anglesum+=Cos[#[[5]]]#1\[LeftDoubleBracket]3\[RightDoubleBracket],
_,anglesum]&/@Drop[Prepend[lattice,{0,0,0,"",0}],-1]),findrotations=Table[0.,{Length[lattice]}]];

findrotationsv=(sum1=0;(sum1+=Sin[#[[5]]]#1\[LeftDoubleBracket]3\[RightDoubleBracket]&)/@Drop[Prepend[lattice,{0,0,0,"",0}],-1]);
*)
xform[{angle_,tilt_,length_},{x_,r_}]:=Block[{dx,n,rt,rp},
end=x+Flatten[If[Abs[angle]>0,{{(length (-Cos[r]+Cos[angle+r]))/angle},{0},{(length (-Sin[r]+Sin[angle+r]))/angle}},{{-length Sin[r]},{0},{length Cos[r]}}]];
{end,r+angle}
];
x={{#}&/@offset};
localXYZ=0;
Block[{},
{x1,localXYZ}=xform[{If[bends,-#[[3]],0],-#[[5]],#[[2]]},{x[[-1]],localXYZ}];
AppendTo[x,x1]]&/@lattice;
prepositions2=Most[x[[All,All,1]]];
If[names==True,
prepositions2=Transpose[{#[[-1]]["NAME"]&/@lattice,prepositions2}];
];
prepositions2]


ElementDraw[data_,opts___]:=Block[{text,thick,bpms,lengths,filled,widthscale,symms,bends,closed,offset,optShow,elementList,lattice,elementDrawRot, roty,sinc2,xform,localXYZ,x,graph,sinc,cosc,sym, tilt,findrotations,findrotationsv,anglesum=0,sum1,x1,prepositions2},
text=Labels/. {opts}/. Options[ElementDraw];thick=Thick/. {opts}/. Options[ElementDraw];bpms=Monitors/. {opts}/. Options[ElementDraw];lengths=Lengths/. {opts}/. Options[ElementDraw];filled=Filled/. {opts}/. Options[ElementDraw];If[filled,shape="Polygon",shape="Line"];widthscale=WidthScale/. {opts}/. Options[ElementDraw];symms=Symms/. {opts}/. Options[ElementDraw];bends=Bends/. {opts}/. Options[ElementDraw];closed=CheckClosed/. {opts}/. Options[ElementDraw];offset=Offset/. {opts}/. Options[ElementDraw];
$BENDSIGN=BendSign/. {opts}/. Options[ElementDraw];
vbends=Global`VerticalBends/.{opts}/.{Global`VerticalBends->False};optShow=Join[{Sequence@@FilterRules[Flatten[{opts}],Options[Graphics]]},{Sequence@@FilterRules[Flatten[{opts}],Options[Show]]}];elementList=Flatten[data];
(*If[Not[bpms],elementList=Select[elementList,#1\[LeftDoubleBracket]2\[RightDoubleBracket]=!="BPM"&]];*)

tilt[element_]:=Switch[findElementClass[element],
"dipole",element["TILT"] ,
_,0];

lattice=({findElementClass[#],#1["LENGTH"],N[#["BENDANGLE"]],"",tilt[#1],#}&)/@elementList;

(*roty[line_,\[Theta]_]:={line\[LeftDoubleBracket]1\[RightDoubleBracket] Sin[\[Theta]]-line\[LeftDoubleBracket]2\[RightDoubleBracket] Cos[\[Theta]],line\[LeftDoubleBracket]1\[RightDoubleBracket] Cos[\[Theta]]+line\[LeftDoubleBracket]2\[RightDoubleBracket] Sin[\[Theta]]};
sinc[\[Theta]_]:=If[Abs[\[Theta]]>0,Sin[\[Theta]]/\[Theta],1];
cosc[\[Theta]_]:=If[Abs[\[Theta]]>0,(1-Cos[\[Theta]])/\[Theta],0];
sinc2[\[Theta]_]:=If[Abs[\[Theta]]>0,Sin[\[Theta]]/\[Theta],0];
sym={"symmline",0,0,"",0};*)

If[bends===True,findrotations=(
Switch[#[[1]],
"dipole",anglesum+=$BENDSIGN Cos[#[[5]]]#1[[3]],
_,anglesum]&/@Drop[Prepend[lattice,{0,0,0,"",0}],-1]),findrotations=Table[0.,{Length[lattice]}]];

findrotationsv=(sum1=0;(sum1+=Sin[#[[5]]]#1[[3]]&)/@Drop[Prepend[lattice,{0,0,0,"",0}],-1]);

xform[{\[Theta]_,tilt_,length_},{x_,r_}]:=Block[{dx,n,rt,rp},
dx=r.({
 {Cos[tilt], -Sin[tilt], 0},
 {Sin[tilt], Cos[tilt], 0},
 {0, 0, 1}
}).({
 {Limit[length/\[Theta]1 (Cos[\[Theta]1]-1),\[Theta]1->\[Theta]]},
 {0},
 {Limit[length/\[Theta]1 Sin[\[Theta]1],\[Theta]1->\[Theta]]}
});
rt=Transpose[r];
n=rt[[2]]Cos[tilt]-rt[[1]]Sin[tilt];
rp=Outer[Times,rt.n,n](1-Cos[\[Theta]])+rt Cos[\[Theta]]+{Cross[rt[[1]],n],Cross[rt[[2]],n],Cross[rt[[3]],n]}Sin[\[Theta]];
{x+dx,Transpose[rp]}
];
Which[ListQ[offset],
x={({
 {offset[[2]]},
 {0},
 {offset[[1]]}
})},
NumberQ[offset],
x={({
 {offset},
 {0},
 {0}
})},
True,
x={({
 {0},
 {0},
 {0}
})}
];
localXYZ=IdentityMatrix[3];
Block[{},
{x1,localXYZ}=xform[{If[bends,-$BENDSIGN#[[3]],0],-$BENDSIGN#[[5]],#[[2]]},{x[[-1]],localXYZ}];
AppendTo[x,x1]]&/@lattice;
prepositions2=Most[x[[All,{3,1},1]]];
Clear[TEXTOSCILLATE];
graph=Graphics[pelement[#1[[1,1]],#1[[2]],#1[[1,2]] ,If[bends,$BENDSIGN Cos[#[[1,5]]]#1[[1,3]],0],#1[[3]],StringReplace[#[[1,-1]]["NAME"],{"$"->"-"}],Element->#[[1]],opts]&/@Transpose[{lattice,prepositions2,findrotations}]];
Show[graph,optShow,Sequence@@FilterRules[Flatten[{Options[ElementDraw]}],Options[Show]],Lighting->Automatic]]


Clear[elementSPositions]


elementSPositions[elementLine[list__]]:=Rest[FoldList[Plus,0,Map[#["LENGTH"]&,Flatten[elementLine[list]]]]]


Options[elementInfo]={Headings->{"Name","Type","Length","K1","Angle","Label","Position"}}


Clear[elementInfo];
elementInfo[lattice_elementLine,opts___Rule]:=Block[{headings=Headings/.{opts}/.Options[elementInfo]},
TableForm[Transpose[Map[Block[{heading=#},
Switch[ToUpperCase[#],
"POSITION",
elementSPositions[lattice],
"LENGTH",
Map[#["LENGTH"]&,Flatten[lattice]],
_,
Map[#[ToUpperCase[heading]]&,Flatten[lattice]]]]&,headings]],TableHeadings->{Automatic,headings}]]


allowedElegantCharacters:=(WordCharacter|DigitCharacter|"~"|"@"|"$"|"%"|"^"|"&"|"-"|"_"|"+"|"="|"{"|"}"|"["|"]"|"|"|"\\"|"/"|"?"|"<"|">"|"."|"\"")


joinSplitLines[records_]:=StringReplace[StringJoin[#],"&"->""]&/@Split[records,StringTake[StringTrim[#1],-1]=="&"&]


realNumberQ=StringMatchQ[#,StringExpression[(DigitCharacter|"+"|"-"|".")..]]&


exponentNumberQ=StringMatchQ[ToUpperCase[#],StringExpression[(DigitCharacter|"+"|"-"|"."|"E")..]]&


convertNames[string_String]:=StringReplace[string,{a:allowedElegantCharacters~~("_"|"-")~~b:allowedElegantCharacters:>a~~"$"~~b,"\""->""}]


convertRules[string_String]:=StringReplace[string,{a:allowedElegantCharacters~~("_"|"-")~~b:allowedElegantCharacters:>a~~"$"~~b,"\""->""}]


convertElementRules[string_String]:=StringReplace[string,{"ANGLE"->"BENDANGLE","ENTRANCE_EDGE_ANGLE"->"E1","EXIT_EDGE_ANGLE"->"E2","L"->"LENGTH"},IgnoreCase->True]


interpretElegentValues[string_String]:=Block[{str,notword,newstr},
Which[
realNumberQ[string],
Internal`StringToDouble[string],
exponentNumberQ[string],
Internal`StringToDouble[string],
Not[StringMatchQ[string,WhitespaceCharacter...~~"\""~~"*"~~"\""~~WhitespaceCharacter...]],
Quiet@Block[{},
str=string;
notword=StringTake[str,StringPosition[str,WordCharacter][[1,1]]-1];
newstr=StringDrop[str,StringPosition[str,WordCharacter][[1,1]]-1];
If[StringQ[notword]&&Not[notword==""],
Check[Evaluate[ToExpression[Evaluate[StringReplace[notword,{"-"->"-1"}]]]*Symbol[Evaluate[newstr]]],string],
Check[Evaluate[Symbol[Evaluate[newstr]]],string]
]],
True,
string]
]


interpretElegantRules[string_String]:=Block[{},
allrules=StringSplit[string,{",",";","\n"}];
Sequence@@Flatten[StringCases[StringTrim[#],name:(WordCharacter|"_")..~~WhitespaceCharacter...~~"="~~WhitespaceCharacter...~~value:__:>Rule[convertElementRules[name],interpretElegentValues[value]]]&/@allrules]
]


interpretElegantLines[string_String]:=Block[{},
allelements=StringSplit[string,{","}];
ToExpression[convertNames[#]]&/@allelements
]


elementInterpretLTE[filename_]:=Block[{records},
records=Select[joinSplitLines[ReadList[filename,Record,RecordSeparators->"\n"]],Not[StringMatchQ[#,WhitespaceCharacter...~~"!*"]]&];
elements=
StringCases[#,elementName:allowedElegantCharacters..~~WhitespaceCharacter...~~":"~~WhitespaceCharacter...~~elementType:(LetterCharacter)..~~((","~~rest:___))...:>element["NAME"->Evaluate[convertNames[elementName]],"TYPE"->elementType,interpretElegantRules[rest]],IgnoreCase->True]&/@records;
params=
StringCases[#,StartOfString~~elementName:(LetterCharacter~~(LetterCharacter|DigitCharacter|"_")..)..~~WhitespaceCharacter...~~":"...~~"="~~WhitespaceCharacter...~~value:(allowedElegantCharacters)..:>((*Print["Clear["~~convertNames[elementName]~~"];"~~convertNames[elementName]~~"="~~value];*)ToExpression["Clear["~~convertNames[elementName]~~"];"~~convertNames[elementName]~~"="~~value];convertNames[elementName]),1]&/@records;
lines=StringCases[#,elementName:allowedElegantCharacters..~~WhitespaceCharacter...~~":"~~WhitespaceCharacter...~~"Line"~~WhitespaceCharacter...~~"="~~WhitespaceCharacter...~~"("~~WhitespaceCharacter...~~rest:__~~")"~~WhitespaceCharacter...:>line[Evaluate[convertNames[elementName]],Evaluate[interpretElegantLines[rest]]],1,IgnoreCase->True]&/@records;
Print["New Elements:",Map[#["NAME"]&,Flatten[elements]]];
Print["New Parameters:",Flatten[Select[params,Not[#=={}]&]]];
Print["New Lines:",Flatten[lines]];
]


End[]


EndPackage[]
