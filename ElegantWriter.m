(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["ElegantWriter`",{"Madtomma`MADInput`MADInput`","numberRight`","sddsBinaryInterpret`"}]//Quiet


(* ::Input::Initialization:: *)
ElegantWrite::usage="ElegantWrite[lattice, filename, <latticename>]\nWrites lattice definition to filename, using optional line name of latticename";


ElegantRules::usage="ElegantRules[rules]\nCreate rules for an Elegant Command";


ElegantWriteCommands::usage="ElegantWriteCommands[commands, filename]\nWrites a list of commands to filename";


ElegantRun::usage="ElegantRun[filename]\nRuns Elegant on filename";


ElegantCreateErrorCommands::usage="ElegantCreateErrorCommands[]\nReturns a sequence of error_element commands.";


sddsCommand::usage="sddsCommand[command, filename]\nRuns sddsCommand on filename, and importing the output using sddsBinaryInterpret";


sddsAnalyzeBeam::usage="sddsAnalyzeBeam[filename]\nRuns sddsAnalyzeBeam on filename, and importing the output using sddsBinaryInterpret";


(* ::Input::Initialization:: *)
CSRDriftRules={};


(* ::Input::Initialization:: *)
CSBENDRules=SBENDRules={"n_kicks"->50,"integration_order"->2,"EDGE_ORDER"->2};


(* ::Input::Initialization:: *)
CSRCSBENDRules={"n_kicks"->50,"integration_order"->2,"EDGE_ORDER"->2,"bins"->10}


(* ::Input::Initialization:: *)
RBENDRules={};


(* ::Input::Initialization:: *)
QUADRules={"n_kicks"->20};


(* ::Input::Initialization:: *)
SEXTRules={"n_kicks"->20};


(* ::Input::Initialization:: *)
MARKRules={"fitpoint"->1};


(* ::Input::Initialization:: *)
CWIGGLERRules={};


WATCHRules={};


(* ::Input::Initialization:: *)
RFRules={"END1_FOCUS"->1,"END2_FOCUS"->1,"N_KICKS"->50,"BODY_FOCUS_MODEL"-> "SRS"};


(* ::Input::Initialization:: *)
commandDefinition/:capitalRuleNames[commandDefinition[list__]]:=Map[Rule[StringReplace[ToLowerCase[#[[1]]],"sdds"->"SDDS"],#[[2]]]&,{list}]


$elegantPath="";


$sddsPath="";


$elegantFilename="elegant";


(* ::Input::Initialization:: *)
Begin["`Private`"]


ElegantRun[filename_]:=Block[{},
ReadList["!"<>$elegantPath<>If[$elegantPath=!="","\\",""]<>$elegantFilename<>" "<>filename,Record]
]


sddsCommand[command_String, filename_String,opts___Rule]:=Block[{createOutput},
createOutput=Global`CreateOutput/.{opts}/.{Global`CreateOutput->False};
If[createOutput==True,
ReadList["!"<>$sddsPath<>If[$sddsPath=!="","\\",""]<>command<>" "<>filename<>" "<>filename<>"."<>command,Record];
sddsBinaryInterpret[filename<>".analysis",opts],
sddsBinaryInterpret[OpenRead["!"<>command<>" -pipe=output "<>filename,BinaryFormat->True],opts]
]
]


sddsAnalyzeBeam[filename_,opts___Rule]:=Block[{createOutput},
createOutput=Global`CreateOutput/.{opts}/.{Global`CreateOutput->False};
If[createOutput==True,
ReadList["!"<>$elegantPath<>If[$elegantPath=!="","\\",""]<>"sddsanalyzebeam "<>filename<>" "<>filename<>".analysis",Record];
sddsBinaryInterpret[filename<>".analysis",opts],
sddsBinaryInterpret[OpenRead["!"<>$elegantPath<>If[$elegantPath=!="","\\",""]<>"sddsanalyzebeam -pipe=output "<>filename,BinaryFormat->True],opts]
]
]


(* ::Input::Initialization:: *)
Clear[elegantMultipole];
elegantMultipole[data_List]:=Block[{extralist},
extralist=ToExpression[data[[1]]<>"Extra"];
Quiet[order=Check[Position[extralist[[Range[6,24,2]]],_?(Abs[#]>0&)][[1,1]],1]];
{extralist[[Range[6,24,2][[order]]]],order-1}
]


(* ::Input::Initialization:: *)
SetAttributes[ElegantWrite,HoldAll];
ElegantWrite[latticein_,filename_,latticename___String:"",opts___Rule]:=Module[{name,file,writeErrors=False,slices=1,lattice},
writeErrors=Global`WriteErrors/.{opts}/.{Global`WriteErrors->False};
slices=Global`Slices/.{opts}/.{Global`Slices->1};
lattice=Madtomma`MADInput`MADInput`MADSplitElementsAll[latticein,slices]; 
Clear[ELEMENT];
Clear[BEAMLINE];
ELEMENT[All]:=Cases[DownValues[ELEMENT],HoldPattern[ELEMENT[_String]],3];
BEAMLINE[All]:=Cases[DownValues[BEAMLINE],HoldPattern[BEAMLINE[_String]],3];
If[latticename=="",name=ToString[HoldForm[latticein]],name=latticename];
Block[{data},
data=Join[#,ToExpression[#[[1]]<>"Extra"]];
ELEMENT[data[[1]]]=N@Join[Switch[#[[2]],
"SectorBend",Join[{"Name"->data[[1]],"Type"->"CSBEND","l"->data[[3]],"angle"->data[[6]],"e1"->data[[5+7]],"e2"->data[[6+7]],"k1"->data[[4]]},SBENDRules],
"CSectorBend",Join[{"Name"->data[[1]],"Type"->"CSBEND","l"->data[[3]],"angle"->data[[6]],"e1"->data[[5+7]],"e2"->data[[6+7]],"k1"->data[[4]]},CSBENDRules],
"CSRCSectorBend",Join[{"Name"->data[[1]],"Type"->"CSRCSBEND","l"->data[[3]],"angle"->data[[6]],"e1"->data[[5+7]],"e2"->data[[6+7]],"k1"->data[[4]]},CSRCSBENDRules],
"RectBend",Join[{"Name"->data[[1]],"Type"->"RBEND","l"->data[[3]],"angle"->data[[6]],"e1"->data[[5+7]],"e2"->data[[6+7]],"k1"->data[[4]]},RBENDRules],
"CWiggler",Join[{"Name"->data[[1]],"Type"->"CWIGGLER","l"->data[[3]],"B_MAX"->data[[4]]},If[data[[5]]=!="",{"BX_FILE"->data[[5]]},{}],If[data[[6]]=!="",{"BY_FILE"->data[[5]]},{}],
If[data[[7+3]]>0,{"PERIODS"->data[[7+3]]},{}],If[data[[7+4]]>0&&data[[7+4]]=!=10,{"STEPS_PER_PERIOD"->data[[7+4]]},{}],If[Abs@data[[7+5]]>0,{"BX_MAX"->data[[7+5]]},{}],If[Abs@data[[7+6]]>0,{"BY_MAX"->data[[7+6]]},{}],If[data[[7+7]]>0,{"SINUSOIDAL"->data[[7+7]]},{}],If[data[[7+8]]>0,{"VERTICAL"->data[[7+8]]},{}],If[data[[7+9]]>0,{"HELICAL"->data[[7+9]]},{}],If[Abs@data[[7+10]]>0,{"DX"->data[[7+10]]},{}],If[Abs@data[[7+11]]>0,{"DY"->data[[7+11]]},{}],If[Abs@data[[7+12]]>0,{"DZ"->data[[7+12]]},{}],If[Abs@data[[7+13]]>0,{"TILT"->data[[7+13]]},{}],CWIGGLERRules],
"Quadrupole",Join[{"Name"->data[[1]],"Type"->"KQUAD","l"->data[[3]],"k1"->data[[4]]},QUADRules],
"Sextupole",Join[{"Name"->data[[1]],"Type"->"KSEXT","l"->data[[3]],"k2"->data[[4]]},SEXTRules],
"Octupole",Join[{"Name"->data[[1]],"Type"->"KOCT","l"->data[[3]],"k3"->data[[4]]},SEXTRules],
"Solenoid",Join[{"Name"->data[[1]],"Type"->"SOLE","l"->data[[3]],"ks"->data[[4]]},{}],
"Drift",Join[{"Name"->data[[1]],"Type"->"DRIFT","l"->data[[3]]},{}],
"CSRDrift",Join[{"Name"->data[[1]],"Type"->"CSRDRIFT","l"->data[[3]]},CSRDriftRules],
"Marker",Join[{"Name"->data[[1]],"Type"->"MARKER"},MARKRules],
"Watch",Join[{"Name"->data[[1]],"Type"->"Watch","Filename"->"\""<>data[[4]]<>"\""},WATCHRules],
"Monitor",Join[{"Name"->data[[1]],"Type"->"MONI","l"->data[[3]]},{}],
"BPM",Join[{"Name"->data[[1]],"Type"->"MONI","l"->data[[3]]},{}],
"VBPM",Join[{"Name"->data[[1]],"Type"->"MONI","l"->data[[3]]},{}],
"HBPM",Join[{"Name"->data[[1]],"Type"->"MONI","l"->data[[3]]},{}],
"RCOLLIMATOR",Join[{"Name"->data[[1]],"Type"->"RCOL","l"->data[[3]],"X_MAX"->data[[5]],"Y_MAX"->data[[6]]},{}],
"ECOLLIMATOR",Join[{"Name"->data[[1]],"Type"->"ECOL","l"->data[[3]],"X_MAX"->data[[5]],"Y_MAX"->data[[6]]},{}],
"Kicker",Join[{"Name"->data[[1]],"Type"->"KICK","l"->data[[3]],"HKICK"->data[[6]],"VKICK"->data[[5]]},{}],
"HKicker",Join[{"Name"->data[[1]],"Type"->"HKICK","l"->data[[3]],"KICK"->data[[6]]},{}],
"VKicker",Join[{"Name"->data[[1]],"Type"->"VKICK","l"->data[[3]],"KICK"->data[[5]]},{}],
"LCAV",Join[{"Name"->data[[1]],"Type"->"RFCA","l"->data[[3]],"freq"->data[[14]]10^6,"PHASE"->90+(data[[13]] 360)},RFRules],
"RFC",Join[{"Name"->data[[1]],"Type"->"RFCA","l"->data[[3]],"freq"->data[[14]]10^6,"PHASE"->(data[[13]]),"VOLT"->(data[[15]]10^6)},RFRules],
"MULTIPOLE",Join[{"Name"->data[[1]],"Type"->"MULT","l"->data[[3]],Sequence@@MapThread[Rule,{{"KNL","Order"},elegantMultipole[data]}]},SEXTRules],
_,Print[data]],If[writeErrors,Map[ReplacePart[#,1->ToString[#[[1]]]]&,GetMADErrors[Evaluate[data[[1]]]]],{}]]]&/@Madtomma`MADInput`MADInput`MADFlatten[lattice];
BEAMLINE[name]={"Name"->name,"Type"->"LINE","Line"->MADFlatten[lattice][[All,1]]};
file= OpenWrite[filename];
Check[(
str=StringDrop[StringDrop[ToString[Replace[Drop[#,2],{Rule[x_,y_]:>x<>" = "<>StringReplace[ToString[If[NumberQ[y]&&IntegerPart[y]==y,IntegerPart[y],If[StringQ[y],y,NumberRight[Round[y,10^-6]]]]],{"$"->"_","\[Sterling]"->"-"}]},2]],1],-1];
WriteString[file,StringReplace[Evaluate["Name"/.#],{"$"->"_","\[Sterling]"->"-"}]<>":"<>Evaluate["Type"/.#]];
WriteString[file,Block[{a=If[StringLength[str]>0,", "<>str,""],b="",pos},While[StringLength[a]>80,pos=Last[Select[StringPosition[a,","][[All,1]],#<80&]];b=StringJoin[b,StringTake[a,pos]<>"&\n"];a=StringDrop[a,pos]];StringJoin[b,a]<>";\n"]]),Print[#]]&/@ELEMENT[All];
Check[(str=StringReplace[StringDrop[StringDrop[ToString[Replace[Drop[#,2],{Rule[x_,y_]:>x<>" = "<>StringReplace[ToString[y],{"$"->"_","\[Sterling]"->"-"}]},2]],1],-1],{"{"->"(","}"->")"}];
WriteString[file,StringReplace[Evaluate["Name"/.#],{"$"->"_","\[Sterling]"->"-"}]<>":"];
WriteString[file,Block[{a=" "<>str,b="",pos},While[StringLength[a]>80,pos=Last[Select[StringPosition[a,","][[All,1]],#<80&]];b=StringJoin[b,StringTake[a,pos]<>"&\n"];a=StringDrop[a,pos]];StringJoin[b,a]<>"\n"]]),Print[#]]&/@BEAMLINE[All];
Close[file];
]


(* ::Input::Initialization:: *)
ElegantRules["run_setup"]=ToLowerCase/@{"LATTICE","USE_BEAMLINE","ROOTNAME","OUTPUT","CENTROID","SIGMA","FINAL","ACCEPTANCE","LOSSES","MAGNETS","SEMAPHORE_FILE","PARAMETERS","DEFAULT_ORDER","P_CENTRAL","P_CENTRAL_MEV","ALWAYS_CHANGE_P0","ELEMENT_DIVISIONS","random_number_seed"};


(* ::Input::Initialization:: *)
ElegantRules["run_control"]=ToLowerCase/@{"N_STEPS","N_PASSES","RESET_RF_FOR_EACH_STEP","FIRST_IS_FIDUCIAL"};


(* ::Input::Initialization:: *)
ElegantRules["twiss_output"]=ToLowerCase/@{"filename","matched","output_at_each_step","output_before_tune_correction","final_values_only","statistics ","radiation_integrals","concat_order","higher_order_chromaticity","higher_order_chromaticity_points","higher_order_chromaticity_points","chromatic_tune_spread_half_range","quick_higher_order_chromaticity","beta_x","alpha_x","eta_x","etap_x","beta_y","alpha_y","eta_y","etap_y","reference_file","reference_element","reference_element_occurrence","reflect_reference_values","cavities_are_drifts_if_matched","compute_driving_terms","leading_order_driving_terms_only","local_dispersion"};


(* ::Input::Initialization:: *)
ElegantRules["matrix_output"]=StringReplace[ToLowerCase/@{"printout","printout_order","full_matrix_only","SDDS_output","SDDS_output_order","individual_matrices","SDDS_output_match","output_at_each_step","start_from","start_from_occurrence"},"sdds"->"SDDS"];


(* ::Input::Initialization:: *)
ElegantRules["floor_coordinates"]=StringReplace[ToLowerCase/@{"filename","X0","Z0","theta0","include_vertices","vertices_only","magnet_centers"},"sdds"->"SDDS"];


(* ::Input::Initialization:: *)
ElegantRules["slice_analysis"]=StringReplace[ToLowerCase/@{"output","n_slices","s_start","s_end","final_values_only"},"sdds"->"SDDS"];


(* ::Input::Initialization:: *)
ElegantRules["bunched_beam"]=StringReplace[ToLowerCase/@{"bunch","n_particles_per_bunch","time_start","matched_to_cell","emit_x","emit_nx","beta_x","alpha_x","eta_x","etap_x","emit_y","emit_ny","beta_y","alpha_y","eta_y","etap_y","use_twiss_command_values","Po","sigma_dp","sigma_s","dp_s_coupling","emit_z","beta_z","alpha_z","momentum_chirp","one_random_bunch","symmetrize","halton_sequence","halton_radix","optimized_halton","randomize_order","limit_invariants","limit_in_4d","enforce_rms_values[0]","distribution_cutoff[0]","distribution_type","centroid","first_is_fiducial","save_initial_coordinates"},"sdds"->"SDDS"];


(* ::Input::Initialization:: *)
ElegantRules["track"]=StringReplace[ToLowerCase/@{"center_on_orbit","center_momentum_also","offset_by_orbit","offset_momentum_also","soft_failure","use_linear_chromatic_matrix","longitudinal_ring_only","stop_tracking_particle_limit"},"sdds"->"SDDS"];


(* ::Input::Initialization:: *)
ElegantRules["correction_matrix_output"]=StringReplace[ToLowerCase/@{"response[0]","response[1]","response[2]","response[3]","inverse[0]","inverse[1]","KnL_units","BnL_units","output_at_each_step","output_before_tune_correction","fixed_length","coupled","use_response_from_computed_orbits"},"sdds"->"SDDS"];


(* ::Input::Initialization:: *)
ElegantRules["correct"]=StringReplace[ToLowerCase/@{"mode","method","trajectory_output","corrector_output","statistics","corrector_tweek","corrector_limit","correction_fraction","correction_accuracy","do_correction","remove_smallest_SVs","keep_largest_SVs","minimum_SV_ratio","auto_limit_SVs","removed_pegged","threading_divisor","threading_correctors","bpm_noise","bpm_noise_cutoff","bpm_noise_distribution","verbose","fixed_length","fixed_length_matrix","n_xy_cycles","minimum_cycles","n_iterations","prezero_correctors","track_before_and_after","start_from_centroid","use_actual_beam","closed_orbit_accuracy","closed_orbit_iterations","closed_orbit_iteration_fraction","use_perturbed_matrix","disable","use_response_from_computed_orbits"},"sdds"->"SDDS"];


(* ::Input::Initialization:: *)
ElegantRules["closed_orbit"]=StringReplace[ToLowerCase/@{"output","output_monitors_only","start_from_centroid","start_from_dp_centroid","closed_orbit_accuracy","closed_orbit_iterations","iteration_fraction","fixed_length","start_from_recirc","verbosity"},"sdds"->"SDDS"];


(* ::Input::Initialization:: *)
ElegantRules["error_control"]=StringReplace[ToLowerCase/@{"clear_error_settings","summarize_error_settings","no_errors_for_first_step","error_log","error_factor"
},"sdds"->"SDDS"];


(* ::Input::Initialization:: *)
ElegantRules["error_element"]=StringReplace[ToLowerCase/@{"name","element_type","item","type","amplitude","cutoff","bind","bind_number","bind_across_names","post_correction","fractional","additive","allow_missing_elements","after","before"},"sdds"->"SDDS"];


(* ::Input::Initialization:: *)
addRules[rules_]:=Block[{},
Union[Flatten[Switch[Head[#],
String,{#,ToUpperCase[#],ToLowerCase[#]},
Symbol,{#,ToString[#],ToUpperCase[ToString[#]],ToLowerCase[ToString[#]],Symbol@ToUpperCase[ToString[#]],Symbol@ToLowerCase[ToString[#]]},
Rule,Block[{a=#[[1]],b=#[[2]]},
Map[Rule[#,b]&,{a,ToString[a],ToUpperCase[ToString[a]],ToLowerCase[ToString[a]],Symbol@ToUpperCase[ToString[a]],Symbol@ToLowerCase[ToString[a]]}]
]
]&/@rules]]
]


(* ::Input::Initialization:: *)
formatString[in_]:=Block[{},
Switch[Head[in],
String,in,
Real,ToString[numberRight[in]],
Integer,ToString[in],
Rational,ToString[CForm[in]],
List,MapIndexed[If[#2[[1]]>1,",",""]<>ToString[CForm[#]]&,in],
_,ToString[numberRight[in]]
]
]


(* ::Input::Initialization:: *)
Clear[elegantWriteCommand];
elegantWriteCommand[list__commandDefinition]:=Block[{option},
option=capitalRuleNames[#];
"&"<>("command"/.option)<>"\n"<>StringJoin@@(Switch[Head[#],
List,If[(#/.option/.{#->Null})=!=Null,"\t"<>ToString[#]<>"="<>StringDrop[StringDrop[formatString[Evaluate[(#/.option)]],-1],1]<>"\n",""],
Symbol,If[(#/.option/.{#->Null})=!=Null,"\t"<>ToString[#]<>"="<>formatString[Evaluate[(#/.option)]]<>"\n",""],
String,If[(#/.option/.{#->Null})=!=Null,"\t"<>ToString[#]<>"="<>formatString[Evaluate[(#/.option)]]<>"\n",""],
Rule,If[(#[[1]]/.option/.{#[[1]]->Null})=!=Null,"\t"<>ToString[#[[2]]]<>"="<>formatString[Evaluate[(#[[1]]/.option)]]<>"\n",""]
]&/@ElegantRules[ToLowerCase[Evaluate["command"/.option]]])<>"&end\n\n"
]&/@Union[{list},SameTest->(("command"/.capitalRuleNames[#1])==("command"/.capitalRuleNames[#2])&)]


(* ::Input::Initialization:: *)
Clear[elegantWriteCommandStrings];
SetAttributes[elegantWriteCommandStrings,HoldFirst];
elegantWriteCommandStrings[commands_]/;Head[Evaluate[commands]]==List:=Block[{},
Map[elegantWriteCommand[#]&,commands]
]


(* ::Input::Initialization:: *)
Clear[ElegantWriteCommands];
SetAttributes[ElegantWriteCommands,HoldFirst];
ElegantWriteCommands[commands_List,filename_]:=Block[{file},
file=OpenWrite[filename];
Map[WriteString[file,StringJoin@@#]&,elegantWriteCommandStrings[Select[commands,Length[Cases[capitalRuleNames[#],Rule["command",a_]:>a]]>0&]]];
Close[file]
];
ElegantWriteCommands[commands_commandDefinition,filename_]:=Block[{file},
file=OpenWrite[filename];
Map[WriteString[file,StringJoin@@#]&,elegantWriteCommandStrings[Select[{commands},Length[Cases[capitalRuleNames[#],Rule["command",a_]:>a]]>0&]]];
Close[file]
];


(* ::Input::Initialization:: *)
SetAttributes[ElegentTwiss,HoldFirst];
ElegentTwiss[lattice_,commands___commandDefinition,opts___Rule]:=Block[{filename},
filename="temp";
runsetup=commandDefinition[opts,"LATTICE"->FileBaseName[filename]<>".lte","command"->"run_setup","use_beamline"->HoldForm[lattice],"p_central_mev"->1000];
runcontrol=commandDefinition[opts,"n_steps"->1,"n_passes"->1,"Command"->"run_control"];
twissoutput=commandDefinition[opts,"filename"->"%s.twi","matched"->1,"Command"->"twiss_output"];
matrixoutput=commandDefinition[opts,"SDDS_output"->"%s.matrix","SDDS_output_order"->2,"individual_matrices"->0,"Command"->"matrix_output"];
flooroutput=commandDefinition[opts,"filename"->"%s.flr","Command"->"floor_coordinates"];
ElegantWriteCommands[{runsetup,runcontrol,twissoutput,matrixoutput,flooroutput,commands},filename<>".ele"];
ElegantWriteLattice[lattice,filename<>".lte"];
ReadList["!elegant "<>filename<>".ele",Record];
sddsBinaryInterpret[filename<>".twi"]
]


ElegantCreateErrorCommands[lattice_]:=Sequence@@Map[Block[{name=#[[1]]},Sequence@@Map[commandDefinition["name"->name,"item"->#[[1]],"amplitude"->#[[2]],"Command"->"error_element"]&,#[[2]]]]&,Map[{#[[1]],GetMADErrors[Evaluate[#[[1]]]]}&,Union[MADFlatten[lattice]]]]


(* ::Input::Initialization:: *)
End[]


(* ::Input::Initialization:: *)
EndPackage[]
